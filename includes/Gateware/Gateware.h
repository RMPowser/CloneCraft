#ifndef GATEWARE_H
#define GATEWARE_H
/* File created by GW Header Compiler version 1.2.0 */

/*
The MIT License (MIT)

Copyright (c) 2016-2020 7thGate Software .LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************

The MIT License (MIT)

Copyright (c) 1998-2019 Toni Ronkko

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************

Copyright (c) 2017 The Khronos Group Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*******************************************************************************

Copyright (c) 2013-2017 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

*******************************************************************************


*/
// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 1
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 2
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'a'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "development"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x6d438ef0d0
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v1.2a"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v1.2a (development) [6d438ef0d0]"

#endif

/*---------------------------------
|	Begin of GGraphicsDefines.h
----------------------------------*/
#ifndef GGRAPHICSDEFINES_H
#define GGRAPHICSDEFINES_H


namespace GW
{
	namespace GRAPHICS
	{
		enum GGraphicsInitOptions
		{
			COLOR_10_BIT			= 0x1,		
			DEPTH_BUFFER_SUPPORT	= 0x2,		
			DEPTH_STENCIL_SUPPORT	= 0X4,		
			OPENGL_ES_SUPPORT		= 0x8,		
			DIRECT2D_SUPPORT		= 0x10,		
			TRIPLE_BUFFER			= 0x20,		
			MSAA_2X_SUPPORT			= 0x40,		
			MSAA_4X_SUPPORT			= 0x80,		
			MSAA_8X_SUPPORT			= 0x100,	
			MSAA_16X_SUPPORT		= 0x200,	
			MSAA_32X_SUPPORT		= 0x400,	
			MSAA_64X_SUPPORT		= 0x800,	
		};

		enum GRasterUpdateFlags
		{
			ALIGN_X_LEFT			= 0x0001, 
			ALIGN_X_CENTER			= 0x0002, 
			ALIGN_X_RIGHT			= 0x0004, 
			ALIGN_Y_TOP				= 0x0008, 
			ALIGN_Y_CENTER			= 0x0010, 
			ALIGN_Y_BOTTOM			= 0x0020, 
			UPSCALE_2X				= 0x0040, 
			UPSCALE_3X				= 0x0080, 
			UPSCALE_4X				= 0x0100, 
			UPSCALE_8X				= 0x0200, 
			UPSCALE_16X				= 0x0400, 
			STRETCH_TO_FIT			= 0x0800, 
			INTERPOLATE_NEAREST		= 0x1000, 
			INTERPOLATE_BILINEAR	= 0x2000, 
		};
	}
}

#endif // GGRAPHICSDEFINES_H

/*---------------------------------
|	End of GGraphicsDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GMathDefines.h
----------------------------------*/
#ifndef GMATHDEFINES_H
#define GMATHDEFINES_H


#define G_PI					3.14159265358979323846
#define G_PI_F					3.141592f

#define G_PI_R					0.318309886183790671538
#define G_PI_R_F				0.3183098f

#define G_EPSILON_F				1.192092896e-07F
#define G_EPSILON_D				2.2204460492503131e-016

#define G_ABS(num)				( ( (num) > 0 ) ?  (num) : (-(num)) )	//RETURN THE ABSOLUTE VALUE OF THE INPUT NUMBER
#define G_LARGER(A, B)			( ( (A) > (B) ) ?  (A) : (B) )			//RETURN THE LARGER INPUT NUMBER
#define G_SMALLER(A, B)			( ( (A) < (B) ) ?  (A) : (B) )			//RETURN THE SMALLER INPUT NUMBER
#define G_ABS_LARGER(A, B)		( ( G_ABS(A) > G_ABS(B) ) ?  G_ABS(A) : G_ABS(B) )

#define G_DEVIATION_EXACT 0
#define G_DEVIATION_PRECISE_F G_EPSILON_F
#define G_DEVIATION_STANDARD_F (G_EPSILON_F * 10)
#define G_DEVIATION_LOOSE_F (G_EPSILON_F * 100)

#define G_DEVIATION_PRECISE_D G_EPSILON_D
#define G_DEVIATION_STANDARD_D (G_EPSILON_D * 10)
#define G_DEVIATION_LOOSE_D (G_EPSILON_D * 100)

#define G_FIRST_COMPARISON_F(num1 , num2)   ( G_ABS( (num1) - (num2) ) <= ( G_EPSILON_F ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G_SECOND_COMPARISON_F(num1 , num2)   ( G_ABS( (num1) - (num2) ) <= ( G_DEVIATION_STANDARD_F * G_ABS_LARGER(num1, num2)) ) 	//SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G_COMPARISON_STANDARD_F(num1 , num2)   ( G_FIRST_COMPARISON_F( (num1), (num2) ) ? true : G_SECOND_COMPARISON_F( (num1) , (num2) ) )
#define G_COMPARISON_F(num1, num2, deviation) ( G_FIRST_COMPARISON_F( (num1), (num2) )	? true :  ( G_ABS( (num1) - (num2) ) <=  ( deviation * G_ABS_LARGER(num1, num2)) )  )

#define G_FIRST_COMPARISON_D(num1 , num2)   ( G_ABS( (num1) - (num2) ) <= ( G_EPSILON_D ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G_SECOND_COMPARISON_D(num1 , num2)   ( G_ABS( (num1) - (num2) ) <= ( G_DEVIATION_STANDARD_D * G_ABS_LARGER(num1, num2)) ) //SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G_COMPARISON_STANDARD_D(num1 , num2)   ( G_FIRST_COMPARISON_D( (num1), (num2) ) ? true : G_SECOND_COMPARISON_D( (num1) , (num2) ) )
#define G_COMPARISON_D(num1 , num2, deviation)   ( G_FIRST_COMPARISON_D( (num1), (num2) ) ? true :( G_ABS( (num1) - (num2) ) <= ( deviation * (G_ABS_LARGER(num1, num2))) )  )

#define G_LERP(start , end, ratio)  ( start + ratio * (end - start) )		//LINEAR INTERPOLATE TWO POINT WITH THE RATIO
#define G_CLAMP(num, min, max)  (((num) > (max)) ? (max) : (((num) < (min)) ? (min) : (num)))	//CLAMP THE NUMBER BETWEEN THE TOP NUMBER AND THE BOTTOM NUMBER

#define G_DEGREE_TO_RADIAN(degree) ( (degree) * ( (G_PI) / (180.0) ) )
#define G_RADIAN_TO_DEGREE(radian) ( (radian) * ( (180.0) / (G_PI) ) )


namespace GW
{
	namespace MATH
	{

		// Ensure identical binary padding for structures on all platforms.
#pragma pack(push, 1)

		struct GVECTORF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float w;
				};
				float data[4];
			};

			inline const GVECTORF xy() const
			{
				return GVECTORF{{{this->x, this->y, 0.0f, 0.0f}}};
			}

			inline const GVECTORF xyz() const
			{
				return GVECTORF{{{this->x, this->y, this->z, 0.0f}}};
			}

			inline const GVECTORF xyzw() const
			{
				return *this;
			}
		};

		struct GVECTORD
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double w;
				};
				double data[4];
			};

			inline const GVECTORD xy() const
			{
				return GVECTORD{{{this->x, this->y, 0.0, 0.0}}};
			}

			inline const GVECTORD xyz() const
			{
				return GVECTORD{{{this->x, this->y, this->z, 0.0}}};
			}

			inline const GVECTORD xyzw() const
			{
				return *this;
			}
		};
		struct GMATRIXF
		{
			union
			{
				struct
				{
					GVECTORF row1;
					GVECTORF row2;
					GVECTORF row3;
					GVECTORF row4;
				};

				float data[16];
			};
		};

		struct GMATRIXD
		{
			union
			{
				struct
				{
					GVECTORD row1;
					GVECTORD row2;
					GVECTORD row3;
					GVECTORD row4;
				};
				double data[16];
			};
		};

		struct GQUATERNIONF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float w;
				};
				float data[4];
			};
		};

		struct GQUATERNIOND
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double w;
				};
				double data[4];
			};
		};

		struct GLINEF
		{
			union
			{
				struct
				{
					GVECTORF start;
					GVECTORF end;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GLINED
		{
			union
			{
				struct
				{
					GVECTORD start;
					GVECTORD end;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GRAYF
		{
			union
			{
				struct
				{
					GVECTORF position;
					GVECTORF direction;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GRAYD
		{
			union
			{
				struct
				{
					GVECTORD position;
					GVECTORD direction;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GTRIANGLEF
		{
			union
			{
				struct
				{
					GVECTORF a;
					GVECTORF b;
					GVECTORF c;
				};
				GVECTORF data[3];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GTRIANGLED
		{
			union
			{
				struct
				{
					GVECTORD a;
					GVECTORD b;
					GVECTORD c;
				};
				GVECTORD data[3];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GPLANEF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float distance;
				};
				GVECTORF data;
			};

			GVECTORF* operator&()
			{
				return &data;
			}

			const GVECTORF* operator&() const
			{
				return &data;
			}
		};

		struct GPLANED
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double distance;
				};
				GVECTORD data;
			};

			GVECTORD* operator&()
			{
				return &data;
			}

			const GVECTORD* operator&() const
			{
				return &data;
			}
		};

		struct GSPHEREF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float radius;
				};
				GVECTORF data;
			};

			GVECTORF* operator&()
			{
				return &data;
			}

			const GVECTORF* operator&() const
			{
				return &data;
			}
		};

		struct GSPHERED
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double radius;
				};
				GVECTORD data;
			};

			GVECTORD* operator&()
			{
				return &data;
			}

			const GVECTORD* operator&() const
			{
				return &data;
			}
		};

		struct GCAPSULEF
		{
			union
			{
				struct
				{
					float start_x;
					float start_y;
					float start_z;
					float radius;
					float end_x;
					float end_y;
					float end_z;
					float reserved;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GCAPSULED
		{
			union
			{
				struct
				{
					double start_x;
					double start_y;
					double start_z;
					double radius;
					double end_x;
					double end_y;
					double end_z;
					double reserved;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GAABBCEF
		{
			union
			{
				struct
				{
					GVECTORF center;
					GVECTORF extent;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GAABBCED
		{
			union
			{
				struct
				{
					GVECTORD center;
					GVECTORD extent;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GAABBMMF
		{
			union
			{
				struct
				{
					GVECTORF min;
					GVECTORF max;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GAABBMMD
		{
			union
			{
				struct
				{
					GVECTORD min;
					GVECTORD max;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GOBBF
		{
			union
			{
				struct
				{
					GVECTORF center;
					GVECTORF extent;
					GQUATERNIONF rotation;
				};
				GVECTORF data[3];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GOBBD
		{
			union
			{
				struct
				{
					GVECTORD center;
					GVECTORD extent;
					GQUATERNIOND rotation;
				};
				GVECTORD data[3];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};
#pragma pack(pop)

		static const GVECTORF GIdentityVectorF{{{0,0,0,1}}};
		static const GVECTORD GIdentityVectorD{{{0,0,0,1}}};
		static const GVECTORF GZeroVectorF{{{0,0,0,0}}};
		static const GVECTORD GZeroVectorD{{{0,0,0,0}}};

		static const GMATRIXF GIdentityMatrixF{{{{{{1,0,0,0}}},{{{0,1,0,0}}},{{{0,0,1,0}}},{{{0,0,0,1}}}}}};
		static const GMATRIXD GIdentityMatrixD{{{{{{1,0,0,0}}},{{{0,1,0,0}}},{{{0,0,1,0}}},{{{0,0,0,1}}}}}};
		static const GMATRIXF GZeroMatrixF{{{{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}}}}};
		static const GMATRIXD GZeroMatrixD{{{{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}}}}};

		static const GQUATERNIONF GIdentityQuaternionF{{{0,0,0,1}}};
		static const GQUATERNIOND GIdentityQuaternionD{{{0,0,0,1}}};
		static const GQUATERNIONF GZeroQuaternionF{{{0,0,0,0}}};
		static const GQUATERNIOND GZeroQuaternionD{{{0,0,0,0}}};
	}
}
#endif // GMATHDEFINES_H


/*---------------------------------
|	End of GMathDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GInputDefines.h
----------------------------------*/
#ifndef GINPUTDEFINES_H
#define GINPUTDEFINES_H



// All GInput/GBufferedInput Key definitions follow
#define G_KEY_UNKNOWN			0x0			 

#define G_KEY_ESCAPE			0x1			 
#define G_KEY_MINUS				0x2			 
#define G_KEY_EQUALS			0x3			 
#define G_KEY_BACKSPACE			0x4			 
#define G_KEY_TAB				0x5			 
#define G_KEY_BRACKET_OPEN		0x6			 
#define G_KEY_BRACKET_CLOSE		0x7			 
#define G_KEY_ENTER				0x8			 
#define G_KEY_CONTROL			0x9			 
#define G_KEY_COLON				0xa			 
#define G_KEY_QUOTE				0xb			 
#define G_KEY_TILDE				0xc			 
#define G_KEY_LEFTSHIFT			0xd			 
#define G_KEY_BACKSLASH			0xe			 
#define G_KEY_COMMA				0xf			 
#define G_KEY_PERIOD			0x10		 
#define G_KEY_FOWARDSLASH		0x11		 
#define G_KEY_RIGHTSHIFT		0x12		 
#define G_KEY_PRINTSCREEN		0x13		 
#define G_KEY_LEFTALT			0x14		 
#define G_KEY_RIGHTALT			0x15		 
#define G_KEY_SPACE				0x16		 
#define G_KEY_CAPSLOCK			0x17		 
#define G_KEY_NUMLOCK			0x18		 
#define G_KEY_SCROLL_LOCK		0x19		 
#define G_KEY_HOME				0x1a		 
#define G_KEY_UP				0x1b		 
#define G_KEY_PAGEUP			0x1c		 
#define G_KEY_NUMPAD_MINUS		0x1d		 
#define G_KEY_LEFT				0x1e		 
#define G_KEY_CENTER			0x1f		 
#define G_KEY_RIGHT				0x20		 
#define G_KEY_NUMPAD_PLUS		0x21		 
#define G_KEY_END				0x22		 
#define G_KEY_DOWN				0x23		 
#define G_KEY_PAGEDOWN			0x24		 
#define G_KEY_INSERT			0x25		 
#define G_KEY_DELETE			0x26		 

// Characters
#define G_KEY_A					0x27		 
#define G_KEY_B					0x28		 
#define G_KEY_C					0x29		 
#define G_KEY_D					0x2a		 
#define G_KEY_E					0x2b		 
#define G_KEY_F					0x2c		 
#define G_KEY_G					0x2d		 
#define G_KEY_H					0x2e		 
#define G_KEY_I					0x2f		 
#define G_KEY_J					0x30		 
#define G_KEY_K					0x31		 
#define G_KEY_L					0x32		 
#define G_KEY_M					0x33		 
#define G_KEY_N					0x34		 
#define G_KEY_O					0x35		 
#define G_KEY_P					0x36		 
#define G_KEY_Q					0x37		 
#define G_KEY_R					0x38		 
#define G_KEY_S					0x39		 
#define G_KEY_T					0x3a		 
#define G_KEY_U					0x3b		 
#define G_KEY_V					0x3c		 
#define G_KEY_W					0x3d		 
#define G_KEY_X					0x3e		 
#define G_KEY_Y					0x3f		 
#define G_KEY_Z					0x40		 

// Numbers
#define G_KEY_0					0x41		 
#define G_KEY_1					0x42		 
#define G_KEY_2					0x43		 
#define G_KEY_3					0x44		 
#define G_KEY_4					0x45		 
#define G_KEY_5					0x46		 
#define G_KEY_6					0x47		 
#define G_KEY_7					0x48		 
#define G_KEY_8					0x49		 
#define G_KEY_9					0x4a		 

// Function Keys
#define G_KEY_F1				0x4b		 
#define G_KEY_F2				0x4c		 
#define G_KEY_F3				0x4d		 
#define G_KEY_F4				0x4e		 
#define G_KEY_F5				0x4f		 
#define G_KEY_F6				0x50		 
#define G_KEY_F7				0x51		 
#define G_KEY_F8				0x52		 
#define G_KEY_F9				0x53		 
#define G_KEY_F10				0x54		 
#define G_KEY_F11				0x55		 
#define G_KEY_F12				0x56		 

// PEMDAS
#define G_KEY_ADD				0x57		 
#define G_KEY_MULTIPLY			0x59		 
#define G_KEY_DIVIDE			0x5a		 

// Button Keys
#define G_BUTTON_LEFT			0x64		 
#define G_BUTTON_RIGHT			0x65		 
#define G_BUTTON_MIDDLE			0x66		 
#define G_MOUSE_SCROLL_UP		0x67		 
#define G_MOUSE_SCROLL_DOWN		0x68		 

// Key Masks 
#define G_MASK_SHIFT			0x0			 
#define G_MASK_CAPS_LOCK		0x1			 
#define G_MASK_CONTROL			0x2			 
#define G_MASK_SCROLL_LOCK		0x3			 
#define G_MASK_NUM_LOCK			0x4			 
#define G_MASK_COMMAND          0x5			 
#define G_MASK_ALT              0x6			 
#define G_MASK_FUNCTION         0x7			 



// All GController Input definitions follow
#define G_SOUTH_BTN						0x00 
#define G_EAST_BTN						0x01 
#define G_NORTH_BTN						0x02 
#define G_WEST_BTN						0x03 
#define G_LEFT_SHOULDER_BTN				0x04 
#define G_RIGHT_SHOULDER_BTN			0x05 
#define G_LEFT_TRIGGER_AXIS				0x06 
#define G_RIGHT_TRIGGER_AXIS			0x07 
#define G_DPAD_LEFT_BTN					0x08 
#define G_DPAD_RIGHT_BTN				0x09 
#define G_DPAD_UP_BTN					0x0A 
#define G_DPAD_DOWN_BTN					0x0B 
#define G_LEFT_THUMB_BTN				0x0C 
#define G_RIGHT_THUMB_BTN				0x0D 
#define G_START_BTN						0x0E 
#define G_SELECT_BTN					0x0F 
#define G_LX_AXIS						0x10 
#define G_LY_AXIS						0x11 
#define G_RX_AXIS						0x12 
#define G_RY_AXIS						0x13 
#define G_UNKOWN_INPUT                  0xff 


// Bit-manip macros
#define G_CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define G_TURNON_BIT(var,pos) ((var) |=  (1<<(pos)))
#define G_TURNOFF_BIT(var,pos) ((var) &= ~(1<<(pos)))
#define G_TOGGLE_BIT(var, pos) (G_CHECK_BIT(var, pos) ? (G_TURNOFF_BIT(var,pos)) : (G_TURNON_BIT(var,pos)))

// The interval daemon operation will run at for GInput (Linux only)
#define G_INPUT_OPERATION_INTERVAL 4
// The interval daemon operation will run at for GBufferedInput (Linux only)
#define G_BUFFEREDINPUT_OPERATION_INTERVAL 6
// The interval daemon operation will run at for GController
#define G_CONTROLLER_DAEMON_OPERATION_INTERVAL 4
// The interval daemon operation will run at for GController notify daemon
#define G_CONTROLLER_NOTIFY_DAEMON_OPERATION_INTERVAL 2

namespace GW
{
	namespace INPUT
	{
		enum class GControllerType
		{
			GENERAL,	
			PS3,		
			PS4,		
			PS5,		
			STEAM,		
			SWITCHPRO,	
			XBOX360,	
			XBOXONE,	
			XBOXSERIES,	
		};
	}
}
#endif // #endif GINPUTDEFINES_H

/*---------------------------------
|	End of GInputDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GMath2DDefines.h
----------------------------------*/
#ifndef GMATH2DDEFINES_H
#define GMATH2DDEFINES_H


#define G2D_PI						3.14159265358979323846
#define G2D_PI_F					3.141592f

#define G2D_PI_R					0.318309886183790671538
#define G2D_PI_R_F					0.3183098f

#define G2D_EPSILON_F				1.192092896e-07F
#define G2D_EPSILON_D				2.2204460492503131e-016

#define G2D_ABS(num)				( ( (num) > 0 ) ?  (num) : (-(num)) )	//RETURN THE ABSOLUTE VALUE OF THE INPUT NUMBER
#define G2D_MAX(A, B)			( ( (A) > (B) ) ?  (A) : (B) )			//RETURN THE LARGER INPUT NUMBER
#define G2D_MIN(A, B)			( ( (A) < (B) ) ?  (A) : (B) )			//RETURN THE SMALLER INPUT NUMBER
#define G2D_ABS_MAX(A, B)		( ( G2D_ABS(A) > G2D_ABS(B) ) ?  G2D_ABS(A) : G2D_ABS(B) )

#define G2D_DEVIATION_EXACT 0
#define G2D_DEVIATION_PRECISE_F G2D_EPSILON_F
#define G2D_DEVIATION_STANDARD_F (G2D_EPSILON_F * 10)
#define G2D_DEVIATION_LOOSE_F (G2D_EPSILON_F * 100)

#define G2D_DEVIATION_PRECISE_D G2D_EPSILON_D
#define G2D_DEVIATION_STANDARD_D (G2D_EPSILON_D * 10)
#define G2D_DEVIATION_LOOSE_D (G2D_EPSILON_D * 100)

#define G2D_FIRST_COMPARISON_F(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_EPSILON_F ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G2D_SECOND_COMPARISON_F(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_DEVIATION_STANDARD_F * G2D_ABS_MAX(num1, num2)) ) 	//SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G2D_COMPARISON_STANDARD_F(num1 , num2)   ( G2D_FIRST_COMPARISON_F( (num1), (num2) ) ? true : G2D_SECOND_COMPARISON_F( (num1) , (num2) ) )
#define G2D_COMPARISON_F(num1, num2, deviation) ( G2D_FIRST_COMPARISON_F( (num1), (num2) )	? true :  ( G2D_ABS( (num1) - (num2) ) <=  ( deviation * G2D_ABS_MAX(num1, num2)) )  )

#define G2D_FIRST_COMPARISON_D(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_EPSILON_D ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G2D_SECOND_COMPARISON_D(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_DEVIATION_STANDARD_D * G2D_ABS_MAX(num1, num2)) ) //SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G2D_COMPARISON_STANDARD_D(num1 , num2)   ( G2D_FIRST_COMPARISON_D( (num1), (num2) ) ? true : G2D_SECOND_COMPARISON_D( (num1) , (num2) ) )
#define G2D_COMPARISON_D(num1 , num2, deviation)   ( G2D_FIRST_COMPARISON_D( (num1), (num2) ) ? true :( G2D_ABS( (num1) - (num2) ) <= ( deviation * (G2D_ABS_MAX(num1, num2))) )  )

#define G2D_LERP(start , end, ratio)  ( start + ratio * (end - start) )		//LINEAR INTERPOLATE TWO POINT WITH THE RATIO
#define G2D_CLAMP(num, min, max)  (((num) > (max)) ? (max) : (((num) < (min)) ? (min) : (num)))	//CLAMP THE NUMBER BETWEEN THE TOP NUMBER AND THE BOTTOM NUMBER

#define G2D_DEGREE_TO_RADIAN(degree) ( (degree) * ( (G2D_PI) / (180.0) ) )
#define G2D_RADIAN_TO_DEGREE(radian) ( (radian) * ( (180.0) / (G2D_PI) ) )



namespace GW
{
	namespace MATH2D
	{

		// Ensure identical byte alignment for structures on all platforms.
#pragma pack(push, 1)

		struct GVECTOR2F
		{
			union 
			{
				struct
				{
					float x;
					float y;
				};
				float data[2];
			};
		};

		struct GVECTOR2D
		{
			union
			{
				struct
				{
					double x;
					double y;
				};
				double data[2];
			};
		};

		struct GVECTOR3F
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
				};
				float data[3];
			};

			inline const GVECTOR2F xy() const
			{
				return GVECTOR2F{{{this->x, this->y}}};
			}
		};

		struct GVECTOR3D
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
				};
				double data[3];
			};

			inline const GVECTOR2D xy() const
			{
				return GVECTOR2D{ {{this->x, this->y}} };
			}
		};

		struct GMATRIX2F
		{
			union
			{
				struct
				{
					GVECTOR2F row1;
					GVECTOR2F row2;
				};
				float data[4];
			};
		};

		struct GMATRIX2D
		{
			union
			{
				struct
				{
					GVECTOR2D row1;
					GVECTOR2D row2;
				};
				double data[4];
			};
		};

		struct GMATRIX3F
		{
			union
			{
				struct
				{
					GVECTOR3F row1;
					GVECTOR3F row2;
					GVECTOR3F row3;
				};
				float data[9];
			};
		};

		struct GMATRIX3D
		{
			union
			{
				struct
				{
					GVECTOR3D row1;
					GVECTOR3D row2;
					GVECTOR3D row3;
				};
				double data[9];
			};
		};

		struct GLINE2F
		{
			GVECTOR2F start;
			GVECTOR2F end;
		};

		struct GLINE2D
		{
			GVECTOR2D start;
			GVECTOR2D end;
		};

		struct GRAY2F
		{
			GVECTOR2F pos;
			GVECTOR2F dir;
		};

		struct GRAY2D
		{
			GVECTOR2D pos;
			GVECTOR2D dir;
		};

		struct GCIRCLE2F
		{
			union 
			{
				struct 
				{
					GVECTOR2F pos;
					float radius;
				};
				GVECTOR3F data;
			};
		};

		struct GCIRCLE2D
		{
			union
			{
				struct
				{
					GVECTOR2D pos;
					double radius;
				};
				GVECTOR3D data;
			};
		};

		struct GCAPSULE2F
		{
			GVECTOR2F start;
			GVECTOR2F end;
			float radius;
		};
		
		struct GCAPSULE2D
		{
			GVECTOR2D start;
			GVECTOR2D end;
			double radius;
		};

		struct GRECTANGLE2F
		{
			GVECTOR2F min;
			GVECTOR2F max;
		};

		struct GRECTANGLE2D
		{
			GVECTOR2D min;
			GVECTOR2D max;
		};

		struct GBARYCENTRICF
		{
			union
			{
				struct
				{
					float alpha;
					float beta;
					float gamma;
				};
				float data[3];
			};
		};

		struct GBARYCENTRICD
		{
			union
			{
				struct
				{
					double alpha;
					double beta;
					double gamma;
				};
				double data[3];
			};
		};

#pragma pack(pop)
		static const GVECTOR2F GZeroVector2F{ {{0,0}} };
		static const GVECTOR2D GZeroVector2D{ {{0,0}} };
		static const GVECTOR3F GZeroVector3F{ {{0,0,0}} };
		static const GVECTOR3D GZeroVector3D{ {{0,0,0}} };

		static const GMATRIX2F GIdentityMatrix2F{ {{{{{1,0}}},{{{0,1}}}}} };
		static const GMATRIX2D GIdentityMatrix2D{ {{{{{1,0}}},{{{0,1}}}}} };
		static const GMATRIX3F GIdentityMatrix3F{ {{{{{1,0,0}}},{{{0,1,0}}},{{{0,0,1}}}}} };
		static const GMATRIX3D GIdentityMatrix3D{ {{{{{1,0,0}}},{{{0,1,0}}},{{{0,0,1}}}}} };

		static const GMATRIX2F GZeroMatrix2F{ {{{{{0,0}}},{{{0,0}}}}} };
		static const GMATRIX2D GZeroMatrix2D{ {{{{{0,0}}},{{{0,0}}}}} };
		static const GMATRIX3F GZeroMatrix3F{ {{{{{0,0,0}}},{{{0,0,0}}},{{{0,0,0}}}}} };
		static const GMATRIX3D GZeroMatrix3D{ {{{{{0,0,0}}},{{{0,0,0}}},{{{0,0,0}}}}} };
	}
}
#endif // GMATH2DDEFINES_H

/*---------------------------------
|	End of GMath2DDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudioDefines.h
----------------------------------*/
#ifndef GAUDIODEFINES_H
#define GAUDIODEFINES_H

// Count of implemented GATTENUATION
#define G_IMPLEMENTED_ATTENUATIONS 1

namespace GW
{
	namespace AUDIO
	{

		enum GATTENUATION
		{
			LINEAR,

			// LOGARITHMIC,

			// LOGREVERSE,

			// INVERSE,

			// NATURAL
		};

	}
}

#endif

/* Information from GAudioLinux.hpp
	PA_CHANNEL_POSITION_MONO

	PA_CHANNEL_POSITION_FRONT_LEFT
	Apple, Dolby call this 'Left'.

	PA_CHANNEL_POSITION_FRONT_RIGHT
	Apple, Dolby call this 'Right'.

	PA_CHANNEL_POSITION_FRONT_CENTER
	Apple, Dolby call this 'Center'.

	PA_CHANNEL_POSITION_REAR_CENTER
	Microsoft calls this 'Back Center', Apple calls this 'Center Surround', Dolby calls this 'Surround Rear Center'.

	PA_CHANNEL_POSITION_REAR_LEFT
	Microsoft calls this 'Back Left', Apple calls this 'Left Surround' (!), Dolby calls this 'Surround Rear Left'.

	PA_CHANNEL_POSITION_REAR_RIGHT
	Microsoft calls this 'Back Right', Apple calls this 'Right Surround' (!), Dolby calls this 'Surround Rear Right'.
*/

/*---------------------------------
|	End of GAudioDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GCoreDefines.h
----------------------------------*/
#ifndef GCOREDEFINES_H
#define GCOREDEFINES_H


// The Gateware proxy pattern is fundamentally built upon std::weak & std::shared
// Gateware Event communication is based on a type erasure observer pattern <typeinfo>
#include <memory>
#include <algorithm>

namespace GW
{

	enum class GReturn : int
	{
		// additional failure codes here
		NO_IMPLEMENTATION		= -16,  
		HARDWARE_UNAVAILABLE	= -15,	
		DEADLOCK				= -14,	
		UNEXPECTED_RESULT		= -13,	
		RESOURCE_LOCKED			= -12,  
		DISCONNECTED			= -11,  
		PREMATURE_DEALLOCATION  = -10,	
		FUNCTION_DEPRECATED		= -9,	
		FEATURE_UNSUPPORTED		= -8,	
		FILE_NOT_FOUND			= -7,	
		INTERFACE_UNSUPPORTED	= -6,   
		MEMORY_CORRUPTION		= -5,	
		INVALID_ARGUMENT		= -4,	
		IGNORED					= -3,	
		EXPIRED_PROXY			= -2,	
		FAILURE					= -1,	
		EMPTY_PROXY				=  0,	
		// Here lies the split between success and failure codes
		SUCCESS					= +1,	
		REDUNDANT				= +2,   
		// additional success codes here

	}; // MOST COMMON: +1 == SUCCESS, +2 == REDUNDANT, -1 == FAILURE, -3 == IGNORED, 0 == EMPTY_PROXY, -2 == EXPIRED_PROXY(future)

};


#define G_PASS(_greturn_) (static_cast<int>(_greturn_) > 0)

#define G_FAIL(_greturn_) (static_cast<int>(_greturn_) < 1)



// Internal definition, how large a GEvent is in memory.
// Note to Gateware Developers: first 16bytes are reserved for basic type identification. Design event packets appropriately.
#define G_EVENT_BLOCK_SIZE 64u
#define G_RAW_DATA_PACKET_SIZE (((G_EVENT_BLOCK_SIZE) - ((sizeof(std::size_t) << 1)) + 2))

namespace GW
{
	inline bool operator+(const GReturn&& _rvalue) { return G_PASS(_rvalue); }
	inline bool operator-(const GReturn&& _rvalue) { return G_FAIL(_rvalue); }

	// Internal namespace for Gateware developers, Doxygen should be configured to ignore this namespace.
	namespace I {
		// Define the template class expander GProxy.
		// This is a core pillar used in the C++11 modernized version of Gateware.
		// A GProxy is a smart wrapper around a Gateware Interface & Implementation.
		// The proxy allows safe transfer and allocation/deallocation of interfaces as well as safe access.
		// Proxy rules: Copying creates safe handles but does not transfer ownership. Only moving r-values can transfer ownership.
		template<typename _Interface, typename _Implementation, typename... _CreationParams>
		class GProxy
		{
		protected:
			typedef _Interface forceRaw; // used to support the rare need of construction from raw pointers (prefer to avoid)
			typedef _Implementation forceStatic; // used to support static calls from proxy ops
			typedef std::shared_ptr<const _Interface> forceConst; // used to support const correctness in proxy ops
			typedef GProxy<_Interface, _Implementation, _CreationParams...> thisClass; // short hand for this type of class
			std::weak_ptr<_Interface> access; // most common way of access via proxy, does not require ownership
			std::shared_ptr<_Interface> storage; // Hard handle to data, not all instances use this, most are weak by default

		private:
			// All Proxys are friends of one another (required for casting)
			template<typename A, typename B, typename... C> friend class GProxy;
			// This function is what actually makes a GProxy "proxy" an interface & associated implementation.
			template<typename... _anyArgs>
			GReturn allocate(_anyArgs&&... _argTransfer)
			{
				GReturn result = GReturn::FAILURE;
				access.reset(); // clear any prior access, storage will be overwritten below
				storage = std::make_shared<_Implementation>(); // so we can write the below more safely...
				// *** A COMPILER ERROR HERE MEANS YOU ARE NOT PASSING ".Create(" A VALID SET OF ARGUMENTS ***
				// *** READ OUR INCLUDED DOCUMENTATION TO FIND THE PROPER ARGUMENTS TO ANY GATEWARE FUNCTION ***
				if (storage && G_PASS(result = dynamic_cast<_Implementation*>
					(storage.get())->Create(std::forward<_anyArgs>(_argTransfer)...)))
					access = storage; // used for primary access
				else // if we failed to create, destruct the interface immediately
					storage.reset();
				// return what happened
				return result;
			}

		public:
			// Creates an invalid but safe handle
			GProxy() = default;
			// Special constructor, allows creation from existing implementation.
			// This should only be used in conjunction with std::shared_from_this from inside an implementation.
			GProxy(const std::shared_ptr<_Interface>& _sharedFromThis)
			{
				access = storage = _sharedFromThis;
			}
			// copy constructor
			GProxy(const thisClass& _cpy)
			{
				if (this != &_cpy)
					access = _cpy.access;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			GProxy(const T& _cpy)
			{
				access = std::dynamic_pointer_cast<_Interface>(_cpy.access.lock());
			}
			// move constructor does a direct transfer since it is not considered a copy
			GProxy(thisClass&& _mov) noexcept //: storage(_mov.storage), access(_mov.access)
			{
				storage = std::move(_mov.storage);
				access = std::move(_mov.access);
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			GProxy(T&& _mov) noexcept //: storage(std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage))), access(storage)
			{
				storage = std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage));
				access = (storage) ? storage : std::dynamic_pointer_cast<_Interface>(_mov.access.lock());
			}
			// Assignment operator
			virtual thisClass& operator=(const thisClass& _cpy) final
			{
				if (this != &_cpy)
				{
					access = _cpy.access;
					storage.reset(); // copy assignment may not transfer or retain any prior ownership
				}
				return *this;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			thisClass& operator=(const T& _cpy)
			{
				access = std::dynamic_pointer_cast<_Interface>(_cpy.access.lock());
				storage.reset(); // copy assignment may not transfer or retain any prior ownership
				return *this;
			}
			// move assignment
			virtual thisClass& operator=(thisClass&& _mov) noexcept final
			{
				storage = std::move(_mov.storage);
				access = std::move(_mov.access);
				return *this;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			thisClass& operator=(T&& _mov) noexcept
			{
				storage = std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage));
				access = (storage) ? storage : std::dynamic_pointer_cast<_Interface>(_mov.access.lock());
				return *this;
			}
			// basic destructor
			~GProxy() = default;
			// Allows testing the class for validity
			virtual operator bool() const final { return !access.expired(); };
			// nullptr assignment is how to clear a proxy before waiting for it to fall out of scope
			virtual thisClass& operator =(std::nullptr_t) final { access.reset(); storage.reset(); return *this; };
			// The GProxy varadic template should match the main internal implementation "Create" function.
			// Though the templated variadic version of this function can support any set of arguments,
			// This version requires derived classes to define & support at least one specific Create variant.
			// This is required for API consistency. Alternate Create routines are supported by the next function.
			virtual GReturn Create(_CreationParams... _parameter) final
			{
				return allocate<_CreationParams...>(std::forward<_CreationParams>(_parameter)...);
			}
			// Provided for alternate Create function potential.(direct use by derived classes is optional)
			// This version is much more functional but cannot be virtual which is why the prior version exists.
			template<	typename... _AltArguments,
				typename = std::enable_if<!std::is_same< // SFINAE used to force virtual override in impl.
				std::tuple<_AltArguments...>, std::tuple<_CreationParams...> >::value>>
			GReturn Create(_AltArguments... _parameter)
			{
				return allocate<_AltArguments...>(std::forward<_AltArguments>(_parameter)...);
			}
			// Return a copy of the Proxy that allows for non-weak transfer of ownership
			// If direct ownership cannot be shared it will return an invalid handle
			virtual thisClass Share() const final
			{
				thisClass canShare;
				if (storage)
				{
					canShare.storage = storage;
					canShare.access = access;
				}
				return canShare; // r-value will invoke move to allow full transfer
			}
			// Surrenders strong ownership of your internal handle to another Proxy, weak ownership is maintained
			// If direct ownership cannot be surrendered it will return an invalid handle
			virtual thisClass Relinquish() final
			{
				thisClass canYield;
				if (storage)
				{
					canYield.storage = storage;
					canYield.access = access;
					storage.reset();
				}
				return canYield;
			}
			// Returns a direct copy of the Proxy with the current ownership status maintined
			// If direct ownership cannot be shared it will provide it's weak ownership
			virtual thisClass Mirror() const final
			{
				thisClass canReflect;
				canReflect.storage = storage;
				canReflect.access = access;
				return canReflect;
			}

			// *** BEGIN WARNING: The following operators & typedefs are provided only for advanced users, avoid unless needed. ***
			// Potentially unsafe (nullptr) access to underlying interface type, only use when a normal proxy call does not suffice
			virtual const std::shared_ptr<_Interface> operator*() noexcept final //std::move will handled by compiler
			{
				return (storage) ? storage : access.lock();
			}
			// Potentially unsafe (nullptr) access to underlying interface type, only use when a normal proxy call does not suffice
			virtual const std::shared_ptr<const _Interface> operator*() const noexcept final //std::move will handled by compiler
			{
				return (storage) ? storage : access.lock();
			}
			// Types that can be used to lock down the internal weak pointer in performance critcal areas.
			// Do not use these unless you are very familiar & comforatable with how shared & weak pointers function.
			// As a general rule of thumb only create these on the stack where you need multiple subsequent API calls.
			// These should only be in places like inner loops or code that is currently being bottlenecked by std::weak_ptr::lock.
			// If you are concerned about access performance it may make more sense to GProxy<>::Share() your proxies with systems
			// which need to constantly access them. However, for edge cases of required weak access in high-perf systems use below:
			typedef const std::shared_ptr<_Interface> burst_w; // use if you are about to author a burst of write (non-const) calls.
			typedef const std::shared_ptr<const _Interface> burst_r; // use if you are about to author a burst of read (const) calls.
			// *** END WARNING: using the above haphazzardly can & will invalidate the inherent safety of the Proxy pattern. ***
		};
		// Non-Member comparison operations allow a proxy to behave like a standard shared_ptr when compared against each other
		template<typename... L, typename... R>
		bool operator==(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs == *_rhs;
		}
		template<typename... L, typename... R>
		bool operator!=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs != *_rhs;
		}
		template<typename... L, typename... R>
		bool operator<(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs < *_rhs; // this operator required for associative container support
		}
		template<typename... L, typename... R>
		bool operator>(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs > *_rhs;
		}
		template<typename... L, typename... R>
		bool operator<=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs <= *_rhs;
		}
		template<typename... L, typename... R>
		bool operator>=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs >= *_rhs;
		}
		// Nullptr comparison support
		template<typename... T>
		bool operator==(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return !(bool)_lhs;
		}
		template<typename... T>
		bool operator==(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return !(bool)_rhs;
		}
		template<typename... T>
		bool operator!=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return (bool)_lhs;
		}
		template<typename... T>
		bool operator!=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return (bool)_rhs;
		}
		template<typename... T>
		bool operator<(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs < _rhs;
		}
		template<typename... T>
		bool operator<(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs < *_rhs;
		}
		template<typename... T>
		bool operator>(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs > _rhs;
		}
		template<typename... T>
		bool operator>(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs > *_rhs;
		}
		template<typename... T>
		bool operator<=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs <= _rhs;
		}
		template<typename... T>
		bool operator<=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs <= *_rhs;
		}
		template<typename... T>
		bool operator>=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs >= _rhs;
		}
		template<typename... T>
		bool operator>=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs >= *_rhs;
		}
	} // end I internal namespace

	// Defines the simple type-erasure struct GEvent
	// This is a another core pillar used in the C++11 modernized version of Gateware.
	// A GEvent is a generic but type-safe way to communicate small-footprint event messages to listeners.
	// All sent messages must fit within G_MESSAGE_BLOCK_SIZE total including type_info hashes.
	// A GEvent only supports safe transfer of raw data blocks(C structs, POD) & enum class types.
	// (Copy)Constructors/Destructors/Assignment Operators etc... of stored types are NOT respected in any way!
	// Future versions (c++17+) of Gateware could replace some of this with the FAR more robust std::any if needed.

	struct GEvent
	{
	private:
		std::size_t enumType = 0; // identifies stored enumerator representing the event ID
		std::size_t dataType = 0; // identifies stored structure representing the associated data bundled with an event
		// raw data containing specific enum value & data packet.
		// The leading byte of each type-erased data block records the size of the embedded data.
		// This information is used for additional data integrity verification during reads and offset jumps when required.
		unsigned char rawData[G_RAW_DATA_PACKET_SIZE] = {0,};
		// due to odd include order issues across platforms regarding std::memcpy & std::copy
		// we provide a substitution here that copies a fixed amount of bytes
		static inline void memory_copy(void *_dst, const void* _src, unsigned int _byteCount)
		{
			std::size_t* write = static_cast<std::size_t*>(_dst);
			std::size_t const *read = static_cast<std::size_t const*>(_src);
			for (; _byteCount >= sizeof(std::size_t); _byteCount -= sizeof(std::size_t))
				*write++ = *read++;
			unsigned char* w = reinterpret_cast<unsigned char*>(write);
			unsigned char const* r = reinterpret_cast<unsigned char const*>(read);
			for (; _byteCount; --_byteCount)
				*w++ = *r++;
		}
		
	public:
		template<class enumT, typename dataT>
		GReturn Write(const enumT& _eventEnumValue, const dataT& _eventData)
		{
			// ensure developers stay within data size limits of storable data types
			static_assert(	sizeof(enumT) < 256, "Enum types stored by GEvent must be < 256 bytes!");
			static_assert(	sizeof(dataT) < 256, "Data types stored by GEvent must be < 256 bytes!");
			// ensure developers do not exceed internal storage limits
			static_assert(	(sizeof(enumT) + sizeof(dataT)) <= G_RAW_DATA_PACKET_SIZE,
							"Enum + Data combined size attempted to be stored by GEvent is too large!");
			// ensure developers do not send types other than an enum to identify their events
			static_assert(	std::is_enum<enumT>::value,
							"Gateware Events{} are required to use an \"enum class\" list to identify themselves!");
			// ensure developers use only C Style stuctures & basic enumerators for information transfer
			static_assert(	std::is_trivially_copyable<dataT>::value,
							"Enum & Data Types must be fully tranferable with std:memcpy only! Plain Old Data Only!");
			// Once we know the storable types are safe we record their type and transfer the data
			enumType = typeid(enumT).hash_code();
			dataType = typeid(dataT).hash_code();
			// Unlikely, but the standard doesn't say it can't happen, would interfere with error checking
			if (enumType == 0 || dataType == 0)
				return GReturn::UNEXPECTED_RESULT;
			// Store bit data for typeless transfer
			rawData[0] = sizeof(enumT); // encode size of enum
			memory_copy(rawData + 1, &_eventEnumValue, sizeof(enumT)); // store enum
			rawData[sizeof(enumT) + 1] = sizeof(dataT); // encode size of data
			memory_copy(rawData + sizeof(enumT) + 2, &_eventData, sizeof(dataT)); // store data
			// transfer to internal storage should now be successful
			return GReturn::SUCCESS;
		};
		template<class enumT, typename dataT>
		GReturn Read(enumT& _outEventID, dataT& _outEventData) const
		{
			// If you get this complier error you are providing Read() with an incompatible type.
			// Always use Gxxx::Events and Gxxx::EVENT_DATA to examine an event.
			static_assert((sizeof(enumT) + sizeof(dataT)) <= G_RAW_DATA_PACKET_SIZE &&
				std::is_enum<enumT>::value && std::is_trivially_copyable<enumT>::value &&
				std::is_trivially_copyable<dataT>::value,
				"Types provided to GEvent::Read() operation are not a compatible types!"
				"Use appropriate GEventGenerator derived G::Events enum and G::EVENT_DATA structure.");
			// Type hashes will ensure safe access of underlying data in 99.9% of situations
			// Not 100% perfect but much safer than a void* like it used to be.
			if (enumType == 0 || dataType == 0) return GReturn::FAILURE; // No event data present
			// Requested type does not match internal enum format (use proper G::Events)
			if (enumType != typeid(enumT).hash_code()) return GReturn::INVALID_ARGUMENT;
			// Requested type does not match internal data structure format (use proper G::EVENT_DATA)
			if (dataType != typeid(dataT).hash_code()) return GReturn::INVALID_ARGUMENT;
			// Once types have been safely checked we verify the byte sizes of types and copy data
			if (sizeof(enumT) == rawData[0])
				memory_copy(&_outEventID, rawData + 1, sizeof(enumT));
			else
				return GReturn::MEMORY_CORRUPTION; // data size verification failed
			// check that data type is also size verified before transfer
			if (sizeof(dataT) == rawData[sizeof(enumT) + 1])
				memory_copy(&_outEventData, rawData + sizeof(enumT) + 2, sizeof(dataT));
			else
				return GReturn::MEMORY_CORRUPTION; // data size verification failed
			// if we made it this far everything checked out and transfered successfully.
			return GReturn::SUCCESS;
		}
		template<class enumOrDataT>
		GReturn Read(enumOrDataT& _outEventOrData) const
		{
			// If you get this complier error you are providing Read() with an incompatible type.
			// Always use Gxxx::Events and Gxxx::EVENT_DATA to examine an event.
			static_assert(sizeof(enumOrDataT) <= G_RAW_DATA_PACKET_SIZE &&
				std::is_trivially_copyable<enumOrDataT>::value,
				"Type provided to GEvent::Read() operation is not a compatible type!"
				"Use appropriate GEventGenerator derived G::Events enum or G::EVENT_DATA structure.");
			// Type hashes will ensure safe access of underlying data in 99.9% of situations
			// Not 100% perfect but much safer than a void* like it used to be.
			if (enumType == 0 && dataType == 0)
				return GReturn::FAILURE; // No event data present
			// enum type identified
			else if (enumType == typeid(enumOrDataT).hash_code())
				if (sizeof(enumOrDataT) == rawData[0])
					memory_copy(&_outEventOrData, rawData + 1, sizeof(enumOrDataT)); // transfer enum bits
				else // data size verification failed
					return GReturn::MEMORY_CORRUPTION;
			// event data identified
			else if (dataType == typeid(enumOrDataT).hash_code())
				if (rawData[0] < (G_EVENT_BLOCK_SIZE - (sizeof(std::size_t) << 1)) && // enoded enum type integrity check
					sizeof(enumOrDataT) == rawData[rawData[0] + 1]) // jump to type size offset
					memory_copy(&_outEventOrData, rawData + rawData[0] + 2, sizeof(enumOrDataT)); // transfer enum bits
				else // data size verification failed
					return GReturn::MEMORY_CORRUPTION;
			else // Requested type does not match internal enum/data structure format (use proper G::Events/G::EVENT_DATA)
				return GReturn::INVALID_ARGUMENT;
			// with transfer complete notify success
			return GReturn::SUCCESS;
		}
	};
};

// Creates an identically named typedef in the proxy to represent a public type in the interface
// These are typically used by Event Generator Proxies for end user typing conveinence
#define GATEWARE_TYPEDEF(interface_type) typedef forceRaw::interface_type interface_type;
// Returns if a proxy is empty or it is expired if this detection functionality is supported
// In Visual Studio you can add "/std:c++17 /Zc:__cplusplus" to your C++ command line for partial c++17 support
#if __cplusplus >= 201703L // This requires c++17 support
// Determines if an invalid proxy has expired or was never intialized in the first place.
#define GATEWARE_EXPIRED(weak_pointer) \
(!(weak_pointer).owner_before(std::weak_ptr<forceRaw>{}) && \
!std::weak_ptr<forceRaw>{}.owner_before((weak_pointer))) \
? GW::GReturn::EMPTY_PROXY : GW::GReturn::EXPIRED_PROXY
#else
// if we don't have support for c++17 we can't detect an expired proxy and fallback to empty.
#define GATEWARE_EXPIRED(weak_pointer) GW::GReturn::EMPTY_PROXY
#endif
// Writes a wrapper function to wrap the internal implementation call
// Uses a variadic template & perfect forwarding of arguments for ease of development & performance
#define GATEWARE_PROXY_FUNCTION(function_name, access_type, lock_type, cast_type) \
template<typename... Args> \
GW::GReturn \
function_name \
(Args&&... parameter) access_type { \
if(storage) return (cast_type(storage.get()))->function_name(std::forward<Args>(parameter)...);\
lock_type _proxy = access.lock(); \
return (_proxy) ? (cast_type(_proxy.get()))->function_name(std::forward<Args>(parameter)...) \
: GATEWARE_EXPIRED(access); \
}
#define GATEWARE_FUNCTION(function_name) GATEWARE_PROXY_FUNCTION(function_name, ,auto, )
#define GATEWARE_CONST_FUNCTION(function_name) GATEWARE_PROXY_FUNCTION(function_name,const,forceConst, )
// Template Proxy functions convert the base class pointer to its known implementation before
// Passing the list of arguments to the appropriate routine, conveinent but not particluarly efficient
#define GATEWARE_TEMPLATE_FUNCTION(function_name) \
GATEWARE_PROXY_FUNCTION(function_name, ,auto,dynamic_cast<forceStatic*>)
#define GATEWARE_CONST_TEMPLATE_FUNCTION(function_name) \
GATEWARE_PROXY_FUNCTION(function_name,const,forceConst,dynamic_cast<forceStatic*>)
// Static functions allow high speed calls with no refrence juggling for things like math libraries.
// Yet they still allow such Proxys to operate like any other Proxy transparently
#define GATEWARE_STATIC_FUNCTION(function_name) \
template<typename... Args> \
static GW::GReturn \
function_name \
(Args&&... parameter) { \
return forceStatic::function_name(std::forward<Args>(parameter)...); \
}
// This macro ensures the derived proxy fully supports dynamic casting and transfer of proxy ownership
// ALL Gateware Proxy classes MUST have this in the public section of the derived proxy class.
#define GATEWARE_PROXY_CLASS(class_name) \
class_name() = default; \
class_name(std::shared_ptr<forceRaw> shr) : thisClass(shr) {} \
template<class Proxy> class_name(const Proxy& cpy) : thisClass(cpy) { } \
template<class Proxy> class_name(Proxy&& mov) noexcept : thisClass(std::forward<Proxy>(mov)) { } \
template<class Proxy> class_name& operator=(const Proxy& cpy) { thisClass::operator=(cpy); return *this; } \
template<class Proxy> class_name& operator=(Proxy&& mov) \
noexcept { thisClass::operator=(std::forward<Proxy>(mov)); return *this; } \
forceStatic* operator--(int) const { std::abort(); return nullptr; }; // The "--->" is ONLY for Intellisense Viewing

// Deprecates an entire class and displays a message recommending an alternative class.
// To use, replace: class Foo
// With: class GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo
#if defined(_MSC_VER)
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class) \
__declspec(deprecated(#deprecated_class " is deprecated: use " #replacing_class " instead."))
#elif defined(__GNUC__)
// XCode and CodeLite will prepend a message indicating the class is deprecated.
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class) \
__attribute__ ((deprecated("use " #replacing_class " instead.")))
#else
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class)
#endif

// NOTE: The GATEWARE_DEPRECATED macro was originally designed for deprecating a class, but it could be used
// to deprecated other things. For example:
//
// Structs: 
//    struct GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo
// Typedefs: 
//    GATEWARE_DEPRECATED(Foo, FoosReplacement) GATEWARE_TYPEDEF(Foo)
//
// For deprecating functions, GATEWARE_DEPRECATED has to be placed inside the argument area of the function
// macro, before the function name. This is because GATEWARE_DEPRECATED has to be placed after the template<T>
// part of the function header. For example:
//
// Functions:
//    GATEWARE_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_CONST_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_PROXY_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_TEMPLATE_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//
// Currently, there is no way to use GATEWARE_DEPRECATED with the GATEWARE_STATIC_FUNCTION macro. This is
// because GATEWARE_DEPRECATED has to be placed after the 'static' keyword. One solution for this would be
// to create a new macro for this specific case.


// If you are looking for binary build support, it has been dropped from the late Beta version of Gateware.
// As much as I wanted to embrace Libs & DLLs... C++11 functional additions, ease of deployment considerations,
// and simplicity for student developers both internal & external have prompted this decision.
// Obviously binaries have many advantages, but their drawbacks simply don't fit the future of this project.
// I spent many weeks trying to have my cake & eat it too, and theoretically it remains possible to support.
// However, the additional complexity and support needed for them was deemed too costly. -L.Norri Gatekeeper
#endif // GCOREDEFINES_H


/*---------------------------------
|	End of GCoreDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GSystemDefines.h
----------------------------------*/
#ifndef GSYSTEMDEFINES_H
#define GSYSTEMDEFINES_H


// Maximum thread pool size allocated by thread pool. Only actual available hardware thread count is used.
#define G_MAX_THREAD_POOL_SIZE		64
// default amount of time in microseconds to nap threads that should release resources
#define G_THREAD_DEFAULT_SLEEP		5000
// amount of time in microseconds below which daemons are spinlocked for launch
#define G_DAEMON_LAUNCH_THRESHOLD	100
// amount of bytes gconcurrent uses to determine how many elements should be allocated per-thread in BranchParallel
#define G_CONCURRENT_AUTO_SECTION	131072

namespace GW
{
	namespace SYSTEM
	{

		struct UNIVERSAL_WINDOW_HANDLE
		{
			void* window;	
			void* display;	
		};

		enum class GWindowStyle
		{
			WINDOWEDBORDERED,		
			WINDOWEDBORDERLESS,		
			WINDOWEDLOCKED,			
			FULLSCREENBORDERED,		
			FULLSCREENBORDERLESS,	
			MINIMIZED				
		};

	}
}
#endif // GSYSTEMDEFINES_H

/*---------------------------------
|	End of GSystemDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of ThreadPool.h
----------------------------------*/
#ifndef CONCURRENT_THREADPOOL_H
#define CONCURRENT_THREADPOOL_H

#include <atomic>
#include <thread>
#include <mutex>
#include <array>
#include <list>
#include <functional>
#include <condition_variable>

namespace nbsdx {
namespace concurrent {

/**
 *  Simple ThreadPool that creates `MaxThreadCount` threads upon its creation or
 *  std::thread::hardware_concurrency() whichever is less 
 *  and pulls from a queue to get new jobs. The default is 32 threads.
 *
 *  This class requires a number of c++11 features be present in your compiler.
 */
template <unsigned MaxThreadCount = 32>
class ThreadPool {
    
    // (Gateware custom) added this array for queries about running threadIds
    std::array<std::thread::id, MaxThreadCount> ids;

    std::array<std::thread, MaxThreadCount> threads;
    std::list<std::function<void(void)>> queue;

    const unsigned          ThreadCount;
    std::atomic_int         jobs_left;
    std::atomic_bool        bailout;
    std::atomic_bool        finished;
    std::condition_variable job_available_var;
    std::condition_variable wait_var;
    std::mutex              wait_mutex;
    std::mutex              queue_mutex;

    /**
     *  Take the next job in the queue and run it.
     *  Notify the main thread that a job has completed.
     */
    void Task() {
        while( !bailout ) {
            next_job()();
            --jobs_left;
            wait_var.notify_one();
        }
    }

    /**
     *  Get the next job; pop the first item in the queue, 
     *  otherwise wait for a signal from the main thread.
     */
    std::function<void(void)> next_job() {
        std::function<void(void)> res;
        std::unique_lock<std::mutex> job_lock( queue_mutex );

        // Wait for a job if we don't have any.
        job_available_var.wait( job_lock, [this]() ->bool { return queue.size() || bailout; } );
        
        // Get job from the queue
        if( !bailout ) {
            res = queue.front();
            queue.pop_front();
        }
        else { // If we're bailing out, 'inject' a job into the queue to keep jobs_left accurate.
            res = []{};
            ++jobs_left;
        }
        return res;
    }

public:
    ThreadPool()
        : ThreadCount( // select all hardware threads or MaxThreads whichever is less 
            (MaxThreadCount < std::thread::hardware_concurrency()) 
            ? MaxThreadCount : std::thread::hardware_concurrency())
        , jobs_left( 0 )
        , bailout( false )
        , finished( false ) 
    {
        for (unsigned i = 0; i < ThreadCount; ++i) {
            threads[i] = std::thread([this] { this->Task(); });
            // (Gateware custom) cache ids of running threads for fast queries
            ids[i] = threads[i].get_id();
        }
    }

    /**
     *  JoinAll on deconstruction
     */
    ~ThreadPool() {
        JoinAll();
    }

    /**
     *  Get the number of threads in this pool
     */
    inline unsigned Size() const {
        return ThreadCount;
    }

    /**
     *  determine if a thread is one of the threads in the pool
     *  used to prevent possible deadlocks
     */
    inline bool Search(std::thread::id threadID) const {
        bool found = false;
        for (std::size_t i = 0; i < ThreadCount; ++i)
            if (ids[i] == threadID) {
                found = true;
                break;
            }
        return found;
    }

    /**
     *  Get the number of jobs left in the queue.
     */
    inline unsigned JobsRemaining() {
        std::lock_guard<std::mutex> guard( queue_mutex );
        return queue.size();
    }

    /**
     *  Add a new job to the pool. If there are no jobs in the queue,
     *  a thread is woken up to take the job. If all threads are busy,
     *  the job is added to the end of the queue.
     */
    void AddJob( std::function<void(void)> job ) {
        std::lock_guard<std::mutex> guard( queue_mutex );
        queue.emplace_back( job );
        ++jobs_left;
        job_available_var.notify_one();
    }

    /**
     *  Join with all threads. Block until all threads have completed.
     *  Params: WaitForAll: If true, will wait for the queue to empty 
     *          before joining with threads. If false, will complete
     *          current jobs, then inform the threads to exit.
     *  The queue will be empty after this call, and the threads will
     *  be done. After invoking `ThreadPool::JoinAll`, the pool can no
     *  longer be used. If you need the pool to exist past completion
     *  of jobs, look to use `ThreadPool::WaitAll`.
     */
    void JoinAll( bool WaitForAll = true ) {
        if( !finished ) {
            if( WaitForAll ) {
                WaitAll();
            }

            // note that we're done, and wake up any thread that's
            // waiting for a new job
            bailout = true;
            job_available_var.notify_all();

            for( auto &x : threads )
                if( x.joinable() )
                    x.join();
            finished = true;
        }
    }

    /**
     *  Wait for the pool to empty before continuing. 
     *  This does not call `std::thread::join`, it only waits until
     *  all jobs have finshed executing.
     */
    void WaitAll() {
        if( jobs_left > 0 ) {
            std::unique_lock<std::mutex> lk( wait_mutex );
            wait_var.wait( lk, [this]{ return this->jobs_left == 0; } );
            lk.unlock();
        }
    }
};

} // namespace concurrent
} // namespace nbsdx

#endif // #endif CONCURRENT_THREADPOOL_H

/*---------------------------------
|	End of ThreadPool.h
----------------------------------*/


/*---------------------------------
|	Begin of macutils.h
----------------------------------*/
#ifndef GATEWARE_MACUTILS_H
#define GATEWARE_MACUTILS_H

#if defined(__APPLE__)
@import Foundation;
@import Cocoa;
#import <objc/objc-runtime.h>

// G_OBJC MACROS
//
// Author: Ozzie Mercado
// Purpose: These macros are designed to simplify the process of writing Objective-C classes using the Objective-C
//          Runtime Library. All Objective-C classes must be created at runtime. The implementation of Objective-C
//          classes cannot be implicitly inlined. By using the Objective-C Runtime Library, we can get around that
//          limitation. Using these macros will make writing and using the Objective-C Runtime Library classes easier.
// Copyright: 7thGate Software LLC.
// License : MIT
//
// For more information about the Objecti-C Runtime Library:
// https://developer.apple.com/documentation/objectivec/objective-c_runtime
//
// --- DIRECTIONS ---
// Below directions for writing a G_OBJC class interface, implementation, how to use call methods, and how to
// retrieve data members. Further clarification for what each G_OBJC macro does can be found below the instructions
// at each macro definition.
//
// Writing a G_OBJC Class Interface:
//
//    // This should be somewhere above the implementation of the C++ Gateware library.
//    namespace internal_gw // Keep all G_OBJC class interfaces inside the internal_gw namespace.
//    {
//        // OPTIONAL: All data members of your class should go inside the data members struct for simplicity sake.
//        //           This makes it much easier to access them later. If you don't need to include data members in
//        //           your class, then you can skip creating the data members struct.
//        G_OBJC_DATA_MEMBERS_STRUCT(YourClassNameHere)
//        {
//            // These data members are just for example.
//            NSObject* someObject;
//            bool active;
//            int values[5];
//        };
//
//        G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(YourClassNameHere); // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//        // Forward declare all member functions of your class. You could write implementation here, but this is cleaner.
//        // These functions are just for example.
//        G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(YourClassNameHere, void, clearValues, id classInstance);
//        G_OBJC_HEADER_INSTANCE_METHOD(YourClassNameHere, void, toggleActive);
//        G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(YourClassNameHere, unsigned int, windowWillResize, NSSize* size, int index);
//
//        // Create your class.
//        // Note: If 'YourObjectiveCParentClass' is NSObject, then you may not need to write your class in Objective-C.
//        //       Regardless, you can still create a G_OBJC class that subclasses NSObject.
//        G_OBJC_CLASS_BEGIN(YourClassNameHere, YourObjectiveCParentClass)
//        {
//            // Add the data members getter function to your class definition.
//            G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(YourClassNameHere); // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//            // Add member functions to your class definition. These functions are just for example.
//            // Note: The 3rd argument is the type encoding for the function. Check the macro definition for more
//            //       information. The 4th argument in G_OBJC_CLASS_METHOD_WITH_ARGUMENTS() is a ':' for each
//            //       argument in the member function.
//            G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(YourClassNameHere, clearValues, "v@:@", :);
//            G_OBJC_CLASS_METHOD(YourClassNameHere, toggleActive, "v@:");
//            G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(YourClassNameHere, windowWillResize, "I@:@i", ::);
//        }
//        G_OBJC_CLASS_END(YourClassNameHere)
//    }
//
// Writing a G_OBJC Class Implementation:
//
//    // This should be somewhere below the implementation of the C++ Gateware library.
//    namespace internal_gw // Keep all G_OBJC class implementations inside the internal_gw namespace.
//    {
//        // Implementation for properties of your class.
//        G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(YourClassNameHere) // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//        // Implementation for all member functions of your class. These functions are just for example.
//        G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(YourClassNameHere, void, clearValues, id classInstance)
//        {
//            // Get the data members for 'classInstance'. We assume 'classInstance' is an instance of YourClassNameHere.
//            // Note: Member functions do not have direct access to member variables. G_OBJC_GET_DATA_MEMBERS() makes it easy
//            //       to get a reference to the data members of your class, use them, and make changes to them.
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, classInstance);
//
//            for (int i = 0; i < 5; ++i)
//                dataMembers.values[i] = 0;
//        }
//
//        G_OBJC_HEADER_INSTANCE_METHOD(YourClassNameHere, void, toggleActive)
//        {
//            // Note: 'self' is available in all non-static member functions.
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, self);
//
//            dataMembers.active = !dataMembers.active;
//        }
//
//        G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(YourClassNameHere, unsigned int, windowWillResize, NSSize* size, int index)
//        {
//            // This is a call to the above static member function 'clearValues'.
//            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(YourClassNameHere, self, clearValues, self);
//
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, self);
//            dataMembers.someObject = nullptr;
//            dataMembers.active = true;
//
//            return (unsigned int)index;
//        }
//    }
//
// Using a G_OBJC Class in a C++ Gateware library implementation:
//
//    // Allocating memory for a member of a G_OBJC class.
//    id classInstance = [internal_gw::G_OBJC_GET_CLASS(YourClassNameHere) alloc];
//
//    // Initializing a member of a G_OBJC class. Note: This example is after allocating 'classInstance'.
//    classInstance = [classInstance init];
//
//    // Both allocating and initializing a member of a G_OBJC class.
//    id classInstance = [[internal_gw::G_OBJC_GET_CLASS(YourClassNameHere) alloc] init];
//
//    // Cleaning up a member of a G_OBJC class.
//    [classInstance autorelease];
//    or
//    [classInstance release];
//
//    // Getting the data members of a G_OBJC class.
//    G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, classInstance);
//
//    // Getting a specific data member of a G_OBJC class. Note: This example is after getting the data members of the G_OBJC class.
//    dataMembers.specificDataMemberName
//
//    // Setting a specific data member of a G_OBJC class. Note: This example is after getting the data members of the G_OBJC class.
//    dataMembers.specificDataMemberName = 3.14f;
//
//    // Calling a member function of a G_OBJC class.
//    internal_gw::G_OBJC_CALL_METHOD(YourClassNameHere, classInstance, YourMemberFunctionNameHere);
//
//    // Calling a member function of a G_OBJC class with arguments.
//    internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(YourClassNameHere, classInstance, YourMemberFunctionNameHere, 3.14f, true);
//
// --- DIRECTIONS END ---

#define G_OBJC_GET_CLASS(class_name) Class##class_name()

// G_OBJC Class Creation:

#define G_OBJC_CLASS_DECLARE(class_name) static Class class_name

#define G_OBJC_CLASS_ALLOCATE(class_name, class_parent) class_name = objc_allocateClassPair([class_parent class], #class_name, 0)

#define G_OBJC_CLASS_REGISTER(class_name) objc_registerClassPair(class_name)

#define G_OBJC_CLASS_DEFINITION_HEADER(class_name) static Class& G_OBJC_GET_CLASS(class_name)

#define G_OBJC_CLASS_BEGIN(class_name, class_parent) G_OBJC_CLASS_DEFINITION_HEADER(class_name)\
{\
    G_OBJC_CLASS_DECLARE(class_name);\
    if (class_name == nil)\
    {\
        G_OBJC_CLASS_ALLOCATE(class_name, class_parent);\
        if (true) // Added to allow for a {code block}.

#define G_OBJC_CLASS_END(class_name) G_OBJC_CLASS_REGISTER(class_name);\
    }\
    return class_name; \
}

#define G_OBJC_CLASS_METHOD(class_name, method_name, method_types_string) class_addMethod(class_name, @selector(method_name), (IMP)class_name##Method##method_name, method_types_string)

#define G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(class_name, method_name, method_types_string, argument_colons) class_addMethod(class_name, @selector(method_name argument_colons), (IMP)class_name##Method##method_name, method_types_string)

#define G_OBJC_CLASS_ADD_PROPERTY(class_name, type_name, property_name) class_addIvar(class_name, "_"#property_name, sizeof(type_name), log2(sizeof(type_name)), @encode(type_name));\
{\
    objc_property_attribute_t instance_variable_type = { "T", "@\""#type_name"\"" };\
    objc_property_attribute_t instance_property_name = { "V", "_"#property_name };\
    objc_property_attribute_t instance_variable_attributes[2] = { instance_variable_type, instance_property_name };\
    class_addProperty(class_name, #property_name, instance_variable_attributes, 2);\
}

#define G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, property_name) G_OBJC_CLASS_METHOD(class_name, property_name, "@@:")

#define G_OBJC_CLASS_SET_PROPERTY_METHOD(class_name, property_name) G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(class_name, Set##property_name, "v@:@", :)

#define G_OBJC_CLASS_PROPERTY(class_name, type_name, property_name) G_OBJC_CLASS_ADD_PROPERTY(class_name, type_name, property_name);\
G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, property_name);\
G_OBJC_CLASS_SET_PROPERTY_METHOD(class_name, property_name)

// G_OBJC Class Interface:

#define G_OBJC_HEADER_STATIC_METHOD(class_name, method_return_type, method_name) static method_return_type class_name##Method##method_name(id self, SEL _cmd)

#define G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(class_name, method_return_type, method_name, ...) static method_return_type class_name##Method##method_name(id self, SEL _cmd, __VA_ARGS__)

#define G_OBJC_HEADER_INSTANCE_METHOD(class_name, method_return_type, method_name) inline method_return_type class_name##Method##method_name(id self, SEL _cmd)

#define G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, method_return_type, method_name, ...) inline method_return_type class_name##Method##method_name(id self, SEL _cmd, __VA_ARGS__)

#define G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD(class_name, type_name&, property_name)

#define G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD(class_name, type_name, property_name)

#define G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, void, Set##property_name, type_name newVal)

#define G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, void, Set##property_name, type_name newVal)

#define G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    CFTypeRef selfPtr = CFBridgingRetain(self);\
    type_name* varPtr = (type_name*)((uint8_t*)selfPtr + ivar_getOffset(ivar));\
    return *varPtr;\
}

#define G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    return (type_name)object_getIvar(self, ivar);\
}

#define G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    CFTypeRef selfPtr = CFBridgingRetain(self);\
    type_name* varPtr = (type_name*)((uint8_t*)selfPtr + ivar_getOffset(ivar));\
    *varPtr = newVal;\
}

#define G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    type_name oldVal = (type_name)object_getIvar(self, ivar);\
    if (oldVal != newVal)\
        object_setIvar(self, ivar, (id)newVal);\
}

#define G_OBJC_HEADER_PROPERTY_METHODS(class_name, type_name, property_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name);\
G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name)

#define G_OBJC_HEADER_PROPERTY_METHODS_FOR_POINTER(class_name, type_name, property_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name);\
G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)

#define G_OBJC_IMPLEMENTATION_PROPERTY_METHODS(class_name, type_name, property_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, type_name, property_name);\
G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD(class_name, type_name, property_name)

#define G_OBJC_IMPLEMENTATION_PROPERTY_METHODS_FOR_POINTER(class_name, type_name, property_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name);\
G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)

// G_OBJC Class Usage:

#define G_OBJC_CALL_METHOD(class_name, class_instance, method_name) class_name##Method##method_name(class_instance, @selector(method_name))

#define G_OBJC_CALL_METHOD_WITH_ARGUMENTS(class_name, class_instance, method_name, ...) class_name##Method##method_name(class_instance, @selector(method_name), __VA_ARGS__)

#define G_OBJC_GET_PROPERTY(class_name, class_instance, property_name) class_name##Method##property_name(class_instance, @selector(property_name))

#define G_OBJC_SET_PROPERTY(class_name, class_instance, property_name, new_value) class_name##MethodSet##property_name(class_instance, @selector(property_name), new_value)

// G_OBJC Class Data Members:

#define G_OBJC_DATA_MEMBERS_TYPE(class_name) class_name##DataMembers

#define G_OBJC_DATA_MEMBERS_STRUCT(class_name) struct class_name##DataMembers

#define G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(class_name) G_OBJC_CLASS_ADD_PROPERTY(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name);\
G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, dataMembersOf##class_name)

#define G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(class_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name)

#define G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(class_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name)

#define G_OBJC_GET_DATA_MEMBERS(class_name, class_instance) G_OBJC_GET_PROPERTY(class_name, class_instance, dataMembersOf##class_name)

// G_OBJC MACROS END

// Thanks to Chris for this little snippet and reminding everyone the proper way to interact with the apple UI layer
// https://chritto.wordpress.com/2012/12/20/updating-the-ui-from-another-thread/
inline void RUN_ON_UI_THREAD(dispatch_block_t block)
{
    if ([NSThread isMainThread])
        block();
    else
        dispatch_sync(dispatch_get_main_queue(), block);
}

inline void FlushMacEventLoop()
{
    while (TRUE)
    {
        if ([NSThread isMainThread])
        {
            NSEvent* event = [NSApp nextEventMatchingMask : NSEventMaskAny
                untilDate : [NSDate distantPast]
                inMode : NSDefaultRunLoopMode
                dequeue : YES];

            if (event == nil)
                break;

            [NSApp sendEvent : event] ;
            [NSApp updateWindows] ;
        }
    }
}
#endif // #endif __APPLE__
#endif // #endif GATEWARE_MACUTILS_H


/*---------------------------------
|	End of macutils.h
----------------------------------*/


/*---------------------------------
|	Begin of GUtility.h
----------------------------------*/
#ifndef GUTILITY_H
#define GUTILITY_H

#include <locale>
#include <codecvt>

namespace INTERNAL
{
	//UINT_MAX is not defined on Mac or Linux.
	//Internal #define for this.
#define G_UINT_MAX 0xFFFFFFFF

#if defined(_WIN32)
	//Macro to preform string conversions.
#define G_TO_UTF16(value) stringConverter.from_bytes(value)
#define G_TO_UTF8(value) stringConverter.to_bytes(value)
#elif defined(__APPLE__) || defined(__linux__)
	//These string conversions are not necessary on Linux/Apple.
	//They are designed to be replaced with just the value given to them.
#define G_TO_UTF16(value) value
#define G_TO_UTF8(value) value
	//Defined to replace instances of strcpy_s with strlcpy on Linux/Mac.
	//This is because strcpy_s is not supported on GCC.
#define strcpy_s(...) strlcpy(__VA_ARGS__)
#else

//If you get this error then we are currently on a platform not supported by Gateware.
#error Gateware Libraries are not built for your current system
#endif

	//All variables and functions below are macroed above. This is so the code wrote out
	//will be the exact same code no matter the system we are writing it for.


	//This is a utf8 to utf16 and utf16 to utf8 string converter.
	//Used like so...
	//to utf16: stringConverter.from_bytes(const char*)  //Is overloaded to accept string as well.
	//to utf8: stringConverter.to_bytes(const wchar_t*) //Is overloaded to accept wstring as well.
	static ::std::wstring_convert < ::std::codecvt_utf8_utf16<wchar_t>> stringConverter;

	//GCC does not support strcpy_s. This is a safe strcpy function for use on Linux.
#if defined(__linux__) || defined(__APPLE__)
#pragma GCC diagnostic ignored "-Wunused-function"
	static unsigned int strlcpy(char* destination, unsigned int strLen, const char* const source)
	{
		return snprintf(destination, strLen, "%s", source);
	}
#pragma GCC diagnostic warning "-Wunused-function"
#endif

}//end INTERNAL namespace

#endif // #endif GUTILITY_H


/*---------------------------------
|	End of GUtility.h
----------------------------------*/


/*---------------------------------
|	Begin of GInterface.h
----------------------------------*/
#ifndef GINTERFACE_H
#define GINTERFACE_H


// Contains all defined elements shared among base interfaces.


namespace GW
{
	// The "I" namespace can be safely ignored by end users. I = ('I'nternal 'I'nterfaces & 'I'mplementations)
	namespace I // Doxygen ignores this namespace.
	{
		// Base interface all Gateware interfaces must support at a minimum.
		// The only purpose of this interface is to identify Gateware Objects, enable run-time polymorphisim.
		class GInterfaceInterface
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			virtual ~GInterfaceInterface() = 0; // all interfaces must support vtables & RTTI 
		};
		inline GInterfaceInterface::~GInterfaceInterface() = default;
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GInterface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GINTERFACE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GINTERFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GInterface
namespace GW {
	namespace I {
	class GInterfaceImplementation : public virtual GInterfaceInterface
	{
	public:
		GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
	};
	} // end CORE
} // end GW


#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Universal implementation of GInterface

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

	// Comments in these files are up to the developer but should not be part of doxygen
	class GInterfaceImplementation : public virtual GInterfaceInterface
	{
		// If we had any internal variables or functions we would define them here.
	public:
		// GInterface doesn't do anything... but you can make one as that is consitent with the API
		// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
		// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
		GReturn Create()
		{
			return GReturn::SUCCESS;
		}

		// A pure virtual destructor requires an implementation in C++  
//		~GInterfaceImplementation() override {};
	};
	// End Gateware namespaces
	} // end CORE
} // end GW


#endif


namespace GW
{
	namespace CORE
	{
		class GInterface final // Note to developers: this is a Proxy, what end users actually interact with. 
		: public I::GProxy<I::GInterfaceInterface, I::GInterfaceImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GInterface)

		// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GINTERFACE_H

/*---------------------------------
|	End of GInterface.h
----------------------------------*/


/*---------------------------------
|	Begin of GThreadShared.h
----------------------------------*/
#ifndef GTHREADSHARED_H
#define GTHREADSHARED_H




namespace GW
{
	namespace I
	{
		// An interface which supports safe resource access from multiple threads.
		// Gateware Developers: Use private inheritance(containment) if you do not wish to allow external locks. (recommended)
		class GThreadSharedInterface : virtual public GInterfaceInterface
		{
		public:
			virtual GReturn LockAsyncRead() const = 0;
			virtual GReturn UnlockAsyncRead() const = 0;
			virtual GReturn LockSyncWrite() = 0;
			virtual GReturn UnlockSyncWrite() = 0;
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GThreadShared.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GTHREADSHARED) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GTHREADSHARED) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface,
											protected GInterfaceImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn LockAsyncRead() const override {
				return GReturn::FAILURE;
			}
			GReturn UnlockAsyncRead() const override {
				return GReturn::FAILURE;
			}
			GReturn LockSyncWrite() override {
				return GReturn::FAILURE;
			}
			GReturn UnlockSyncWrite() override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#ifdef NDEBUG
		#ifdef _WIN32
			// Windows specific version uses SRWLocks for highly optimized read/write access to resources
// This variant has NO safety mechanisms at all, only use it if you need every last shred of performance and
// are certain you have no threading logic errors of any kind.
#define WIN32_LEAN_AND_MEAN
#include <windows.h> // used for fast locks and synchronus reads
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											private GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// Since we fully support C++11 you may inline intialize variables as needed.
			SRWLOCK sync = { nullptr }; // used to synchronize reads & writes, initializig this to something other than null/nothing causes issues
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				InitializeSRWLock(&sync); // The return of this may be null so we cannot use that for error checking
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				AcquireSRWLockShared(const_cast<PSRWLOCK>(&sync));
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				ReleaseSRWLockShared(const_cast<PSRWLOCK>(&sync));
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				AcquireSRWLockExclusive(&sync);
				return GReturn::SUCCESS;
			}

			// it is the end-users resposibility to make sure they lock before they unlock
			// this disables the warning C26110 that is associated with this, so the end-user doesn't see it in Gateware.h
#pragma warning( push )
#pragma warning( disable : 26110 )
			GReturn UnlockSyncWrite() override
			{
				ReleaseSRWLockExclusive(&sync);
				return GReturn::SUCCESS;
			}
			// this returns the pragma to its previous state, effectively un-disabling C26110 for the rest of Gateware.h
#pragma warning( pop )
		};
		// End Gateware namespaces
	} // end CORE
} // end GW
 // fast unlimited asynchronus locking, ZERO safety
		#else	
			// This files implements read & write locks through a generic mutex.
// Ideally you should replace this implementation with an optmized platform specific one.
// No error checking is present in this variant to maximize performance in release.
// **NEW** Updated with c++14 shared mutex.(if available)
#if __cplusplus >= 201402L // shared_mutex requires c++14 support
	#include <shared_mutex>
	#define G_LOCK_OBJ std::shared_mutex
	#define G_LOCK_ASYNC lock_shared
	#define G_UNLOCK_ASYNC unlock_shared
#else
	#include <mutex>
	#define G_LOCK_OBJ std::mutex
	#define G_LOCK_ASYNC lock
	#define G_UNLOCK_ASYNC unlock
#endif
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											protected GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// If C++14 support is detected we enable asynchronus reads for improved performance
			G_LOCK_OBJ async; // hopefully supports aynchronus reads and synchronus writes
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<G_LOCK_OBJ*>(&async)->G_LOCK_ASYNC();
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<G_LOCK_OBJ*>(&async)->G_UNLOCK_ASYNC();
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				async.lock();
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockSyncWrite() override
			{
				async.unlock();
				return GReturn::SUCCESS;
			}
			// release any outstanding locks on destruction
			~GThreadSharedImplementation()
			{
				UnlockAsyncRead();
				UnlockSyncWrite();
			}
		};
		// End Gateware namespaces
	} // end CORE
} // end GW
#undef G_LOCK_OBJ
#undef G_LOCK_ASYNC
#undef G_UNLOCK_ASYNC
 // no error detection, much faster if c++14 compiler (coming soon)
		#endif
	#else
		// This files implements read & write locks through a generic mutex.
// Ideally you should replace this implementation with an optmized platform specific one.
// This version currently does not support asynchronus reads, may be updated with c++14 timed mutex.
#include <atomic>
#include <mutex>
#include <thread> // used for tracking thread ids to avoid deadlock
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											protected GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// Since we fully support C++11 you may inline intialize variables as needed.
			std::mutex sync; // used to synchronize reads & writes
			std::atomic<std::thread::id> locker; // ID of the only thread that has a lock.(used to detect deadlocks)
			std::atomic_bool mode; // tracking of active mode. false = read, true = write
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// even though the function says async this implementation is synced for now
				if (locker == std::this_thread::get_id()) 
					return GReturn::DEADLOCK;
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<std::mutex*>(&sync)->lock();
				*const_cast<std::atomic<std::thread::id>*>(&locker) = std::this_thread::get_id();
				*const_cast<std::atomic_bool*>(&mode) = false;
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// even though the function says async this implementation is synced for now
				if (locker != std::this_thread::get_id() || mode == true) 
					return GReturn::FAILURE;
                // enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				*const_cast<std::atomic<std::thread::id>*>(&locker) = std::thread::id();
				const_cast<std::mutex*>(&sync)->unlock();
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				// even though the function says async this implementation is synced for now
				if (locker == std::this_thread::get_id())
					return GReturn::DEADLOCK;
				sync.lock();
				locker = std::this_thread::get_id();
				mode = true;
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockSyncWrite() override
			{
				// even though the function says async this implementation is synced for now
				if (locker != std::this_thread::get_id() || mode == false)
					return GReturn::FAILURE;
				locker = std::thread::id();
				sync.unlock();
				return GReturn::SUCCESS;
			}
			// release any outstanding locks on destruction
			~GThreadSharedImplementation()
			{
				UnlockAsyncRead();
				UnlockSyncWrite();
			}
		};
		// End Gateware namespaces
	} // end CORE
} // end GW

 // not asyncronous at all but recursive deadlock and error checking
	#endif
#endif



namespace GW
{
	namespace CORE
	{
		class GThreadShared final
			: public I::GProxy<I::GThreadSharedInterface, I::GThreadSharedImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GThreadShared)
			GATEWARE_CONST_FUNCTION(LockAsyncRead)
			GATEWARE_CONST_FUNCTION(UnlockAsyncRead)
			GATEWARE_FUNCTION(LockSyncWrite)
			GATEWARE_FUNCTION(UnlockSyncWrite)

// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GTHREADSHARED_H

/*---------------------------------
|	End of GThreadShared.h
----------------------------------*/


/*---------------------------------
|	Begin of GLogic.h
----------------------------------*/
#ifndef GLOGIC_H
#define GLOGIC_H



#include <functional>

namespace GW
{
	namespace I
	{
		class GLogicInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Assign(std::function<void()> _newLogic) = 0;
			virtual GReturn Invoke() const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GLogic.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GLOGIC) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GLOGIC) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GLogicImplementation : public virtual GLogicInterface,
									 private GThreadSharedImplementation
		{
		public:
			GReturn Create(std::function<void()> _logic) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a std::function<void()> and allows it to be updated/invoked safely
		class GLogicImplementation :	public virtual GLogicInterface,
										protected GThreadSharedImplementation // resource locking
		{
			// internal data members
			std::function<void()> logic = nullptr;
		public:
			// Must match Proxy argument list
			GReturn Create(std::function<void()> _logic) {
				logic = _logic; // should move && in many cases
				return GReturn::SUCCESS;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					logic = _newLogic; // routine updated
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (logic) logic(); // routine called
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (logic) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GLogic final
			: public I::GProxy<I::GLogicInterface, I::GLogicImplementation, std::function<void()>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// procy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GLogic)
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRECEIVER_H


/*---------------------------------
|	End of GLogic.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventResponder.h
----------------------------------*/
#ifndef GEVENTRESPONDER_H
#define GEVENTRESPONDER_H




namespace GW
{
	namespace I
	{
		class GEventResponderInterface : public virtual GLogicInterface
		{
		public:
			// Let the compiler know that we intend to use the base class methods
			// and also override them with an additional parameters.
			using GLogicInterface::Assign; // enables "eventless" response if desired
			using GLogicInterface::Invoke; // A GResponder Invoke with no GEvent will have a dummy event provided.
			// new methods (overrides)
			virtual GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) = 0;
			virtual GReturn Invoke(const GEvent& _incomingEvent) const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventResponder.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTRESPONDER) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTRESPONDER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventResponderImplementation :	public virtual GEventResponderInterface,
												private GThreadSharedImplementation
		{
		public:
			GReturn Create(std::function<void(const GEvent&)> _handler) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a std::function<void(const GEvent&)> and allows it to be updated/invoked safely
		class GEventResponderImplementation :	public virtual GEventResponderInterface,
												protected GThreadSharedImplementation // resource locking
		{
			// internal data members
			std::function<void(const GEvent&)> handler = nullptr;
		public:
			// Must match Proxy argument list
			GReturn Create(std::function<void(const GEvent&)> _handler) {
				handler = _handler; // nullptr is ok, optional.	
				return GReturn::SUCCESS;
			}
			// custom variants here
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					handler = _newEventHandler; // routine updated
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (handler) handler(_incomingEvent); // routine called with actual event
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (handler) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
			// base interface variant internals overwritten below
			GReturn Assign(std::function<void()> _newLogic) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					handler = std::bind(_newLogic); // routine updated to ignore GEvents
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (handler) handler(GEvent()); // routine called with non-event
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (handler) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GEventResponder final
			: public I::GProxy<I::GEventResponderInterface, I::GEventResponderImplementation, std::function<void(const GEvent&)>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventResponder)
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRESPONDER_H

/*---------------------------------
|	End of GEventResponder.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventCache.h
----------------------------------*/
#ifndef GEVENTCACHE_H
#define GEVENTCACHE_H



namespace GW
{
	namespace I
	{
		class GEventCacheInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Append(const GEvent& _inEvent) = 0;
			virtual GReturn Waiting(unsigned int& _outCount) const = 0;
			virtual GReturn Pop(GEvent& _outEvent) = 0;
			virtual GReturn Peek(GEvent& _outEvent) const = 0;
			virtual GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const = 0;
			virtual GReturn Max(unsigned int& _outSize) const = 0;
			virtual GReturn Missed(unsigned int& _outCount) const = 0;
			virtual GReturn Clear() = 0;
			template<class eventType>
			GReturn Find(eventType _check, bool _remove);
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData);
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventCache.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTCACHE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTCACHE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventCacheImplementation :	public virtual GEventCacheInterface,
											private GThreadSharedImplementation
		{
		public:
			// New operations
			GReturn Create(unsigned int _cacheSize) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Max(unsigned int& _outSize) const override {
				return GReturn::FAILURE;
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GEventCacheImplementation :	public virtual GEventCacheInterface,
											private GThreadSharedImplementation // resource locking				
		{
			// internal data members
			int enque = 0; // where items are enqued
			int deque = 0; // where items are dequed
			unsigned int maxEvents = 0; // size of the queue
			unsigned int missedEvents = 0; // increases if the queue is at capacity during append
			unsigned int eventsWaiting = 0; // number of events currently queued
			GEvent* circularQueue = nullptr; // where events are stored (ring buffer)
			
			// functions for circular queue (since std does not seem to provide one)
			// NOTE: we may want to shift this into "key" as an ADT if it sees more widespread application
			
			// returns false if queue is full
			bool Enque(const GEvent& _push) 
			{
				if (eventsWaiting >= maxEvents)
					return false;
				circularQueue[enque] = _push;
				enque = (enque + 1) % maxEvents;
				++eventsWaiting;
				return true;
			}
			// returns false if queue is empty
			bool Deque(GEvent* _pop) // optional
			{
				if (eventsWaiting == 0)
					return false;
				if(_pop != nullptr)
					*_pop = circularQueue[deque];
				deque = (deque + 1) % maxEvents;
				--eventsWaiting;
				return true;
			}
			// required to fully implement the "Find" routines
			// while collapsing the queue is not optimal we go for the closest point to minimize copies
			bool Erase(unsigned int _offset) // offset from dequqe point
			{
				if (eventsWaiting == 0 || _offset >= eventsWaiting) // should we bother?
					return false;
				// which is closer enque or deque?
				int dir = (_offset < (eventsWaiting >> 1)) ? maxEvents - 1 : 1;
				int stop = (dir == 1) ? enque : (deque + dir) % maxEvents; // stop here
				_offset = (deque + _offset) % maxEvents; // this starting spot should be valid now
				for (int i = (_offset + dir) % maxEvents; i != stop; i = (i + dir) % maxEvents)
				{
					circularQueue[_offset] = circularQueue[i]; // copy & move
					_offset = i; // next
				}
				// update enque or deque based on which way we closed the gap
				(dir == 1) ? enque = _offset : deque = ((deque + 1) % maxEvents);
				--eventsWaiting; // reduce overall size of queue
				return true; // hopefully the logic above is good we will test it
			}
			// queue theory:
			// 0 1 2 3 4 5 6
			// - - D + + + E
			// + E - - D + +
			// + E - - - - D
			// D E - - - - -
			// - - - D E - -
			// + + E D + + +
			// - D + + E - -
			// + + + + + E D

		public:
			// with dynamic memory present we must free any allocated resources
			~GEventCacheImplementation()
			{
				delete[] circularQueue; // free allocated queue
			}
			// You must select a maximum size of the queue as for efficiency it is implemented as a circular array
			GReturn Create(unsigned int _cacheSize) 
			{
				if (_cacheSize < 1) // needs to be at least 1
					return GReturn::INVALID_ARGUMENT;
				// generate circular queue
				if ((circularQueue = new GEvent[_cacheSize]) == nullptr)
					return GReturn::FAILURE; // new[] failed
				maxEvents = _cacheSize; // store mamximum allowable event data
				return GReturn::SUCCESS;
			}
			GReturn Max(unsigned int& _outSize) const override 
			{
				LockAsyncRead();
				_outSize = maxEvents; // get maximum size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override 
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventsWaiting >= maxEvents) // are we are full?
					{
						Deque(nullptr); // remove an existing event so we have room
						++missedEvents; // notify we missed an event
					}
					// append new event (should always happen)
					if (Enque(_inEvent) && +UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override 
			{
				LockAsyncRead();
				_outCount = eventsWaiting; // get current size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (Deque(&_outEvent))
						result = GReturn::SUCCESS;
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						_outEvent = circularQueue[deque];
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override
			{
				// Use deque + _eventIndex % maxEvents to find the right spot
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						if (_eventIndex < eventsWaiting) // must be a valid index
						{
							_outEvent = circularQueue[(deque + _eventIndex) % maxEvents];
							result = GReturn::SUCCESS;
						}
						else
							result = GReturn::INVALID_ARGUMENT; // out of range
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents; // how many events were ignored
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventsWaiting)
					{
						enque = deque = eventsWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS 
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						}while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event, _outData)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						} while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};
	} // end CORE
} // end GW


#endif


namespace GW
{
	namespace CORE
	{
		class GEventCache final
			: public I::GProxy<I::GEventCacheInterface, I::GEventCacheImplementation, unsigned int> // cache size
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventCache)
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Max)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_TEMPLATE_FUNCTION(Find)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTCACHE_H

/*---------------------------------
|	End of GEventCache.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventGenerator.h
----------------------------------*/
#ifndef GEVENTGENERATOR_H
#define GEVENTGENERATOR_H


 // can store and examine GEvents for later processing  
 // contains user defined logic for handling a GEvent

namespace GW
{
	namespace I
	{
		// The GEventGenerator Interface is capable of notifying end users of various events that occur during runtime.
		// This interface supports asynchronus addition, removal & notification of observer interfaces
		class GEventGeneratorInterface : public virtual GInterfaceInterface
		{
			// All Gateware API interfaces contain no variables & are pure virtual.		
		public:
			// For API consistency all Gateware "Event Generators" must have an event list called "Events"
			// They can be values other than integer (eg: floats) but must be POD (plain old data)
			enum class Events
			{
				NON_EVENT
			};
			// For API consistency all Gateware "Event Generators" must have an event struct called "EVENT_DATA"
			// All contined values must be POD (plain old data) and fit within a GEvent data block
			struct EVENT_DATA
			{
				std::nullptr_t noData;
			};

			virtual GReturn Register(CORE::GEventCache _recorder) = 0; // Overloads registration for GEventCache
			virtual GReturn Register(CORE::GEventResponder _responder) = 0; // Overloads registration for GEventResponders
			virtual GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) = 0; // Linking to an event generator this way is very specific, use GEventResponder for a more flexible option
			virtual GReturn Deregister(CORE::GInterface _observer) = 0;
			virtual GReturn Observers(unsigned int& _outCount) const = 0;
			virtual GReturn Push(const GEvent& _newEvent) = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventGenerator.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTGENERATOR) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTGENERATOR) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventGeneratorImplementation :	public virtual GEventGeneratorInterface,
												public GThreadSharedImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Register(CORE::GEventCache _recorder) override {
				return GReturn::FAILURE;
			}
			GReturn Register(CORE::GEventResponder _responder) override {
				return GReturn::FAILURE;
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return GReturn::FAILURE;
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return GReturn::FAILURE;
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Push(const GEvent& _newEvent) override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#include <vector> // used to track messagable objects

// define temporary internal defines (GWI = Gateware Internal)
#define GWI_MAX_TRAVERSAL_STACK 32 

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Holds a vector of GEvents which it periodically cleans and sends new events to.
		class GEventGeneratorImplementation :	public virtual GEventGeneratorInterface,
												protected GThreadSharedImplementation // handles resource locking
		{
			// internal data members
			std::vector<std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)>> listeners;

			// Ok we use a per-function cache & smart recursion to lock down the vector.
			// We populate the cache and then execute the callbacks.

			// This should be safe from multiple threads.

			void RecursivePush(const GEvent& _newEvent, unsigned int _offset)
			{
				unsigned int numToInvoke = 0;
				CORE::GEventCache isCache;
				CORE::GEventResponder isResponder;
				// Local stack of objects to visit, can grow with recursion.
				// We use a caching technique because we don't know what logic is present in the callbacks.
				// For example a callback could invoke a "Register" or "Push" from this very class leading to a deadlock.
				std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)> toInvoke[GWI_MAX_TRAVERSAL_STACK];
				// if this is the root call, lock for editing
				if (_offset == 0) 
					LockSyncWrite();
				// traversing the container backwards should make removals a bit more efficient
				int current = static_cast<int>(listeners.size()) - 1 - _offset;
				// traverse contaniner, append to local array, remove dead proxies
				while (current >= 0 && numToInvoke < GWI_MAX_TRAVERSAL_STACK)
				{
					if (listeners[current].first) {
						toInvoke[numToInvoke] = listeners[current];
						numToInvoke++;
						current--;
					}
					else {
						listeners.erase(listeners.begin() + current);
						current--;
					}
				}
				// if we max local array then recurse with offset
				if (current >= 0) // still have some left?
					RecursivePush(_newEvent, _offset + GWI_MAX_TRAVERSAL_STACK);
				else // if you DON'T end up calling a recursive call, then unlock
					UnlockSyncWrite();
				// Traverse local array & Invoke each function & interface combo avaliable.
				while (numToInvoke)
				{	// traverse backwards so we get proper FIFO traversal with recursion
					numToInvoke--;
					if (*toInvoke[numToInvoke].second != nullptr) { // this is the normal behavior
						(*toInvoke[numToInvoke].second)(_newEvent, toInvoke[numToInvoke].first);
					} // if a static handler is not present we will try to use a first class type
					else if (isResponder = toInvoke[numToInvoke].first.Mirror()) { 
						isResponder.Invoke(_newEvent); // handle it now
						isResponder = nullptr; // release handle
					}
					else if (isCache = toInvoke[numToInvoke].first.Mirror()) {
						isCache.Append(_newEvent); // handle it later
						isCache = nullptr; // release handle
					}
					toInvoke[numToInvoke].first = nullptr; // no hanging counts plz...
				}
			}
			// study
			// Q R S T U V X Y Z
			// On recurse with size 3
			// Z Y X // full
				// V U T // full
					// S R Q // full

			// execute FIFO traversal!

		public:

			GReturn Create()
			{
				return GReturn::SUCCESS; // just works
			}

			GReturn Register(CORE::GEventCache _recorder) override
			{
				if (_recorder)
				{
					LockSyncWrite();
					listeners.push_back( 
						std::pair<CORE::GInterface, 
						void(*)(const GEvent&, CORE::GInterface&)>
						(_recorder.Mirror(), nullptr));
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Register(CORE::GEventResponder _responder) override
			{
				if (_responder)
				{
					LockSyncWrite();
					listeners.push_back(
						std::pair<CORE::GInterface,
						void(*)(const GEvent&, CORE::GInterface&)>
						(_responder.Mirror(), nullptr));
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override
			{
				if (_observer && _callback != nullptr)
				{
					LockSyncWrite();
					listeners.push_back( /* THIS IS FINE, THE TRAVERSAL IS ALREADY BACKWARDS! TEST NEXT! */
						std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)>(_observer.Mirror(),_callback) );
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Deregister(CORE::GInterface _observer) override
			{
				GReturn result = GReturn::INVALID_ARGUMENT;
				if (_observer && +LockSyncWrite()) 
				{
					result = GReturn::FAILURE;
					auto iter = listeners.begin();
					while (	iter != listeners.end() && 
							result == GReturn::FAILURE)
					{
						if (iter->first == _observer) {
							listeners.erase(iter);
							result = GReturn::SUCCESS;
						}
						else {
							iter = std::next(iter);
						}
					}
					UnlockSyncWrite();
				}
				return result;
			}
			
			GReturn Observers(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = static_cast<unsigned int>(listeners.size());
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn Push(const GEvent& _newEvent) override
			{
				if (listeners.empty()) // empty() should be thread safe on vector
					return GReturn::REDUNDANT; 
				// traverse & remove dead proxies while notifying receivers
				RecursivePush(_newEvent, 0);
				return GReturn::SUCCESS;
			}
		};

	} // end CORE
} // end GW

// undefine temporary internal defines
#undef GWI_MAX_TRAVERSAL_STACK 


#endif 



namespace GW
{
	namespace CORE
	{
		class GEventGenerator final
			: public I::GProxy<I::GEventGeneratorInterface, I::GEventGeneratorImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
            GATEWARE_PROXY_CLASS(GEventGenerator)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Register)
			GATEWARE_FUNCTION(Deregister)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTGENERATOR_H

/*---------------------------------
|	End of GEventGenerator.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventReceiver.h
----------------------------------*/
#ifndef GEVENTRECEIVER_H
#define GEVENTRECEIVER_H



#include <functional>

namespace GW
{
	namespace I
	{
		class GEventReceiverInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Append(const GEvent& _inEvent) = 0;
			virtual GReturn Waiting(unsigned int& _outCount) const = 0;
			virtual GReturn Pop(GEvent& _outEvent) = 0;
			virtual GReturn Peek(GEvent& _outEvent) const = 0;
			virtual GReturn Missed(unsigned int& _outCount) const = 0;
			virtual GReturn Clear() = 0;
			virtual GReturn Invoke() const = 0;
			template<class eventType>
			GReturn Find(eventType _check, bool _remove);
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData);
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventReceiver.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTRECEIVER) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTRECEIVER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventReceiverImplementation :	public virtual GEventReceiverInterface,
												private GThreadSharedImplementation
		{
		public:
			GReturn Create(CORE::GEventGenerator _listenToMe, std::function<void()> _callback) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW
// Required for dummy compilation but does nothing
namespace internal_gw {
	static void(*event_receiver_callback)(const GW::GEvent&, GW::CORE::GInterface&) = nullptr;
	template<class Proxy>
	static void event_receiver_logic(const GW::GEvent& _e, GW::CORE::GInterface& _i) {};
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// internal namespace used for global Gateware variables & callbacks  
namespace internal_gw 
{
	// internal call that forwards arguments to internal std::function
	// The logic for this operation is implemented later once the GEventReceiver Proxy is defined
	static void(*event_receiver_callback)(const GW::GEvent&, GW::CORE::GInterface&) = nullptr;
	
	// Actual logic for above callback, will be defined after declaration of GEventReceiver
	template<class Proxy> // will be defined as GEventReceiver
	static void event_receiver_logic(const GW::GEvent& _e, GW::CORE::GInterface& _i)
	{
		Proxy r(_i.Mirror()); // mirror for speed where possible & appropriate
		r.Append(_e); // if an invalid Proxy is requested this will fail to be intialized
		r.Invoke();
	};
} // end internal_gw namespace

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a GEvent and allows it to be updated by a GEventGenerator
		// Also connects itself to said Generator during creation
		class GEventReceiverImplementation :	public virtual GEventReceiverInterface,
												protected GThreadSharedImplementation, // resource locking
												public std::enable_shared_from_this<GInterfaceInterface>
		{
			// internal data members
			unsigned int eventWaiting = 0;
			unsigned int missedEvents = 0;
			std::function<void()> callback = nullptr;
			GEvent lastEvent; // can be used to see what happened

		public:
			// Must match Proxy argument list
			GReturn Create(CORE::GEventGenerator _listenToMe, std::function<void()> _callback)
			{
				if (_listenToMe && internal_gw::event_receiver_callback)
				{
					callback = _callback; // nullptr is ok, optional.	
					// This is how to create a Proxy from "this", ideally we try and avoid doing this.
					CORE::GInterface me(shared_from_this()); // we create a temporary so only weak access is transfered
					// While weak access is not as fast, it grants lifetime control and flexibility to the user.
					// If you want the most efficiency you should consider calling "Register" directly with a fixed callback.
					return _listenToMe.Register(me, internal_gw::event_receiver_callback);
				}
				else if(internal_gw::event_receiver_callback)
					return GReturn::INVALID_ARGUMENT; // cannot be null EventGenerator
				else
					return GReturn::UNEXPECTED_RESULT; // global callback was not assigned!
			}
			GReturn Append(const GEvent& _inEvent) override
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventWaiting) ++missedEvents; // did they miss the last one?
					lastEvent = _inEvent; // copy new event
					eventWaiting = 1; // let them know (we can only hold one)
					if (+UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = eventWaiting;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventWaiting)
					{
						--eventWaiting;
						_outEvent = lastEvent;						
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventWaiting)
					{
						_outEvent = lastEvent;
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventWaiting)
					{
						eventWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override
			{
				if (callback)
				{					
					callback(); // Invoke internal callback (can be done from multiple threads)
					return GReturn::SUCCESS;
				}
				// No callback attatched, so it cannot be invoked
				return GReturn::FAILURE; 
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventWaiting)
					{
						if (G_PASS(result = lastEvent.Read(event)))
						{
							if (event == _check) // found it?
							{
								if (_remove) --eventWaiting; // clear found event
								result = GReturn::SUCCESS;
							}
							else
								result = GReturn::FAILURE;
						}
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventWaiting)
					{
						if (G_PASS(result = lastEvent.Read(event, _outData)))
						{
							if (event == _check) // found it?
							{
								if (_remove) --eventWaiting; // clear found event
								result = GReturn::SUCCESS;
							}
							else
								result = GReturn::FAILURE;
						}
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GEventReceiver final
			: public I::GProxy<I::GEventReceiverInterface, I::GEventReceiverImplementation, GEventGenerator, std::function<void()>>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback { init_callback() {
				internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GEventReceiver>;
			} }init; // hopefully your compiler will optimize this out
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventReceiver)
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRECEIVER_H

/*---------------------------------
|	End of GEventReceiver.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventQueue.h
----------------------------------*/
#ifndef GEVENTQUEUE_H
#define GEVENTQUEUE_H




namespace GW
{
	namespace I
	{
		class GEventQueueInterface : public virtual GEventReceiverInterface
		{
		public:
			// Let the compiler know that we intend to use the base class method as well as an override with an additional parameter
			using GEventReceiverInterface::Peek;
			// new methods
			virtual GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const = 0; // override
			virtual GReturn Max(unsigned int& _outSize) const = 0;

			// we internally override Queue template "Find" functions to search whole queue
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventQueue.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTQUEUE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTQUEUE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventQueueImplementation :	public virtual GEventQueueInterface,
											private GThreadSharedImplementation
		{
		public:
			// New operations
			GReturn Create(unsigned int _maxSize, CORE::GEventGenerator _listenToMe, std::function<void()> _callback) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Max(unsigned int& _outSize) const override {
				return GReturn::FAILURE;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GEventQueueImplementation :	public virtual GEventQueueInterface,
											private GThreadSharedImplementation, // resource locking
											public std::enable_shared_from_this<GInterfaceInterface>
		{
			// internal data members
			int enque = 0; // where items are enqued
			int deque = 0; // where items are dequed
			unsigned int maxEvents = 0; // size of the queue
			unsigned int missedEvents = 0; // increases if the queue is at capacity during append
			unsigned int eventsWaiting = 0; // number of events currently queued
			GEvent* circularQueue = nullptr; // where events are stored (ring buffer)
			std::function<void()> callback = nullptr; // custom user invocation on new event (optional)

			// functions for circular queue (since std does not seem to provide one)
			// NOTE: we may want to shift this into "key" as an ADT if it sees more widespread application
			
			// returns false if queue is full
			bool Enque(const GEvent& _push) 
			{
				if (eventsWaiting >= maxEvents)
					return false;
				circularQueue[enque] = _push;
				enque = (enque + 1) % maxEvents;
				++eventsWaiting;
				return true;
			}
			// returns false if queue is empty
			bool Deque(GEvent* _pop) // optional
			{
				if (eventsWaiting == 0)
					return false;
				if(_pop != nullptr)
					*_pop = circularQueue[deque];
				deque = (deque + 1) % maxEvents;
				--eventsWaiting;
				return true;
			}
			// required to fully implement the "Find" routines
			// while collapsing the queue is not optimal we go for the closest point to minimize copies
			bool Erase(unsigned int _offset) // offset from dequqe point
			{
				if (eventsWaiting == 0 || _offset >= eventsWaiting) // should we bother?
					return false;
				// which is closer enque or deque?
				int dir = (_offset < (eventsWaiting >> 1)) ? maxEvents - 1 : 1;
				int stop = (dir == 1) ? enque : (deque + dir) % maxEvents; // stop here
				_offset = (deque + _offset) % maxEvents; // this starting spot should be valid now
				for (int i = (_offset + dir) % maxEvents; i != stop; i = (i + dir) % maxEvents)
				{
					circularQueue[_offset] = circularQueue[i]; // copy & move
					_offset = i; // next
				}
				// update enque or deque based on which way we closed the gap
				(dir == 1) ? enque = _offset : deque = ((deque + 1) % maxEvents);
				--eventsWaiting; // reduce overall size of queue
				return true; // hopefully the logic above is good we will test it
			}
			// queue theory:
			// 0 1 2 3 4 5 6
			// - - D + + + E
			// + E - - D + +
			// + E - - - - D
			// D E - - - - -
			// - - - D E - -
			// + + E D + + +
			// - D + + E - -
			// + + + + + E D

		
		public:
			// with dynamic memory present we must free any allocated resources
			~GEventQueueImplementation()
			{
				delete[] circularQueue; // free allocated queue
			}
			// You must select a maximum size of the queue as for efficiency it is implemented as a circular array
			GReturn Create(unsigned int _maxSize, CORE::GEventGenerator _listenToMe, std::function<void()> _callback) 
			{
				if (_maxSize && _listenToMe && internal_gw::event_receiver_callback)
				{	
					// generate circular queue
					circularQueue = new GEvent[_maxSize];
					maxEvents = _maxSize; // store mamximum allowable event data
					callback = _callback; // nullptr is ok, optional.	
					// This is how to create a Proxy from "this", ideally we try and avoid doing this.
					CORE::GInterface me(shared_from_this()); // we create a temporary so only weak access is transfered
					// While weak access is not as fast, it grants lifetime control and flexibility to the user.
					// If you want the most efficiency you should consider calling "Register" directly with a fixed callback.
					return _listenToMe.Register(me, internal_gw::event_receiver_callback);					
				}
				else if (internal_gw::event_receiver_callback)
					return GReturn::INVALID_ARGUMENT; // cannot be null EventGenerator or Zero Size Queue! 
				else
					return GReturn::UNEXPECTED_RESULT; // global callback was not assigned!
			}
			GReturn Max(unsigned int& _outSize) const override 
			{
				LockAsyncRead();
				_outSize = maxEvents; // get maximum size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override 
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventsWaiting >= maxEvents) // are we are full?
					{
						Deque(nullptr); // remove an existing event so we have room
						++missedEvents; // notify we missed an event
					}
					// append new event (should always happen)
					if (Enque(_inEvent) && +UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override 
			{
				LockAsyncRead();
				_outCount = eventsWaiting; // get current size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (Deque(&_outEvent))
						result = GReturn::SUCCESS;
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						_outEvent = circularQueue[deque];
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override
			{
				// Use deque + _eventIndex % maxEvents to find the right spot
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						if (_eventIndex < eventsWaiting) // must be a valid index
						{
							_outEvent = circularQueue[(deque + _eventIndex) % maxEvents];
							result = GReturn::SUCCESS;
						}
						else
							result = GReturn::INVALID_ARGUMENT; // out of range
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents; // how many events were ignored
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventsWaiting)
					{
						enque = deque = eventsWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override 
			{
				if (callback)
				{
					callback(); // Invoke internal callback (can be done from multiple threads)
					return GReturn::SUCCESS;
				}
				// No callback attatched, so it cannot be invoked
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS 
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						}while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event, _outData)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						} while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class  GEventQueue final
			: public I::GProxy<I::GEventQueueInterface, I::GEventQueueImplementation, unsigned int, GEventGenerator, const std::function<void()>>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback {
				init_callback() {
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventQueue)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Max)
			
			// reimplemented 
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTQUEUE_H


/*---------------------------------
|	End of GEventQueue.h
----------------------------------*/


/*---------------------------------
|	Begin of GFile.h
----------------------------------*/
#ifndef GFILE_H
#define GFILE_H




namespace GW
{
	namespace I
	{
		class GFileInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn OpenBinaryRead(const char* const _file) = 0;
			virtual GReturn OpenBinaryWrite(const char* const _file) = 0;
			virtual GReturn AppendBinaryWrite(const char* const _file) = 0;
			virtual GReturn OpenTextRead(const char* const _file) = 0;
			virtual GReturn OpenTextWrite(const char* const _file) = 0;
			virtual GReturn AppendTextWrite(const char* const _file) = 0;
			virtual GReturn Write(const char* const _inData, unsigned int _numBytes) = 0;
			virtual GReturn Read(char* _outData, unsigned int _numBytes) = 0;
			virtual GReturn WriteLine(const char* const _inData) = 0;
			virtual GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) = 0;
			virtual GReturn CloseFile() = 0;
			virtual GReturn FlushFile() = 0;
			virtual GReturn SetCurrentWorkingDirectory(const char* const _dir) = 0;
			virtual GReturn GetCurrentWorkingDirectory(char* _outDir, unsigned int _dirSize) = 0;
			virtual GReturn GetDirectorySize(unsigned int& _outSize) = 0;
			virtual GReturn GetSubDirectorySize(unsigned int& _outSize) = 0;
			virtual GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) = 0;
			virtual GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) = 0;
			virtual GReturn GetFileSize(const char* const _file, unsigned int& _outSize) = 0;
			virtual GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) = 0;
		};
	}
};

// Implementaion for GFile.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.

// dirent.h is not native to Windows and is added to the project
// The " " are used for include so the compiler knows to look in the
// project folder first.
// dirent.h is native in Linux and Mac so the < > are used to include.
// Apple and Linux includes.
#if defined(__APPLE__) || defined(__linux__)
	#include <dirent.h>
#elif defined(_WIN32)
	/*
 * Dirent interface for Microsoft Visual Studio
 * Version 1.21
 *
 * Copyright (C) 2006-2012 Toni Ronkko
 * This file is part of dirent.  Dirent may be freely distributed
 * under the MIT license.  For all details and documentation, see
 * https://github.com/tronkko/dirent
 */
#ifndef DIRENT_H
#define DIRENT_H

/*
 * Define architecture flags so we don't need to include windows.h.
 * Avoiding windows.h makes it simpler to use windows sockets in conjunction
 * with dirent.h.
 */
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#   define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#include <stdio.h>
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

/* Indicates that d_type field is available in dirent structure */
#define _DIRENT_HAVE_D_TYPE

/* Indicates that d_namlen field is available in dirent structure */
#define _DIRENT_HAVE_D_NAMLEN

/* Entries missing from MSVC 6.0 */
#if !defined(FILE_ATTRIBUTE_DEVICE)
#   define FILE_ATTRIBUTE_DEVICE 0x40
#endif

/* File type and permission flags for stat(), general mask */
#if !defined(S_IFMT)
#   define S_IFMT _S_IFMT
#endif

/* Directory bit */
#if !defined(S_IFDIR)
#   define S_IFDIR _S_IFDIR
#endif

/* Character device bit */
#if !defined(S_IFCHR)
#   define S_IFCHR _S_IFCHR
#endif

/* Pipe bit */
#if !defined(S_IFFIFO)
#   define S_IFFIFO _S_IFFIFO
#endif

/* Regular file bit */
#if !defined(S_IFREG)
#   define S_IFREG _S_IFREG
#endif

/* Read permission */
#if !defined(S_IREAD)
#   define S_IREAD _S_IREAD
#endif

/* Write permission */
#if !defined(S_IWRITE)
#   define S_IWRITE _S_IWRITE
#endif

/* Execute permission */
#if !defined(S_IEXEC)
#   define S_IEXEC _S_IEXEC
#endif

/* Pipe */
#if !defined(S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* Block device */
#if !defined(S_IFBLK)
#   define S_IFBLK 0
#endif

/* Link */
#if !defined(S_IFLNK)
#   define S_IFLNK 0
#endif

/* Socket */
#if !defined(S_IFSOCK)
#   define S_IFSOCK 0
#endif

/* Read user permission */
#if !defined(S_IRUSR)
#   define S_IRUSR S_IREAD
#endif

/* Write user permission */
#if !defined(S_IWUSR)
#   define S_IWUSR S_IWRITE
#endif

/* Execute user permission */
#if !defined(S_IXUSR)
#   define S_IXUSR 0
#endif

/* Read group permission */
#if !defined(S_IRGRP)
#   define S_IRGRP 0
#endif

/* Write group permission */
#if !defined(S_IWGRP)
#   define S_IWGRP 0
#endif

/* Execute group permission */
#if !defined(S_IXGRP)
#   define S_IXGRP 0
#endif

/* Read others permission */
#if !defined(S_IROTH)
#   define S_IROTH 0
#endif

/* Write others permission */
#if !defined(S_IWOTH)
#   define S_IWOTH 0
#endif

/* Execute others permission */
#if !defined(S_IXOTH)
#   define S_IXOTH 0
#endif

/* Maximum length of file name */
#if !defined(PATH_MAX)
#   define PATH_MAX MAX_PATH
#endif
#if !defined(FILENAME_MAX)
#   define FILENAME_MAX MAX_PATH
#endif
#if !defined(NAME_MAX)
#   define NAME_MAX FILENAME_MAX
#endif

/* File type flags for d_type */
#define DT_UNKNOWN 0
#define DT_REG S_IFREG
#define DT_DIR S_IFDIR
#define DT_FIFO S_IFIFO
#define DT_SOCK S_IFSOCK
#define DT_CHR S_IFCHR
#define DT_BLK S_IFBLK
#define DT_LNK S_IFLNK

/* Macros for converting between st_mode and d_type */
#define IFTODT(mode) ((mode) & S_IFMT)
#define DTTOIF(type) (type)

/*
 * File type macros.  Note that block devices, sockets and links cannot be
 * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
 * only defined for compatibility.  These macros should always return false
 * on Windows.
 */
#if !defined(S_ISFIFO)
#   define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISDIR)
#   define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG)
#   define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISLNK)
#   define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK)
#   define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISCHR)
#   define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISBLK)
#   define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif

/* Return the exact length of d_namlen without zero terminator */
#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)

/* Return number of bytes needed to store d_namlen */
#define _D_ALLOC_NAMLEN(p) (PATH_MAX)


#ifdef __cplusplus
extern "C" {
#endif


/* Wide-character version */
struct _wdirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    wchar_t d_name[PATH_MAX];
};
typedef struct _wdirent _wdirent;

struct _WDIR {
    /* Current directory entry */
    struct _wdirent ent;

    /* Private file data */
    WIN32_FIND_DATAW data;

    /* True if data is valid */
    int cached;

    /* Win32 search handle */
    HANDLE handle;

    /* Initial directory name */
    wchar_t *patt;
};
typedef struct _WDIR _WDIR;

static _WDIR *_wopendir (const wchar_t *dirname);
static struct _wdirent *_wreaddir (_WDIR *dirp);
static int _wclosedir (_WDIR *dirp);
static void _wrewinddir (_WDIR* dirp);


/* For compatibility with Symbian */
#define wdirent _wdirent
#define WDIR _WDIR
#define wopendir _wopendir
#define wreaddir _wreaddir
#define wclosedir _wclosedir
#define wrewinddir _wrewinddir


/* Multi-byte character versions */
struct dirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    char d_name[PATH_MAX];
};
typedef struct dirent dirent;

struct DIR {
    struct dirent ent;
    struct _WDIR *wdirp;
};
typedef struct DIR DIR;

static DIR *opendir (const char *dirname);
static struct dirent *readdir (DIR *dirp);
static int closedir (DIR *dirp);
static void rewinddir (DIR* dirp);


/* Internal utility functions */
static WIN32_FIND_DATAW *dirent_first (_WDIR *dirp);
static WIN32_FIND_DATAW *dirent_next (_WDIR *dirp);

static int dirent_mbstowcs_s(
    size_t *pReturnValue,
    wchar_t *wcstr,
    size_t sizeInWords,
    const char *mbstr,
    size_t count);

static int dirent_wcstombs_s(
    size_t *pReturnValue,
    char *mbstr,
    size_t sizeInBytes,
    const wchar_t *wcstr,
    size_t count);

static void dirent_set_errno (int error);

/*
 * Open directory stream DIRNAME for read and return a pointer to the
 * internal working area that is used to retrieve individual directory
 * entries.
 */
static _WDIR*
_wopendir(
    const wchar_t *dirname)
{
    _WDIR *dirp = NULL;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate new _WDIR structure */
    dirp = (_WDIR*) malloc (sizeof (struct _WDIR));
    if (dirp != NULL) {
        DWORD n;

        /* Reset _WDIR structure */
        dirp->handle = INVALID_HANDLE_VALUE;
        dirp->patt = NULL;
        dirp->cached = 0;

        /* Compute the length of full path plus zero terminator */
        n = GetFullPathNameW (dirname, 0, NULL, NULL);

        /* Allocate room for absolute directory name and search pattern */
        dirp->patt = (wchar_t*) malloc (sizeof (wchar_t) * n + 16);
        if (dirp->patt) {

            /*
             * Convert relative directory name to an absolute one.  This
             * allows rewinddir() to function correctly even when current
             * working directory is changed between opendir() and rewinddir().
             */
            n = GetFullPathNameW (dirname, n, dirp->patt, NULL);
            if (n > 0) {
                wchar_t *p;

                /* Append search pattern \* to the directory name */
                p = dirp->patt + n;
                if (dirp->patt < p) {
                    switch (p[-1]) {
                    case '\\':
                    case '/':
                    case ':':
                        /* Directory ends in path separator, e.g. c:\temp\ */
                        /*NOP*/;
                        break;

                    default:
                        /* Directory name doesn't end in path separator */
                        *p++ = '\\';
                    }
                }
                *p++ = '*';
                *p = '\0';

                /* Open directory stream and retrieve the first entry */
                if (dirent_first (dirp)) {
                    /* Directory stream opened successfully */
                    error = 0;
                } else {
                    /* Cannot retrieve first entry */
                    error = 1;
                    dirent_set_errno (ENOENT);
                }

            } else {
                /* Cannot retrieve full path name */
                dirent_set_errno (ENOENT);
                error = 1;
            }

        } else {
            /* Cannot allocate memory for search pattern */
            error = 1;
        }

    } else {
        /* Cannot allocate _WDIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &&  dirp) {
        _wclosedir (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.  The directory entry is returned in dirent
 * structure in the d_name field.  Individual directory entries returned by
 * this function include regular files, sub-directories, pseudo-directories
 * "." and ".." as well as volume labels, hidden files and system files.
 */
static struct _wdirent*
_wreaddir(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;
    struct _wdirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp);
    if (datap) {
        size_t n;
        DWORD attr;
        
        /* Pointer to directory entry to return */
        entp = &dirp->ent;

        /* 
         * Copy file name as wide-character string.  If the file name is too
         * long to fit in to the destination buffer, then truncate file name
         * to PATH_MAX characters and zero-terminate the buffer.
         */
        n = 0;
        while (n + 1 < PATH_MAX  &&  datap->cFileName[n] != 0) {
            entp->d_name[n] = datap->cFileName[n];
            n++;
        }
        dirp->ent.d_name[n] = 0;

        /* Length of file name excluding zero terminator */
        entp->d_namlen = n;

        /* File type */
        attr = datap->dwFileAttributes;
        if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
            entp->d_type = DT_CHR;
        } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            entp->d_type = DT_DIR;
        } else {
            entp->d_type = DT_REG;
        }

        /* Reset dummy fields */
        entp->d_ino = 0;
        entp->d_reclen = sizeof (struct _wdirent);

    } else {

        /* Last directory entry read */
        entp = NULL;

    }

    return entp;
}

/*
 * Close directory stream opened by opendir() function.  This invalidates the
 * DIR structure as well as any directory entry read previously by
 * _wreaddir().
 */
static int
_wclosedir(
    _WDIR *dirp)
{
    int ok;
    if (dirp) {

        /* Release search handle */
        if (dirp->handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp->handle);
            dirp->handle = INVALID_HANDLE_VALUE;
        }

        /* Release search pattern */
        if (dirp->patt) {
            free (dirp->patt);
            dirp->patt = NULL;
        }

        /* Release directory structure */
        free (dirp);
        ok = /*success*/0;

    } else {
        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;
    }
    return ok;
}

/*
 * Rewind directory stream such that _wreaddir() returns the very first
 * file name again.
 */
static void
_wrewinddir(
    _WDIR* dirp)
{
    if (dirp) {
        /* Release existing search handle */
        if (dirp->handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp->handle);
        }

        /* Open new search handle */
        dirent_first (dirp);
    }
}

/* Get first directory entry (internal) */
static WIN32_FIND_DATAW*
dirent_first(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;

    /* Open directory and retrieve the first entry */
    dirp->handle = FindFirstFileW (dirp->patt, &dirp->data);
    if (dirp->handle != INVALID_HANDLE_VALUE) {

        /* a directory entry is now waiting in memory */
        datap = &dirp->data;
        dirp->cached = 1;

    } else {

        /* Failed to re-open directory: no directory entry in memory */
        dirp->cached = 0;
        datap = NULL;

    }
    return datap;
}

/* Get next directory entry (internal) */
static WIN32_FIND_DATAW*
dirent_next(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *p;

    /* Get next directory entry */
    if (dirp->cached != 0) {

        /* A valid directory entry already in memory */
        p = &dirp->data;
        dirp->cached = 0;

    } else if (dirp->handle != INVALID_HANDLE_VALUE) {

        /* Get the next directory entry from stream */
        if (FindNextFileW (dirp->handle, &dirp->data) != FALSE) {
            /* Got a file */
            p = &dirp->data;
        } else {
            /* The very last entry has been processed or an error occured */
            FindClose (dirp->handle);
            dirp->handle = INVALID_HANDLE_VALUE;
            p = NULL;
        }

    } else {

        /* End of directory stream reached */
        p = NULL;

    }

    return p;
}

/* 
 * Open directory stream using plain old C-string.
 */
static DIR*
opendir(
    const char *dirname) 
{
    struct DIR *dirp;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate memory for DIR structure */
    dirp = (DIR*) malloc (sizeof (struct DIR));
    if (dirp) {
        wchar_t wname[PATH_MAX];
        size_t n;

        /* Convert directory name to wide-character string */
        error = dirent_mbstowcs_s (&n, wname, PATH_MAX, dirname, PATH_MAX);
        if (!error) {

            /* Open directory stream using wide-character name */
            dirp->wdirp = _wopendir (wname);
            if (dirp->wdirp) {
                /* Directory stream opened */
                error = 0;
            } else {
                /* Failed to open directory stream */
                error = 1;
            }

        } else {
            /* 
             * Cannot convert file name to wide-character string.  This
             * occurs if the string contains invalid multi-byte sequences or
             * the output buffer is too small to contain the resulting
             * string.
             */
            error = 1;
        }

    } else {
        /* Cannot allocate DIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &&  dirp) {
        free (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.
 *
 * When working with text consoles, please note that file names returned by
 * readdir() are represented in the default ANSI code page while any output to
 * console is typically formatted on another code page.  Thus, non-ASCII
 * characters in file names will not usually display correctly on console.  The
 * problem can be fixed in two ways: (1) change the character set of console
 * to 1252 using chcp utility and use Lucida Console font, or (2) use
 * _cprintf function when writing to console.  The _cprinf() will re-encode
 * ANSI strings to the console code page so many non-ASCII characters will
 * display correcly.
 */
static struct dirent*
readdir(
    DIR *dirp) 
{
    WIN32_FIND_DATAW *datap;
    struct dirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp->wdirp);
    if (datap) {
        size_t n;
        int error;

        /* Attempt to convert file name to multi-byte string */
        error = dirent_wcstombs_s(
            &n, dirp->ent.d_name, PATH_MAX, datap->cFileName, PATH_MAX);

        /* 
         * If the file name cannot be represented by a multi-byte string,
         * then attempt to use old 8+3 file name.  This allows traditional
         * Unix-code to access some file names despite of unicode
         * characters, although file names may seem unfamiliar to the user.
         *
         * Be ware that the code below cannot come up with a short file
         * name unless the file system provides one.  At least
         * VirtualBox shared folders fail to do this.
         */
        if (error  &&  datap->cAlternateFileName[0] != '\0') {
            error = dirent_wcstombs_s(
                &n, dirp->ent.d_name, PATH_MAX, 
                datap->cAlternateFileName, PATH_MAX);
        }

        if (!error) {
            DWORD attr;

            /* Initialize directory entry for return */
            entp = &dirp->ent;

            /* Length of file name excluding zero terminator */
            entp->d_namlen = n - 1;

            /* File attributes */
            attr = datap->dwFileAttributes;
            if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
                entp->d_type = DT_CHR;
            } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
                entp->d_type = DT_DIR;
            } else {
                entp->d_type = DT_REG;
            }

            /* Reset dummy fields */
            entp->d_ino = 0;
            entp->d_reclen = sizeof (struct dirent);

        } else {
            /* 
             * Cannot convert file name to multi-byte string so construct
             * an errornous directory entry and return that.  Note that
             * we cannot return NULL as that would stop the processing
             * of directory entries completely.
             */
            entp = &dirp->ent;
            entp->d_name[0] = '?';
            entp->d_name[1] = '\0';
            entp->d_namlen = 1;
            entp->d_type = DT_UNKNOWN;
            entp->d_ino = 0;
            entp->d_reclen = 0;
        }

    } else {
        /* No more directory entries */
        entp = NULL;
    }

    return entp;
}

/*
 * Close directory stream.
 */
static int
closedir(
    DIR *dirp) 
{
    int ok;
    if (dirp) {

        /* Close wide-character directory stream */
        ok = _wclosedir (dirp->wdirp);
        dirp->wdirp = NULL;

        /* Release multi-byte character version */
        free (dirp);

    } else {

        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;

    }
    return ok;
}

/*
 * Rewind directory stream to beginning.
 */
static void
rewinddir(
    DIR* dirp) 
{
    /* Rewind wide-character string directory stream */
    _wrewinddir (dirp->wdirp);
}

/* Convert multi-byte string to wide character string */
static int
dirent_mbstowcs_s(
    size_t *pReturnValue,
    wchar_t *wcstr,
    size_t sizeInWords,
    const char *mbstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = mbstowcs_s (pReturnValue, wcstr, sizeInWords, mbstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to wide-character string (or count characters) */
    n = mbstowcs (wcstr, mbstr, sizeInWords);
    if (!wcstr  ||  n < count) {

        /* Zero-terminate output buffer */
        if (wcstr  &&  sizeInWords) {
            if (n >= sizeInWords) {
                n = sizeInWords - 1;
            }
            wcstr[n] = 0;
        }

        /* Length of resuting multi-byte string WITH zero terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Could not convert string */
        error = 1;

    }

#endif

    return error;
}

/* Convert wide-character string to multi-byte string */
static int
dirent_wcstombs_s(
    size_t *pReturnValue,
    char *mbstr,
    size_t sizeInBytes, /* max size of mbstr */
    const wchar_t *wcstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = wcstombs_s (pReturnValue, mbstr, sizeInBytes, wcstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to multi-byte string (or count the number of bytes needed) */
    n = wcstombs (mbstr, wcstr, sizeInBytes);
    if (!mbstr  ||  n < count) {

        /* Zero-terminate output buffer */
        if (mbstr  &&  sizeInBytes) {
            if (n >= sizeInBytes) {
                n = sizeInBytes - 1;
            }
            mbstr[n] = '\0';
        }

        /* Lenght of resulting multi-bytes string WITH zero-terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Cannot convert string */
        error = 1;

    }

#endif

    return error;
}

/* Set errno variable */
static void
dirent_set_errno(
    int error)
{
#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 and later */
    _set_errno (error);

#else

    /* Non-Microsoft compiler or older Microsoft compiler */
    errno = error;

#endif
}


#ifdef __cplusplus
}
#endif
#endif /*DIRENT_H*/



#endif

#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GFILE) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GFILE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GFileImplementation : public GFileInterface
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			GReturn OpenBinaryRead(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenBinaryWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn AppendBinaryWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenTextRead(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenTextWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn AppendTextWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override {
				return GReturn::FAILURE;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override {
				return GReturn::FAILURE;
			}

			GReturn WriteLine(const char* const _inData) override {
				return GReturn::FAILURE;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override {
				return GReturn::FAILURE;
			}

			GReturn CloseFile() override {
				return GReturn::FAILURE;
			}

			GReturn FlushFile() override {
				return GReturn::FAILURE;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override {
				return GReturn::FAILURE;
			}

			GReturn GetCurrentWorkingDirectory(char* _outDir, unsigned int _dirSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetFilesFromDirectory(	char* _outFiles[], unsigned int _numFiles, 
											unsigned int _fileNameSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize,
											char* _outsubDir[]) override {
				return GReturn::FAILURE;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(__APPLE__)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
  //Internal utility functions
#include <stdio.h>

//dirent.h is not native to Windows and is added to the project
//The " " are used for include so the compiler knows to look in the
//project folder first.
//dirent.h is native in Linux and Mac so the < > are used to include.
#if defined(__APPLE__) || defined(__linux__)

//Apple and Linux includes.
  //Directory handling.
 //thread safety.
#include <sys/stat.h>  //File stats.
#include <string.h>
#include <cstring>

#define DIR_SEPERATOR '/'

#else

#error Gateware libraries are not currently supported for your platform

#endif

//The using statements for specifically what we are using.
using std::string;
using std::fstream;
using std::ios;
using std::atomic;
using std::mutex;
using std::getline;

namespace GW
{
    namespace I
    {
        class GFileImplementation : public virtual GW::I::GFileInterface, protected GThreadSharedImplementation
    
        {
            DIR* currDirStream;  //Maintains the current directory.
            fstream file;  //Maintains the current file (if one is open).
            FILE* binaryFile = NULL; //for binary read and write
            string currDir;  //A cached directory path for faster fetching.
            char initialDir[250];
            atomic<unsigned int> mode; //Used to track what open mode the file is in
            mutex lock; //Read/Write lock.
            unsigned int fileSize = 0;

        public:
            GFileImplementation()
            {
                currDirStream = nullptr;
            };
            
            virtual ~GFileImplementation()
            {
                SetCurrentWorkingDirectory(initialDir);
                //Close the current directory.
                closedir(currDirStream);

                //Close the file stream.
                CloseFile();
            };

            GReturn OpenBinaryRead(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is not already open.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file in the currentWorkingDirectory.
                file.open(currDir + G_TO_UTF16(_file), ios::in | ios::binary);

                //If the file failed to open the function fails.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to read
                mode = ios::in;
                
                // get the file size
                GetFileSize(_file, fileSize);
                
                return GW::GReturn::SUCCESS;
            };

            GReturn OpenBinaryWrite(const char* const _file) override
            {

                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //If the file is currently open we fail.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::binary);

                //If file failed to open we fail.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn AppendBinaryWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::binary | ios::app | ios::ate);

                //If file failed to open we fail.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn OpenTextRead(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::in);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to read
                mode = ios::in;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn OpenTextWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn AppendTextWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::app | ios::ate);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn Write(const char* const _inData, unsigned int _numBytes) override
            {
                //Check for invalid arguments.
                if (_inData == nullptr || _numBytes == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for writing
                if (mode != ios::out)
                    return GW::GReturn::FAILURE;

                //Lock the write operations.
                lock.lock();

                file.write(_inData, _numBytes);
                
                // update the file size
                fileSize += _numBytes;

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn Read(char* _outData, unsigned int _numBytes) override
            {
                if (_numBytes == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open() && binaryFile == NULL)
                {
                    _outData = nullptr;
                    return GW::GReturn::FAILURE;
                }

                //Make sure the file is opened for reading
                if (mode != ios::in)
                    return GW::GReturn::FAILURE;

                //Lock the read operations.
                lock.lock();

                file.read(_outData, _numBytes);

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn WriteLine(const char* const _inData) override
            {
                //Check for invalid arguments.
                if (_inData == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open())
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for writing
                if (mode != ios::out)
                    return GW::GReturn::FAILURE;

                //Transfer the data to a string. #defines make it so the
                //string is what we need it to be on any system we support.
                string writeOutString = G_TO_UTF16(_inData);

                //Lock the write operations.
                lock.lock();

                //Write out the string.
                file << writeOutString;
                
                // update the file size
                fileSize += static_cast<unsigned int>(writeOutString.length());

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
            {
                if (_outData == nullptr || _outDataSize == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure file is open.
                if (!file.is_open())
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for reading
                if (mode != ios::in)
                    return GW::GReturn::FAILURE;

                //The string to be read into.
                string outString;

                //Lock the read operations.
                lock.lock();

                //Just read in data normally.
                getline(file, outString, _delimiter);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                INTERNAL::strlcpy(_outData, _outDataSize, G_TO_UTF8(outString).c_str());
            #else

                //Copy the data over to the out parameter.
                INTERNAL::strcpy_s(_outData, _outDataSize, G_TO_UTF8(outString).c_str());

            #endif

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn CloseFile() override
            {
                //If a file is not open, we can not close it.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                if (binaryFile != NULL)
                {
                    fflush(binaryFile);
                    fclose(binaryFile);
                    binaryFile = nullptr;
                }
                else
                {
                    //Flush the file.
                    file.flush();
                    //Close the file.
                    file.close();
                }
                return GW::GReturn::SUCCESS;
            };

            GReturn FlushFile() override
            {
                //If a file is not open we can not flush it.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                if (binaryFile != NULL)
                    fflush(binaryFile);
                else
                {
                    //flush the file.
                    file.flush();
                }
                return GW::GReturn::SUCCESS;
            };

            GReturn SetCurrentWorkingDirectory(const char* const _dir) override
            {
                //Check for valid arguments.
                if (_dir == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Get the absolute path.
                char buffer[PATH_MAX];
                if (realpath(_dir, buffer) == nullptr)
                    return GW::GReturn::FAILURE;

                //Ensure the directory exists.
                struct stat s;
                if (stat(buffer, &s) != 0)
                    return GW::GReturn::FILE_NOT_FOUND;

                //Assign the passed in directory to our internal directory storage.
                currDir = buffer;
                currDir += DIR_SEPERATOR;

                //If there is an open directory, close it.
                if (currDirStream != nullptr)
                    closedir(currDirStream);

                //Open new directory.
                currDirStream = opendir(currDir.c_str());

                //Check to ensure directory is open.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                return GW::GReturn::SUCCESS;
            };

            GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
            {
                //Check for valid arguments.
                if (_dir == nullptr || _dirSize == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Check that a directory is open.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                INTERNAL::strlcpy(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
            #else
                //Copy the current directory to the out parameter.
                INTERNAL::strcpy_s(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
            #endif

                return GW::GReturn::SUCCESS;
            };

            GReturn GetDirectorySize(unsigned int& _outSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                struct dirent* file;
                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                //Reset the dir size.
                _outSize = 0;

                //Get the number of files in directory.
                while ((file = readdir(currDirStream)))
                {
                    if (file->d_type == DT_REG)
                        ++_outSize;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetSubDirectorySize(unsigned int& _outSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                struct dirent* subDir;
                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                //Reset the sub-dir size.
                _outSize = 0;

                while ((subDir = readdir(currDirStream)))
                {
                    if (strcmp(subDir->d_name, ".\0") == 0 ||
                        strcmp(subDir->d_name, "..\0") == 0)
                        continue;

                    if (subDir->d_type == DT_DIR)
                        ++_outSize;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                struct dirent* file;
                unsigned int fileIndex = 0;

                while ((file = readdir(currDirStream)) && fileIndex < _numFiles)
                {
                    if (file->d_type == DT_REG)
                    {
                        string fileName(file->d_name);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                        INTERNAL::strlcpy(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
            #else
                        INTERNAL::strcpy_s(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
            #endif

                        ++fileIndex;
                    }
                    else
                        continue;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                struct dirent* subDir;
                unsigned int subDirIndex = 0;

                while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
                {

                    if (strcmp(subDir->d_name, ".\0") == 0 ||
                        strcmp(subDir->d_name, "..\0") == 0)
                        continue;

                    if (subDir->d_type == DT_DIR)
                    {
                        string subDirName(subDir->d_name);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                        INTERNAL::strlcpy(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
            #else
                        INTERNAL::strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
            #endif

                        ++subDirIndex;
                    }
                    else
                        continue;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
            {
                //Make a full path to the file.
                string filePath = currDir;
                filePath += G_TO_UTF16(_file);

                struct stat s;
                if (stat(filePath.c_str(), &s) != 0)
                    return GW::GReturn::FILE_NOT_FOUND;

                //Copy the file size to the out parameter.
                _outSize = (unsigned int)s.st_size;

                return GW::GReturn::SUCCESS;
            };

            GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
                // if text file
                if (file.is_open()) {
                    // if not seeking from the current position
                    if (_seekFrom != -1) {
                        // check for invalid arguments
                        // lock
                        lock.lock();
                        if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
                            // seek to the new position relative to _seekFrom
                            std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
                            file.seekg(offset, std::ios_base::beg);
                            
                            // set the output to the new current position
                            _outCurrPos = static_cast<unsigned int>(file.tellg());

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    else { // seeking from the current position
                        // check for invalid arguments
                        // lock
                        lock.lock();

                        unsigned int pos = static_cast<unsigned int>(file.tellg());
                        if (0 <= pos + _amount && pos + _amount < fileSize) {
                            // seek to the new position relative to the current position
                            file.seekg(_amount, std::ios_base::cur);

                            // set the output to the new current position
                            _outCurrPos = static_cast<unsigned int>(file.tellg());

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    
                }
                // if binary file
                else if (binaryFile != NULL) {
                    // check where we seek from
                    if (_seekFrom != -1) {
                        // check for invalid arguments.
                        // lock
                        lock.lock();
                        if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
                            // seek to the new position relative to _seekFrom
                            fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

                            // set the output to the new current position
                            fpos_t pos;
                            fgetpos(binaryFile, &pos);
                            _outCurrPos = static_cast<unsigned int>(pos);

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    else { // seek from the current position
                        // check for invalid arguments
                        // lock
                        lock.lock();
                        fpos_t pos;
                        fgetpos(binaryFile, &pos);
                        if (0 <= static_cast<unsigned int>(pos) + _amount && static_cast<unsigned int>(pos) + _amount < fileSize) {
                            // seek to the new position relative to the current position
                            fseek(binaryFile, _amount, SEEK_CUR);

                            // set the output to the new current position
                            fgetpos(binaryFile, &pos);
                            _outCurrPos = static_cast<unsigned int>(pos);

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                }
                else return GReturn::FILE_NOT_FOUND;
            };

            GReturn Init()  //The init function for this class in order to initialize variables.
            {
                //Set the current working directory to the directory the program was ran from.
            #if TARGET_OS_IOS || TARGET_OS_SIMULATOR
                string tempDir = getenv("HOME");
                tempDir += "/Library";
                GW::GReturn rv = SetCurrentWorkingDirectory(tempDir.c_str());
                if (G_FAIL(rv))
                    return rv;
            #else
                GW::GReturn rv = SetCurrentWorkingDirectory("./");
                if (G_FAIL(rv))
                    return rv;
            #endif

                return GW::GReturn::SUCCESS;
            };
            
            GReturn Create()
            {
                if (G_FAIL(this->Init()))
                {
                    return GW::GReturn::FAILURE;
                }
                GetCurrentWorkingDirectory(initialDir, 250);
                return GW::GReturn::SUCCESS;
            };
        };
    }//end namespace I
}//end namespace GW

#undef DIR_SEPERATOR


#elif defined(__linux__)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
#include <stdio.h>


#include <sys/stat.h>  //File stats.
#include <string.h>
#include <cstring>

#ifndef DIR_SEPERATOR
#define DIR_SEPERATOR '/'
#endif




namespace GW
{
	namespace I
	{
		class GFileImplementation : public virtual GW::I::GFileInterface,
			protected GThreadSharedImplementation
		{
		private:
			DIR* currDirStream;  //Maintains the current directory.
			std::fstream file;  //Maintains the current file (if one is open).
			FILE* binaryFile = NULL; //for binary read and write
			std::string currDir;  //A cached directory path for faster fetching.
            char initialDir[250];
			std::atomic<unsigned int> mode; //Used to track what open mode the file is in
			std::mutex lock; //Read/Write lock.
			unsigned int fileSize = 0;

		public:
			GFileImplementation()
			{
				currDirStream = nullptr;
			}
			
			~GFileImplementation()
			{
				SetCurrentWorkingDirectory(initialDir);
				//Close the current directory.
				closedir(currDirStream);
				//Close the file stream.
				CloseFile();
			}
			
			GReturn Create()
			{
				//Set the current working directory to the directory the program was ran from.
		#if TARGET_OS_IOS || TARGET_OS_SIMULATOR
			std::string tempDir = getenv("HOME");
			tempDir += "/Library";
			GReturn rv = SetCurrentWorkingDirectory(tempDir.c_str());
			if (G_FAIL(rv))
				return rv;
		#else
			GReturn rv = SetCurrentWorkingDirectory("./");
			if (G_FAIL(rv))
				return rv;
		#endif
			
			GetCurrentWorkingDirectory(initialDir, 250);
			return GReturn::SUCCESS;
			}

			GReturn OpenBinaryRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is not already open.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file in the currentWorkingDirectory.
				file.open(currDir + G_TO_UTF16(_file), std::ios::in | std::ios::binary);
				
				//If the file failed to open the function fails.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//If the file is currently open we fail.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::binary);
				
				//If file failed to open we fail.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn AppendBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::binary | std::ios::app | std::ios::ate);
				
				//If file failed to open we fail.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenTextRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::in);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn AppendTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::app | std::ios::ate);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr || _numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Lock the write operations.
				lock.lock();
				
				file.write(_inData, _numBytes);
				
				// update the file size
				fileSize += _numBytes;
				
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override
			{
				if (_numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
				{
					_outData = nullptr;
					return GReturn::FAILURE;
				}

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//Lock the read operations.
				lock.lock();
				file.read(_outData, _numBytes);
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn WriteLine(const char* const _inData) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Transfer the data to a string. #defines make it so the
				//string is what we need it to be on any system we support.
				std::string writeOutString = G_TO_UTF16(_inData);

				//Lock the write operations.
				lock.lock();
				
				file << writeOutString;
				
				// update the file size
				fileSize += static_cast<unsigned int>(writeOutString.length());
				
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
			{
				if (_outData == nullptr || _outDataSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//The string to be read into.
				std::string outString;

				//Lock the read operations.
				lock.lock();
				
				//Just read in data normally.
				std::getline(file, outString, _delimiter);
				
				//Copy the data over to the out parameter.
				INTERNAL::strcpy_s(_outData, _outDataSize, G_TO_UTF8(outString).c_str());
				
				lock.unlock();
				
				return GReturn::SUCCESS;
			}

			GReturn CloseFile() override
			{
				//If a file is not open, we can not close it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
					fclose(binaryFile);
					binaryFile = nullptr;
				}
				else
				{
					//Flush the file.
					file.flush();
					//Close the file.
					file.close();
				}
				
				// update the file size
				fileSize = 0;
				
				return GReturn::SUCCESS;
			}

			GReturn FlushFile() override
			{
				//If a file is not open we can not flush it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
				}
				else
				{
					//flush the file.
					file.flush();
				}
				return GReturn::SUCCESS;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override
			{
				//Check for valid arguments.
				if (_dir == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Get the absolute path.
				char buffer[PATH_MAX];
				if (realpath(_dir, buffer) == nullptr)
					return GReturn::FAILURE;

				//Ensure the directory exists.
				struct stat s;
				if (stat(buffer, &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Assign the passed in directory to our internal directory storage.
				currDir = buffer;
				currDir += DIR_SEPERATOR;

				//If there is an open directory, close it.
				if (currDirStream != nullptr)
					closedir(currDirStream);

				//Open new directory.
				currDirStream = opendir(currDir.c_str());

				//Check to ensure directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
			{
				//Check for valid arguments.
				if (_dir == nullptr || _dirSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Check that a directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				INTERNAL::strcpy_s(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
				return GReturn::SUCCESS;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* file;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the dir size.
				_outSize = 0;

				//Get the number of files in directory.
				while ((file = readdir(currDirStream)))
				{
					if (file->d_type == DT_REG)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				
				return GReturn::SUCCESS;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* subDir;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the sub-dir size.
				_outSize = 0;

				while ((subDir = readdir(currDirStream)))
				{
					if (strcmp(subDir->d_name, ".\0") == 0 ||
						strcmp(subDir->d_name, "..\0") == 0)
						continue;

					if (subDir->d_type == DT_DIR)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GW::GReturn::FAILURE;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* file;
				unsigned int fileIndex = 0;
				while ((file = readdir(currDirStream)) && fileIndex < _numFiles)
				{
					if (file->d_type == DT_REG)
					{
						std::string fileName(file->d_name);
						INTERNAL::strcpy_s(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
						++fileIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;
					
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* subDir;
				unsigned int subDirIndex = 0;
				
				while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
				{

					if (strcmp(subDir->d_name, ".\0") == 0 ||
						strcmp(subDir->d_name, "..\0") == 0)
						continue;

					if (subDir->d_type == DT_DIR)
					{
						std::string subDirName(subDir->d_name);
						INTERNAL::strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
						++subDirIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
			{
				//Make a full path to the file.
				std::string filePath = currDir;
				filePath += G_TO_UTF16(_file);

				struct stat s;
				if (stat(filePath.c_str(), &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Copy the file size to the out parameter.
				_outSize = (unsigned int)s.st_size;

				return GReturn::SUCCESS;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
				// if text file
				if (file.is_open()) {
					// if not seeking from the current position
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
							file.seekg(offset, std::ios_base::beg);
							
							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					else { // seeking from the current position
						// check for invalid arguments
						// lock
						lock.lock();

						unsigned int pos = static_cast<unsigned int>(file.tellg());
						if (0 <= pos + _amount && pos + _amount < fileSize) {
							// seek to the new position relative to the current position
							file.seekg(_amount, std::ios_base::cur);

							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					
				} 
				// if binary file
				else if (binaryFile != NULL) {
					// check where we seek from
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

							// set the output to the new current position
							fpos_t pos;
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos.__pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					} 
					else { // seek from the current position
						// check for invalid arguments
						// lock
						lock.lock();
						fpos_t pos;
						fgetpos(binaryFile, &pos);
						if (0 <= static_cast<unsigned int>(pos.__pos) + _amount && static_cast<unsigned int>(pos.__pos) + _amount < fileSize) {
							// seek to the new position relative to the current position
							fseek(binaryFile, _amount, SEEK_CUR);

							// set the output to the new current position
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos.__pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
				} 
				else return GReturn::FILE_NOT_FOUND;
			}
		};
	}//end namespace I
}//end namespace GW

#undef DIR_SEPERATOR


#elif defined(_WIN32)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
#include <stdio.h>

#include <io.h>  //Included for mode change.
#include <fcntl.h>  //Included for mode change.



#ifndef DIR
#define DIR _WDIR
#endif
#ifndef dirent
#define dirent _wdirent
#endif
#ifndef fstream
#define fstream wfstream
#endif
#ifndef string
#define string wstring
#endif

#ifndef opendir
#define opendir _wopendir
#endif
#ifndef readdir
#define readdir _wreaddir
#endif
#ifndef closedir
#define closedir _wclosedir
#endif
#ifndef rewinddir
#define rewinddir _wrewinddir
#endif

#ifndef DIR_SEPERATOR
#define DIR_SEPERATOR L'\\'
#endif

namespace GW
{
	namespace I
	{
		class GFileImplementation : public virtual GW::I::GFileInterface,
			protected GThreadSharedImplementation
		{
		private:
			DIR* currDirStream;  //Maintains the current directory.
			std::fstream file;  //Maintains the current file (if one is open).
			FILE* binaryFile = NULL; //for binary read and write
			char initialDir[250] = "";
			errno_t err;// for checking file opened in secure way

			unsigned int fileSize = 0;

			std::string currDir;  //A cached directory path for faster fetching.

			std::atomic<unsigned int> mode; //Used to track what open mode the file is in
			std::mutex lock; //Read/Write lock.
		public:
			GFileImplementation()
			{
				err = 0;
				currDirStream = nullptr;
			}
			~GFileImplementation()
			{
				SetCurrentWorkingDirectory(initialDir);
				//Close the current directory.
				closedir(currDirStream);
				//Close the file stream.
				CloseFile();
			}

			GReturn Create()
			{
				//Set the current working directory to the directory the program was ran from.
				GReturn rv = SetCurrentWorkingDirectory("./");
				if (G_FAIL(rv))
					return rv;

				GetCurrentWorkingDirectory(initialDir, 250);

				//Create a UTF8 Locale to imbue the fstream with.
				std::locale utf8Locale(std::locale(), new std::codecvt_utf8<wchar_t>);

				//Imbue the fstream.
				utf8Locale = file.imbue(utf8Locale);

				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary reading mode
				if ((err = fopen_s(&binaryFile, tempDir, "rb")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to read
				mode = std::ios::in;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary writing mode
				if ((err = fopen_s(&binaryFile, tempDir, "wb")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn AppendBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary appending mode
				if ((err = fopen_s(&binaryFile, tempDir, "ab")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenTextRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::in);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::out);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn AppendTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::out | std::ios::app | std::ios::ate);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr || _numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Lock the write operations.
				lock.lock();

				//On windows we need to cast the char* to a wchar_t*.
				if (binaryFile)
				{
					fwrite((void*)_inData, sizeof(char), _numBytes, binaryFile);
				}
				else
					file.write((wchar_t*)_inData, _numBytes);

				// update the file size
				fileSize += _numBytes;

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override
			{
				if (_numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
				{
					_outData = nullptr;
					return GReturn::FAILURE;
				}

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//Lock the read operations.
				lock.lock();

				if (binaryFile)
				{
					//setting the buffer size(2nd parameter) be as big as reading data size(_numBytes)
					fread_s(_outData, _numBytes, sizeof(char), _numBytes, binaryFile);
				}
				else
				{
					// this is only a problem on win32
					if ((_numBytes % 2) == 1) { // check for odd number of bytes to read because utf-16
						char tmp[2];
						//On Windows we need to cast the _outData char* to a wchar_t*.
						file.read((wchar_t*)_outData, _numBytes - 1); // read 1 less bytes into the buffer directly
						file.read((wchar_t*)tmp, 1); // read the last byte into the tmp
						_outData[_numBytes - 1] = tmp[0]; // assign the last byte
					} else {
						file.read((wchar_t*)_outData, _numBytes);
					}
				}

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn WriteLine(const char* const _inData) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Transfer the data to a string. #defines make it so the
				//string is what we need it to be on any system we support.
				std::string writeOutString = INTERNAL::G_TO_UTF16(_inData);

				//Lock the write operations.
				lock.lock();

				//Write out the string.
				file << writeOutString;

				// update the file size
				fileSize += static_cast<unsigned int>(writeOutString.length());

				lock.unlock();
				
				return GReturn::SUCCESS;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
			{
				if (_outData == nullptr || _outDataSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//The string to be read into.
				std::string outString;

				//Lock the read operations.
				lock.lock();

				//Convert the UTF8 delimeter to UTF16.
				const wchar_t delimiter = *INTERNAL::G_TO_UTF16(_delimiter).c_str();

				//Read the information.
				std::getline(file, outString, delimiter);

				//Copy the data over to the out parameter.
				strncpy_s(_outData, _outDataSize, INTERNAL::G_TO_UTF8(outString).c_str(), _TRUNCATE);

				//Copy the data over to the out parameter.
				strcpy_s(_outData, _outDataSize, INTERNAL::G_TO_UTF8(outString).c_str());

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn CloseFile() override
			{
				//If a file is not open, we can not close it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
					fclose(binaryFile);
					binaryFile = nullptr;
				}
				else
				{
					//Flush the file.
					file.flush();
					//Close the file.
					file.close();
				}

				// update the file size
				fileSize = 0;

				return GReturn::SUCCESS;
			}

			GReturn FlushFile() override
			{
				//If a file is not open we can not flush it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
					fflush(binaryFile);
				else
				{
					//flush the file.
					file.flush();
				}

				return GReturn::SUCCESS;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override
			{
				//Check for valid arguments.
				if (_dir == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Get the absolute path.
				wchar_t buffer[MAX_PATH];
				if (_wfullpath(buffer, INTERNAL::G_TO_UTF16(_dir).c_str(), MAX_PATH) == nullptr)
					return GReturn::FAILURE;

				//Check to make sure the directory exists.
				struct _stat s;
				if (_wstat(buffer, &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Assign the passed in directory to our internal directory storage.
				currDir = buffer;
				currDir += DIR_SEPERATOR;

				//If there is an open directory, close it.
				if (currDirStream != nullptr)
					closedir(currDirStream);

				//Open new directory.
				currDirStream = opendir(currDir.c_str());

				//Check to ensure directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
			{
				//Check for valid arguments.
				if (_dir == nullptr || _dirSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Check that a directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Copy the current directory to the out parameter.
				strcpy_s(_dir, _dirSize, INTERNAL::G_TO_UTF8(currDir).c_str());
				return GReturn::SUCCESS;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* currFile;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the dir size.
				_outSize = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;

				//Get the number of files in directory.
				while ((currFile = readdir(currDirStream)))
				{
					if (currFile->d_type == DT_REG)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* subDir;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the sub-dir size.
				_outSize = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;

				while ((subDir = readdir(currDirStream)))
				{
					if (subDir->d_type == DT_DIR)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* currFile;
				unsigned int fileIndex = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;

				while ((currFile = readdir(currDirStream)) && fileIndex < _numFiles)
				{
					if (currFile->d_type == DT_REG)
					{
						std::string fileName(currFile->d_name);
						strcpy_s(_outFiles[fileIndex], _fileNameSize, INTERNAL::G_TO_UTF8(fileName).c_str());
						++fileIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[])
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* subDir;
				unsigned int subDirIndex = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;

				while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
				{
					if (subDir->d_type == DT_DIR)
					{
						std::string subDirName(subDir->d_name);
						strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, INTERNAL::G_TO_UTF8(subDirName).c_str());
						++subDirIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
			{
				//Make a full path to the file.
				std::string filePath = currDir;
				filePath += INTERNAL::G_TO_UTF16(_file);

				//Other than the UTF8 to UTF16 conversion for the windows calls,
				//this is handled the same for each platform.
				//We call stat() and it fills in the passed in function
				//with the stats of the passed in path.
				struct _stat s;
				if (_wstat(filePath.c_str(), &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Copy the file size to the out parameter.
				_outSize = s.st_size;

				return GReturn::SUCCESS;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override
			{
				// if text file
				if (file.is_open()) {
					// if not seeking from the current position
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
							file.seekg(offset, std::ios_base::beg);
							
							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					else { // seeking from the current position
						// check for invalid arguments
						// lock
						lock.lock();
						unsigned int pos = static_cast<unsigned int>(file.tellg());
						if (0 <= pos + _amount && pos + _amount < fileSize) {
							// seek to the new position relative to the current position
							file.seekg(_amount, std::ios_base::cur);

							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					
				} 
				// if binary file
				else if (binaryFile != NULL) {
					// check where we seek from
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

							// set the output to the new current position
							fpos_t pos;
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<int>(pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					} 
					else { // seek from the current position
						// check for invalid arguments
						// lock
						lock.lock();

						fpos_t pos;
						fgetpos(binaryFile, &pos);
						if (0 <= static_cast<unsigned int>(pos) + _amount && static_cast<unsigned int>(pos) + _amount < fileSize) {
							// seek to the new position relative to the current position
							fseek(binaryFile, _amount, SEEK_CUR);

							// set the output to the new current position
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
				} 
				else return GReturn::FILE_NOT_FOUND;
			}

			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	} // end namespace I
} // end namespace GW

#undef DIR_SEPERATOR
#undef DIR
#undef dirent
#undef fstream
#undef string

#undef opendir
#undef readdir
#undef closedir
#undef rewinddir

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GFile final 
			: public I::GProxy<I::GFileInterface, I::GFileImplementation>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GFile)
			GATEWARE_FUNCTION(OpenBinaryRead)
			GATEWARE_FUNCTION(OpenBinaryWrite)
			GATEWARE_FUNCTION(AppendBinaryWrite)
			GATEWARE_FUNCTION(OpenTextRead)
			GATEWARE_FUNCTION(OpenTextWrite)
			GATEWARE_FUNCTION(AppendTextWrite)
			GATEWARE_FUNCTION(Write)
			GATEWARE_FUNCTION(Read)
			GATEWARE_FUNCTION(WriteLine)
			GATEWARE_FUNCTION(ReadLine)
			GATEWARE_FUNCTION(CloseFile)
			GATEWARE_FUNCTION(FlushFile)
			GATEWARE_FUNCTION(SetCurrentWorkingDirectory)
			GATEWARE_FUNCTION(GetCurrentWorkingDirectory)
			GATEWARE_FUNCTION(GetDirectorySize)
			GATEWARE_FUNCTION(GetSubDirectorySize)
			GATEWARE_FUNCTION(GetFilesFromDirectory)
			GATEWARE_FUNCTION(GetFoldersFromDirectory)
			GATEWARE_FUNCTION(GetFileSize)
			GATEWARE_FUNCTION(Seek)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GFILE_H

/*---------------------------------
|	End of GFile.h
----------------------------------*/


/*---------------------------------
|	Begin of GDaemon.h
----------------------------------*/
#ifndef GDAEMON_H
#define GDAEMON_H




namespace GW
{
	namespace I
	{
		class GDaemonInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				OPERATION_COMPLETED,
				OPERATIONS_PAUSED,
				OPERATIONS_RESUMING
			};

			struct EVENT_DATA
			{
				unsigned long long operationCount;
			};

			virtual GReturn Pause(bool _wait, unsigned int _spinUntil) = 0;
			virtual GReturn Resume() = 0;
			virtual GReturn Counter(unsigned long long& _outCounter) const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GDaemon.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GDAEMON) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GDAEMON) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GDaemon
namespace GW {
	namespace I {
		class GDaemonImplementation :	public virtual GDaemonInterface,
										public GEventGeneratorImplementation
		{
		public:
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(unsigned int _targetInterval, 
				std::function<void()> _daemonOperation, unsigned int _delayOrPause) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(CORE::GLogic _daemonLogic, 
				unsigned int _targetInterval, unsigned int _delayOrPause) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Pause(bool _wait, unsigned int _spinUntil) override {
				return GReturn::FAILURE;
			}
			GReturn Resume() override {
				return GReturn::FAILURE;
			}
			GReturn Counter(unsigned long long& _outCounter) const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Link to our internal thread pool
#ifndef GW_INTERNAL_THREADPOOL
#define GW_INTERNAL_THREADPOOL

 // current implementation used for threadpools


// where Gateware keeps it's "invisible" global variables, do not modify outside of Gateware implementations
namespace internal_gw // DEVS: Only allowed on approval, favor static class members if a global is required.
{
	// for variables to be truly global across translation units they must be static WITHIN a function or class.
	// This allows us to avoid using extern and requiring definition in a user translation unit.
	static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE>& GatewareThreadPool() // avoids a name colission in other units
	{
		// internally this ThreadPool has been adapted to use std::thread::hardware_concurrency() threads 
		static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE> gatewareThreadPool;
		return gatewareThreadPool; // the only one we have, static inside the function ensure it is the same
	}
}

#endif 



#include <vector>
#include <chrono>

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I { // Going to switch to using containment for GEventGenerator (safer)
		class GDaemonImplementation : public virtual GDaemonInterface
		{
            // GDaemonImplementation HAS A GEventGenerator.
            // This will be safer than private Inheritance when we need to pass the generator around.
            CORE::GEventGenerator generator;
            // defines what a daemon actually is
			typedef std::tuple<std::chrono::time_point<std::chrono::steady_clock>,
				unsigned long long, CORE::GEventReceiver> Daemon;
			// Global daemon managment variables, intialized below the class
			// responsible for creating and joining/stopping the daemon visitor
			class GDaemonManager {
			public:
				// Used to control access to the internal global daemon resources, must also be global
				CORE::GThreadShared g_daemonAccess;
				// Allows external insertion into the daemon list (prevents blocking)
				std::vector<Daemon> g_insertionStack; // order not critical so we favor cache perf
				// This just exists to allow GEventReceivers to exist
				CORE::GEventGenerator g_daemonNotifier;
				// Used to enable more advanced and careful sleeping in the manager thread
				std::condition_variable g_managerNotifier;
				// launches daemon thread
				GDaemonManager() {
					g_daemonAccess.Create();
					g_daemonNotifier.Create();
					g_daemonVisitor = std::thread(&GDaemonManager::processWaitingDaemons, this);
				}
				// frees daemon thread
				~GDaemonManager() {
					// were done now, this will signal thread to exit
					g_daemonNotifier = nullptr;
					if (g_daemonVisitor.joinable())
					{
						// its time to go... WAKE UP!!!
						g_managerNotifier.notify_one();
						g_daemonVisitor.join();
					}
					g_daemonAccess = nullptr;
				}
			private:
				// Global list of all daemons, traversed by worker thread adding them to the thread pool as needed. 
				std::vector<Daemon> g_daemons; // stores all daemons
				// Global worker thread not part of the main thread pool but responsible for adding to it.
				// Having g_daemonVisitor and GDaemonManager allows for safe termination of the Daemons with the
				// added benefit of being able to debug the end of the system. Without this, daemons would
				// have to be detached and There wouldn't be a guaranteed way to allow the thread to exit 
				// normally at the end of main.
				std::thread g_daemonVisitor;
				// routine that manages the daemon set until the last has finshed (defined below)
				void processWaitingDaemons()
				{
					std::mutex sleeper; // used only for more controlled naps with std::condition_variable 
					// local function to update thread sleep time as needed
					auto updateNextWake = [](const std::chrono::time_point<std::chrono::steady_clock> upnext,
						std::chrono::time_point<std::chrono::steady_clock>& nextwake, bool& allow)
					{
						if (allow) // can only be updated once by the youngest
						{
							// we shorten the sleep time by potential spin time to better ensure launch
							nextwake = upnext - std::chrono::microseconds(G_DAEMON_LAUNCH_THRESHOLD);
							allow = false; // no more changes allowed, stay young
						}
					};
					do // loop until the program ends
					{
						bool allow_adj = true; // has the wake time been adjusted yet? (only allow once per loop)
						// grab the original time at loop start
						std::chrono::time_point<std::chrono::steady_clock> origin = std::chrono::steady_clock::now();
						// by default the next cycle is at "G_THREAD_DEFAULT_SLEEP" from now.
						// however if there are unlaunched items in the list below we sleep till right before the next up. 
						// Var used to record the youngest item that is not going to be launched this cycle.
						std::chrono::time_point<std::chrono::steady_clock> nextwake =
							origin + std::chrono::microseconds(G_THREAD_DEFAULT_SLEEP);
						// lock the daemon array, sort it, traverse it, unlock it.
						if (+g_daemonAccess.LockSyncWrite())
						{
							// transfer any waiting Daemons into the main list. (staging)
							while (g_insertionStack.empty() == false)
							{
								g_daemons.push_back(g_insertionStack.back());
								g_insertionStack.pop_back();
							}
							// once we have inserted any waiting Daemons into the list we unlock to not cause stalls 
							g_daemonAccess.UnlockSyncWrite();

							//num_daemons = g_daemons.size(); // how many do we have now?
							std::sort(g_daemons.begin(), g_daemons.end(), sortWaitingDaemons);
							for (auto i = g_daemons.begin(); i != g_daemons.end(); ) // iteration is contolled inside
							{
								// grab the exact time at loop start
								std::chrono::time_point<std::chrono::steady_clock> exact = std::chrono::steady_clock::now();
								// if the GEventGenerator(GDaemon) is dead remove it from the list. 
								if (std::get<2>(*i) == nullptr)
								{
									i = g_daemons.erase(i); // get rid of this one and move to the next
								}
								// launch any valid daemons who are past time.
								else if (std::get<0>(*i) <= exact)
								{
									// deltaLag describes how far behind the daemon is.
									// numPeriods is how many periods have been missed in that time(deltaLag).
									// So, if this daemon is in the past after 1 period increase, 
									// set it's timer for the period it 'should' be at.
									// (currentTime += numOfMissedPeriods * periodLength)
									// This method is to prevent a "rubber-banding" sort of behavior.
									unsigned long long deltaLag = 
										std::chrono::duration_cast<std::chrono::milliseconds>(exact - std::get<0>(*i)).count();
									unsigned long long numPeriods = deltaLag / std::get<1>(*i);
									if ((std::get<0>(*i) + std::chrono::milliseconds(std::get<1>(*i))) < exact)
										std::get<0>(*i) += std::chrono::milliseconds(numPeriods * std::get<1>(*i));
									// before we launch we set the time to the next time step. (add time)
									std::get<0>(*i) += std::chrono::milliseconds(std::get<1>(*i));
									// update the wake cycle as needed
									updateNextWake(std::get<0>(*i), nextwake, allow_adj);
									// weak handle to GEventReceiver which we will invoke
									auto caller = std::get<2>(*i);
									// add to threadpool, invoke Daemon routine
									internal_gw::GatewareThreadPool().AddJob([caller]() {
										// should be safe and not cause oddness
										caller.Invoke();
									});
									// move to the next item and continue traversal
									++i; // see if anyone else needs to be launched
								}
								else // if we get here we know the current Daemon is in the future
								{
									// how much time till this must launch?
									unsigned long long microleft =
										std::chrono::duration_cast<std::chrono::microseconds>(exact - std::get<0>(*i)).count();
									// if a daemon is less than G_DAEMON_LAUNCH_THRESHOLD microseconds from starting we spinlock.
									if (microleft <= G_DAEMON_LAUNCH_THRESHOLD)
									{
										while (std::chrono::steady_clock::now() < std::get<0>(*i))
											std::this_thread::yield(); // spin lock and restart loop to launch
									}
									else // not time for this one yet, we move on
									{
										// update the wake cycle as needed
										updateNextWake(std::get<0>(*i), nextwake, allow_adj);
										++i;
									}
								}
							}
						}
						// once we exit the loop we have this thread take a short nap.
						// we wait for the default thread sleep time: G_THREAD_DEFAULT_SLEEP (typically 16ms)
						// reduce by the launch threshold so we have a better possibility of launching on time
						// if possible we wait for the next launching time span.
						// If a new daemon is added or a destructor is invoked we will be notified while sleeping.
						// The suprious wakeup will wake the thread no matter what since it is always safe to do so.
						{
							std::unique_lock<std::mutex> locker(sleeper);
							g_managerNotifier.wait_until(locker, nextwake, [&]() { return true; });
							///std::this_thread::sleep_until(nextwake); // how we used to do it
						}
					// The loop ends when g_daemonNotifier is destructed	
					} while (g_daemonNotifier);
				}
			};
			//static GDaemonManager g_daemonManager;
			static GDaemonManager& GetDaemonManager()
			{
				static GDaemonManager g_daemonManager;
				return g_daemonManager;
			}
			static bool sortWaitingDaemons(const GDaemonImplementation::Daemon& _a,
				const GDaemonImplementation::Daemon& _b)
			{
				return std::get<0>(_a) < std::get<0>(_b); // compare time points
			}
			// daemons are sorted by when they must next run in accending order (oldest first)
			
			// * End Globals, start local variables *

			// used to pause execution of this daemon (disabled during Initialization)
			std::atomic_bool paused = { true };
			// flag that controls pauseing and resuming of a daemon
			std::atomic_flag running = ATOMIC_FLAG_INIT;
			// keeps track of the current thread running our daemon to avoid possible deadlock
			std::atomic<std::thread::id> runner; // deafault constructor is a non-thread
			// the amount of time (milliseconds) between execution events
			unsigned int period = 0;
			// tracks the number of complete executions of the daemon
			std::atomic_uint64_t count;
			// caches a copy of the routine to be applied at the interval
			CORE::GEventReceiver daemon;
		public:
			// required for HAS-A relationship
			GReturn Register(CORE::GEventCache _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return generator.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return generator.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return generator.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return generator.Push(_newEvent);
			}
			// actual implementation functions here
			// alternative create, allows user to start the daemon paused
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation, unsigned int _delay)
			{
				if (_targetInterval == 0) // daemons can't run faster than 1000hz
					return GReturn::INVALID_ARGUMENT;
				// If a _delay was supplied we need to unpause this daemon immediately (otherwise start paused)
				if (_delay > 0)
					paused = false; // intialized to true by default (for simplified init reasons)
                // make an internal event generator to implement that functionality
                // this may not be as efficient as private inheritance but allows for
                // safe message sending if the _daemonOperation is used to delete/replace this proxy
                generator.Create();
				period = _targetInterval; // fixed time step between daemon invocations
				count = 0; // nothing has been excecuted yet
				// create daemon here
				daemon.Create(GetDaemonManager().g_daemonNotifier, [&, _daemonOperation]() {
					// This is called wether we are ready or not.
					// Only run code if we are not already running
					if (std::atomic_flag_test_and_set_explicit(&running, std::memory_order_acquire) == false)
					{
						if (paused == false) // only execute when not paused
						{
							GEvent send; // event package
							runner = std::this_thread::get_id(); // avoid deadlocks
                            // this operation could technically erase this class so save a safe handle
                            CORE::GEventGenerator safe = generator;
                            if (_daemonOperation) // these are optional so we need to check
								_daemonOperation(); // we assume this MAY delete "this"
							// increase count, notify listeners and unlock spin if still possible
							CORE::GEventGenerator::burst_w alive = *safe;
							if (alive)
							{	// notify anyone listening we have completed
								unsigned long long c = ++count; // increase & copy count to POD
								send.Write(Events::OPERATION_COMPLETED, c); // send current count
								alive->Push(send); // a daemon run is not done till eveyone has received it
								std::atomic_flag_clear_explicit(&running, std::memory_order_release);
							}
						}
						else // allow execution again
							std::atomic_flag_clear_explicit(&running, std::memory_order_release);
					}
					// done
				});
				// add ourselves to the vector
				// insert our daemon into the global list for processing
				GetDaemonManager().g_daemonAccess.LockSyncWrite();
				// insert relevant data to begin processing
				GetDaemonManager().g_insertionStack.push_back(
					{	std::chrono::steady_clock::now() + std::chrono::milliseconds(_delay),
						static_cast<unsigned long long>(period), daemon });
				GetDaemonManager().g_daemonAccess.UnlockSyncWrite();
				// wakeup the manager thread if it is snoozing
				GetDaemonManager().g_managerNotifier.notify_one();
				// were done here, the daemon processor will takeover.
				return GReturn::SUCCESS;
			}
			// main create, starts the daemon immediately unpaused
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation)
			{
				paused = false; // start running right away! (true by default)
				return Create(_targetInterval, _daemonOperation, 0);
			}
			// alternate create, provide swappable logic
			GReturn Create(CORE::GLogic _daemonLogic, unsigned int _targetInterval, unsigned int _delayOrPause)
			{
				if (_daemonLogic == nullptr) return GReturn::INVALID_ARGUMENT;
				return Create(_targetInterval, [_daemonLogic]() { _daemonLogic.Invoke(); }, _delayOrPause);
			}
			GReturn Pause(bool _wait, unsigned int _spinUntil) override
			{
				if (paused == true) // no need to do this twice
					return GReturn::REDUNDANT;
				// inform the external threads to no longer execute our daemon
				paused = true;
				// if _wait == true we use the spin lock technique from GConcurrent
				if (_wait)
				{
					// are we inside the daemon thread?
					if (runner == std::this_thread::get_id())
					{
						paused = false; // didn't work so don't change the behavior
						return GReturn::DEADLOCK; // This would cause a deadlock!
					}
					// waits until "working" is false, sleeping the thread for 1ms each time _spinUntil is reached.
					auto last = std::chrono::steady_clock::now();
					// This operation is lock free, so very optimized for short wait times
					while (std::atomic_flag_test_and_set_explicit(&running, std::memory_order_acquire))
					{	// measures how much time this thread is spin locked
						if (std::chrono::duration_cast<std::chrono::nanoseconds>(
							std::chrono::steady_clock::now() - last).count() >= _spinUntil)
						{
							// if things take longer than our maximum lock time we free the thread and try again later
							std::this_thread::sleep_for(std::chrono::microseconds(G_THREAD_DEFAULT_SLEEP));
							last = std::chrono::steady_clock::now();
						}
					}
					// Once we have converged we release our lock so we can lock again later.
					std::atomic_flag_clear_explicit(&running, std::memory_order_release);
				}
				// notify anyone listening a pause has been requested.
				GEvent send;
				unsigned long long c = count;
				send.Write(Events::OPERATIONS_PAUSED, c);
				Push(send); // let everyone know who cares
				// so far so good
				return GReturn::SUCCESS;
			}
			GReturn Resume() override
			{
				if (paused == false) // no need to do this twice
					return GReturn::REDUNDANT;
				// since we don't wait in this function, checking for deadlocks is not required
				paused = false;
				// notify anyone listening a resume has been requested.
				GEvent send;
				unsigned long long c = count;
				send.Write(Events::OPERATIONS_RESUMING, c);
				Push(send); // let everyone know who cares
				return GReturn::SUCCESS;
			}
			GReturn Counter(unsigned long long& _outCounter) const override
			{
				_outCounter = count; // this can't really fail
				return GReturn::SUCCESS;
			}
			// destructor ensures no waiting jobs exist
			~GDaemonImplementation()
			{
				// wakeup the manager thread if it is snoozing
				GetDaemonManager().g_managerNotifier.notify_one();
				// ensure we do not run any more daemon code
				Pause(true, 0);
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace SYSTEM
	{
		class GDaemon final
			: public I::GProxy<I::GDaemonInterface, I::GDaemonImplementation, unsigned int, std::function<void()>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDaemon)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_CONST_FUNCTION(Counter)
				
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDAEMON_H

/*---------------------------------
|	End of GDaemon.h
----------------------------------*/


/*---------------------------------
|	Begin of GConcurrent.h
----------------------------------*/
#ifndef GCONCURRENT_H
#define GCONCURRENT_H




namespace GW
{
	namespace I
	{
		class GConcurrentInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				SINGULAR_TASK_COMPLETE,
				PARALLEL_TASK_COMPLETE,
				PARALLEL_SECTION_COMPLETE
			};

			struct EVENT_DATA
			{
				unsigned long long taskSubmissionIndex;
				unsigned long long microsecondsElapsed;
				unsigned int completionRange[2];
			};

			virtual GReturn BranchSingular(std::function<void()> _singleTask) = 0;
			virtual GReturn BranchDynamic(CORE::GLogic _dynamicTask) = 0;
			template<typename Data>
			GReturn BranchParallel(	void(*_parallelTask)(Data&), unsigned int _arraySize, Data* _outDataArray);
			template<typename Input, typename Output>
			GReturn BranchParallel(	void(*_parallelTask)(const Input*,Output*,unsigned int,const void*), unsigned int _maxSection, unsigned int _arraySize, const void* _userData, int _inStride, const Input* _inputArray, int _outStride, Output* _outputArray);
			virtual GReturn Converge(unsigned int _spinUntil) = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GConcurrent.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GCONCURRENT) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GCONCURRENT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GConcurrent
namespace GW {
	namespace I {
		class GConcurrentImplementation :	public virtual GConcurrentInterface,
											public GEventGeneratorImplementation
		{
		public:
			// actual dummies for this class
			GReturn Create(bool _nope) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
			GReturn BranchSingular(std::function<void()> _singleTask) override	{ 
				return GReturn::FAILURE;
			}
			GReturn BranchDynamic(CORE::GLogic _dynamicTask) override {
				return GReturn::FAILURE;
			}
			template<typename Data>
			GReturn BranchParallel(void(*_parallelTask)(Data&),
				unsigned int _arraySize, Data* _outDataArray) {
				return GReturn::FAILURE;
			}
			template<typename Input, typename Output>
			GReturn BranchParallel(void(*_parallelTask)(const Input*, Output*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const Input* _inputArray,
				int _outStride, Output* _outputArray) {
				return GReturn::FAILURE;
			}
			GReturn Converge(unsigned int _spinUntil) override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Link to our internal thread pool
#ifndef GW_INTERNAL_THREADPOOL
#define GW_INTERNAL_THREADPOOL

 // current implementation used for threadpools


// where Gateware keeps it's "invisible" global variables, do not modify outside of Gateware implementations
namespace internal_gw // DEVS: Only allowed on approval, favor static class members if a global is required.
{
	// for variables to be truly global across translation units they must be static WITHIN a function or class.
	// This allows us to avoid using extern and requiring definition in a user translation unit.
	static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE>& GatewareThreadPool() // avoids a name colission in other units
	{
		// internally this ThreadPool has been adapted to use std::thread::hardware_concurrency() threads 
		static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE> gatewareThreadPool;
		return gatewareThreadPool; // the only one we have, static inside the function ensure it is the same
	}
}

#endif 


// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GConcurrentImplementation : public virtual GConcurrentInterface
		{
			bool supressEvents = false;
			std::atomic_uint tasksProcessing;  
			std::atomic_uint64_t taskSubmissionIndex;
			// This is flag is only false when tasksProcessing == 0
			// It is used to efficiently spin-lock during a Converge operation
			std::atomic_flag working = ATOMIC_FLAG_INIT;
			// HAS A relationship allows for safe lifetime access in external threads
			CORE::GEventGenerator generator;
			// this class creates a message when it falls out of scope (uses shared_ptr)
			// solves the issue on how to notify when all parallel threads complete
			struct ScopedEvent {
				EVENT_DATA info = { 0, 0, { 0,1 } };
				CORE::GEventGenerator me; // safe even if proxied object is destructed
				std::chrono::time_point<std::chrono::steady_clock> start;
				~ScopedEvent() {
					GEvent send; // what people are listening for
					auto end = std::chrono::steady_clock::now();
					info.microsecondsElapsed = 
						std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
					if (+send.Write(Events::PARALLEL_TASK_COMPLETE, info))
						me.Push(send); // Notify anyone who is listening the Parrallel Task has completed
				}
			};
			
		public:
			// required for HAS-A relationship
			GReturn Register(CORE::GEventCache _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return generator.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return generator.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return generator.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return generator.Push(_newEvent);
			}
			// actual implementation starts here
			GReturn Create(bool _supressEvents)
			{
				supressEvents = _supressEvents;
				tasksProcessing = 0;
				taskSubmissionIndex = 0;
				return generator.Create();
			}
			GReturn BranchSingular(std::function<void()> _singleTask) override
			{
				if (_singleTask == nullptr)
					return GReturn::INVALID_ARGUMENT;
				EVENT_DATA einfo = { 0, 0, { 0,1 } };
				std::chrono::time_point<std::chrono::steady_clock> start;
				++tasksProcessing; // as soon as a task is submitted it is considered to be processing
				if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
					std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
				// send events to end users?
				if (supressEvents == false)
				{
					start = std::chrono::steady_clock::now();
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
				}
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// because "singleTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// we need to send by reference due to "tasksProcessing" being a class member.
				// The task itself & a few other items must be copied as they will fall out of scope.
				internal_gw::GatewareThreadPool().AddJob([&, _singleTask, supress, safe,
															einfo, start]() mutable {
					_singleTask(); // execute job while within the thread pool
					// send any event that still must be sent
					if (supress == false)
					{
						GEvent send; // what people are listening for
						auto end = std::chrono::steady_clock::now();
						einfo.microsecondsElapsed =
							std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
						// Notify anyone who is listening
						send.Write(Events::SINGULAR_TASK_COMPLETE, einfo);
						safe.Push(send);
					}
					// increase count, notify listeners and unlock spin if still possible
					CORE::GEventGenerator::burst_w alive = *safe;
					if (alive)
					{
						--tasksProcessing; // tasks are also considered processing until all event responders have completed
						if (tasksProcessing == 0) // disable spinlock
							std::atomic_flag_clear_explicit(&working, std::memory_order_release);
					}
				});
				return GReturn::SUCCESS;
			}
			// Due to std::function's argressive constructor we had to give this function a unique name
			GReturn BranchDynamic(CORE::GLogic _dynamicTask) override 
			{
				if (_dynamicTask == nullptr) return GReturn::INVALID_ARGUMENT;
				return BranchSingular([_dynamicTask]() { _dynamicTask.Invoke(); });
			}
			template<typename Input, typename Output>
			GReturn BranchParallel(	void(*_parallelTask)(const Input*, Output*,unsigned int,const void*), 
									unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
									int _inStride, const Input* _inputArray, int _outStride, Output* _outputArray)
			{
				// error check what is possible
				if (_parallelTask == nullptr) return GReturn::INVALID_ARGUMENT;
				if (_maxSection == 0) return GReturn::INVALID_ARGUMENT;
				if (_arraySize == 0) return GReturn::INVALID_ARGUMENT;
				// Input & Output may not be the same array. (if you need this just use Output alone!)
				if ((_inputArray || _outputArray) && 
					reinterpret_cast<std::uintptr_t>(_inputArray) == 
					reinterpret_cast<std::uintptr_t>(_outputArray))
					return GReturn::INVALID_ARGUMENT;
				// set input and output stride if not provided
				if (_inStride == 0) _inStride = sizeof(Input);
				if (_outStride == 0) _outStride = sizeof(Output);
				// check for overlapped memory if it could exist
				if (_inputArray != nullptr && _outputArray != nullptr)
				{
					std::uintptr_t input_start = reinterpret_cast<std::uintptr_t>(_inputArray);
					std::uintptr_t output_start = reinterpret_cast<std::uintptr_t>(_outputArray);
					std::uintptr_t input_end = input_start + static_cast<std::uintptr_t>(_arraySize) * _inStride;
					std::uintptr_t output_end = output_start + static_cast<std::uintptr_t>(_arraySize) * _outStride;
					if (input_start < output_start && input_end > output_start)
						return GReturn::MEMORY_CORRUPTION;
					if (output_start < input_start && output_end > input_start)
						return GReturn::MEMORY_CORRUPTION;
				}
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// When the shared object falls completely out of scope we know all threads have completed.
				std::shared_ptr<ScopedEvent> waitForDeath;
				// because "parallelTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// error checks done we compute required jobs and submitt to thread pool.
				EVENT_DATA einfo = { 0, 0, { 0,_arraySize } };
				if (supressEvents == false)
				{
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
					// allocate a ScopedEvent to handle the last message
					waitForDeath = std::make_shared<ScopedEvent>();
					waitForDeath->info = einfo;
					waitForDeath->start = std::chrono::steady_clock::now();
					waitForDeath->me = generator; // safe even if proxied object is destructed
				}
				// determine total amount of jobs to be sent
				int jobCount = ((_arraySize / _maxSection) + ((_arraySize % _maxSection) ? 1 : 0));
				// loop sending a job for each parallel task
				for (int i = 0; i < jobCount; ++i)
				{
					// as soon as a task is submitted it is considered to be processing
					++tasksProcessing;
					if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
						std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
					// include completion event info (fixed for C++11 syntax)
                    einfo.completionRange[0] = i * _maxSection;
                    einfo.completionRange[1] = (i+1) * _maxSection - 1;
					if (einfo.completionRange[1] >= _arraySize)
						einfo.completionRange[1] = _arraySize - 1u;
					// launch job, copy ScopedEvent so it does not fall out of scope until we are done.
					// The task itself & a few other items must be copied as they will fall out of scope.
					internal_gw::GatewareThreadPool().AddJob([&, _parallelTask, _inStride, _inputArray, 
																_outStride, _outputArray, _userData, 
																einfo, supress, waitForDeath, safe]() mutable {
						// used for timing individual sections to help find performance bottlenecks.
						std::chrono::time_point<std::chrono::steady_clock> start;
						if (supress == false)
							start = std::chrono::steady_clock::now();
						// traverse using byte pointers to account for unique data strides
						const unsigned char* in = reinterpret_cast<const unsigned char*>(_inputArray) + static_cast<uint64_t>(einfo.completionRange[0]) * _inStride;
						unsigned char* out = reinterpret_cast<unsigned char*>(_outputArray) + static_cast<uint64_t>(einfo.completionRange[0]) * _outStride;
						// do the actual work requested
						for (unsigned int j = einfo.completionRange[0]; j <= einfo.completionRange[1]; ++j, in += _inStride, out += _outStride)
						{
							_parallelTask(reinterpret_cast<const Input*>(in),
								reinterpret_cast<Output*>(out), j, _userData);
						}
						// if the user wants to be informed we inform them
						if (supress == false)
						{
							GEvent send; // what people are listening for
							auto end = std::chrono::steady_clock::now();
							einfo.microsecondsElapsed = // *NEW* Include timing data always
								std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
							send.Write(Events::PARALLEL_SECTION_COMPLETE, einfo);
							safe.Push(send); // Notify anyone who is listening
						}
						// manually free "waitForDeath" here so like "BranchSingular" tasksprocessing is inclusive
						// to any event responders who may be reacting to completed events.
						waitForDeath.reset(); // drop this copy (will invoke destructor if this is the last one)
						// increase count, notify listeners and unlock spin if still possible
						CORE::GEventGenerator::burst_w alive = *safe;
						if (alive)
						{
							--tasksProcessing; // tasks are considered processing until all responders have reacted
							if (tasksProcessing == 0) // disable spinlock
								std::atomic_flag_clear_explicit(&working, std::memory_order_release);
						}
					});
				}
				return GReturn::SUCCESS;
			}
			// specialization of void input type
			template<typename Output>
			GReturn BranchParallel(void(*_parallelTask)(const void*, Output*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const void* _inputArray, int _outStride, Output* _outputArray)
			{
				void(*_job)(const size_t*, Output*, unsigned int, const void*) =
					reinterpret_cast<void(*)(const size_t*, Output*, unsigned int, const void*)>(_parallelTask);
				return BranchParallel<size_t, Output>(_job, _maxSection, _arraySize, _userData, _inStride,
					static_cast<const size_t*>(_inputArray), _outStride, _outputArray);
			}
			// specialization of void output type
			template<typename Input>
			GReturn BranchParallel(void(*_parallelTask)(const Input*, void*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const Input* _inputArray, int _outStride, void* _outputArray)
			{
				void(*_job)(const Input*, size_t*, unsigned int, const void*) =
					reinterpret_cast<void(*)(const Input*, size_t*, unsigned int, const void*)>(_parallelTask);
				return BranchParallel<Input, size_t>(_parallelTask, _maxSection, _arraySize, _userData, _inStride,
					_inputArray, _outStride, static_cast<size_t*>(_outputArray));
			}
			// simplified version
			template<typename Data>
			GReturn BranchParallel(void(*_parallelTask)(Data&), unsigned int _arraySize, Data* _outDataArray) 
			{
				// error check what is possible
				if (_parallelTask == nullptr) return GReturn::INVALID_ARGUMENT;
				if (_arraySize == 0) return GReturn::INVALID_ARGUMENT;
				if (_outDataArray == nullptr) return GReturn::INVALID_ARGUMENT;
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// When the shared object falls completely out of scope we know all threads have completed.
				std::shared_ptr<ScopedEvent> waitForDeath;
				// because "parallelTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// error checks done we compute required jobs and submitt to thread pool.
				EVENT_DATA einfo = { 0, 0, { 0,_arraySize } };
				if (supressEvents == false)
				{
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
					// allocate a ScopedEvent to handle the last message
					waitForDeath = std::make_shared<ScopedEvent>();
					waitForDeath->info = einfo;
					waitForDeath->start = std::chrono::steady_clock::now();
					waitForDeath->me = generator; // safe even if proxied object is destructed
				}
				// determine total amount of jobs to be sent
				int autoSection = (sizeof(Data) * _arraySize) / G_CONCURRENT_AUTO_SECTION;// one thread per Nkb items 
				int jobCount = ((_arraySize / autoSection) + ((_arraySize % autoSection) ? 1 : 0));
				// loop sending a job for each parallel task
				for (int i = 0; i < jobCount; ++i)
				{
					// as soon as a task is submitted it is considered to be processing
					++tasksProcessing;
					if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
						std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
					// include completion event info (fixed for C++11 syntax)
					einfo.completionRange[0] = i * autoSection;
					einfo.completionRange[1] = (i + 1) * autoSection - 1;
					if (einfo.completionRange[1] >= _arraySize)
						einfo.completionRange[1] = _arraySize - 1u;
					// launch job, copy ScopedEvent so it does not fall out of scope until we are done.
					// The task itself & a few other items must be copied as they will fall out of scope.
					internal_gw::GatewareThreadPool().AddJob([&, _parallelTask, _outDataArray,
						einfo, supress, waitForDeath, safe]() mutable {
							// used for timing individual sections to help find performance bottlenecks.
							std::chrono::time_point<std::chrono::steady_clock> start;
							if (supress == false)
								start = std::chrono::steady_clock::now();
							// do the actual work requested
							for (unsigned int j = einfo.completionRange[0]; 
								j <= einfo.completionRange[1]; ++j)
							{
								_parallelTask(_outDataArray[j]);
							}
							// if the user wants to be informed we inform them
							if (supress == false)
							{
								GEvent send; // what people are listening for
								auto end = std::chrono::steady_clock::now();
								einfo.microsecondsElapsed = // *NEW* Include timing data always
									std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
								send.Write(Events::PARALLEL_SECTION_COMPLETE, einfo);
								safe.Push(send); // Notify anyone who is listening
							}
							// manually free "waitForDeath" here so like "BranchSingular" tasksprocessing is inclusive
							// to any event responders who may be reacting to completed events.
							waitForDeath.reset(); // drop this copy (will invoke destructor if this is the last one)
							// increase count, notify listeners and unlock spin if still possible
							CORE::GEventGenerator::burst_w alive = *safe;
							if (alive)
							{
								--tasksProcessing; // tasks are considered processing until all responders have reacted
								if (tasksProcessing == 0) // disable spinlock
									std::atomic_flag_clear_explicit(&working, std::memory_order_release);
							}
						});
				}
				return GReturn::SUCCESS;
			}
			GReturn Converge(unsigned int _spinUntil) override
			{
				// converge is only allowed on threads that are NOT in the thread pool
				if (internal_gw::GatewareThreadPool().Search(std::this_thread::get_id()))
					return GReturn::DEADLOCK;
				// waits until "working" is false, sleeping the thread for 1ms each time _spinUntil is reached.
				auto last = std::chrono::steady_clock::now();
				// This operation is lock free, so very optimized for short wait times
				while (std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire))
				{	// measures how much time this thread is spin locked
					if (std::chrono::duration_cast<std::chrono::nanoseconds>(
						std::chrono::steady_clock::now() - last).count() >= _spinUntil)
					{
						// if things take longer than our maximum lock time we free the thread and try again later
						last = std::chrono::steady_clock::now();
					}
				}
				// Once we have converged we release our lock so we can lock again later.
				std::atomic_flag_clear_explicit(&working, std::memory_order_release);
				
				// Basic version provided by thread pool. Uneeded now
				// internal_gw::gatewareThreadPool.WaitAll();
				return GReturn::SUCCESS;
			}
			// Ensures "ScopedEvent" stays valid until all tasks complete
			~GConcurrentImplementation()
			{
				// if you wanted to spin you should do that before you let things fall out of scope.
				// if you die within a job, ensure no deadlock.  
				if (Converge(0) == GReturn::DEADLOCK && tasksProcessing > 0) 
				{
					// If anyone may still be converging, ensure we get the last lock on "working"
					std::atomic_flag_clear_explicit(&working, std::memory_order_release);
					while (std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire))
						std::this_thread::sleep_for(std::chrono::microseconds(G_THREAD_DEFAULT_SLEEP));
				}
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace SYSTEM
	{
		class GConcurrent final
			: public I::GProxy<I::GConcurrentInterface, I::GConcurrentImplementation, bool>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GConcurrent)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(BranchSingular)
			GATEWARE_FUNCTION(BranchDynamic)
			GATEWARE_TEMPLATE_FUNCTION(BranchParallel)
			GATEWARE_FUNCTION(Converge)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GCONCURRENT_H

/*---------------------------------
|	End of GConcurrent.h
----------------------------------*/


/*---------------------------------
|	Begin of GLog.h
----------------------------------*/
#ifndef GLOG_H
#define GLOG_H




namespace GW
{
	namespace I
	{
		class GLogInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Log(const char* const _log) = 0;
			virtual GReturn LogCategorized(const char* const _category, const char* const _log) = 0;
			virtual GReturn EnableVerboseLogging(bool _value) = 0;
			virtual GReturn EnableConsoleLogging(bool _value) = 0;
			virtual GReturn Flush() = 0;
		};
	}
}

// Implementaion for GLog.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GLOG) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GLOG) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface
		{
		public:
			GW::GReturn Init(const char* const _fileName)
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Init(GW::SYSTEM::GFile _file)
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Log(const char* const _log) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn EnableVerboseLogging(bool _value) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn EnableConsoleLogging(bool _value) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Flush() override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Create(const char* const _fileName)
			{
				return GReturn::FEATURE_UNSUPPORTED;
			};

			GW::GReturn Create(GW::SYSTEM::GFile _file)
			{
				return GReturn::FEATURE_UNSUPPORTED;
			};
		};
	} //end namespace I
} // end namespace GW

#elif defined(__APPLE__) || defined(__linux__)
	



#include <queue>
#include <mutex>
#include <sstream>
#include <iostream>
#include <condition_variable>

#define MAX_QUEUE_SIZE 20
#define THREAD_SLEEP_TIME 1
#define TIME_BUFFER 40

namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface,
			protected GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GFile logFile;
			GW::SYSTEM::GConcurrent thread;
			std::atomic<bool> threadRunning;

			std::condition_variable conditional;
			std::mutex queueLock;
			std::queue<std::string> logQueue;

			bool isVerbose = true;
			bool isConsoleLogged = false;

			unsigned long long GetThreadID()
			{
				std::stringstream ss;
				ss << std::this_thread::get_id();
				return std::stoull(ss.str());
			};

			GReturn LauchThread()
			{
				isVerbose = true;
				isConsoleLogged = false;
				threadRunning = true;
				thread.Create(false);
				return thread.BranchSingular([&]() {
					std::unique_lock<std::mutex> localQueueLock(queueLock);
					while (threadRunning || logQueue.size() != 0)
					{
						//Will lock the mutex when awaken and unlock it when put back to sleep.
						conditional.wait_for(localQueueLock, std::chrono::seconds(THREAD_SLEEP_TIME));
						//If there is anything to write.
						if (logQueue.size() != 0)
						{
							while (logQueue.size() != 0)
							{
								logFile.WriteLine(logQueue.front().c_str());
								logQueue.pop();

								logFile.FlushFile();
							}
						}
					}
				});
			}
		public:
			~GLogImplementation()
			{
				threadRunning = false;
				thread.Converge(0);
			}

			GReturn Create(const char* const _fileName)
			{
				GReturn rv = logFile.Create();
				if (G_FAIL(rv))
					return rv;

				rv = logFile.AppendTextWrite(_fileName);
				if (G_FAIL(rv))
					return rv;

				return LauchThread();
			}

			GReturn Create(SYSTEM::GFile _file)
			{
				if (!_file)
					return GReturn::INVALID_ARGUMENT;
				logFile = _file;

				return LauchThread();
			}

			GReturn Log(const char* const _log) override
			{
				if (_log == nullptr)
					return GReturn::INVALID_ARGUMENT;

				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse the time out to readable time.
					std::string buffer(asctime(localtime(&t)));
					INTERNAL::strcpy_s(timeBuffer, TIME_BUFFER, buffer.c_str());

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Create our log string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the log and a newline.
				logStream << _log << "\r\n";

				//Lock the mutex to push the new message.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				if (_category == nullptr || _log == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				//The stream that will contain the full message.
				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse time to readable time.
					std::string buffer(asctime(localtime(&t)));
					INTERNAL::strcpy_s(timeBuffer, TIME_BUFFER, buffer.c_str());

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Build the string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the category and message.
				logStream << "[" << _category << "]\t" << _log << "\r\n";

				//Lock the mutex to push the new msg.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn EnableVerboseLogging(bool _value) override
			{
				isVerbose = _value;
				return GReturn::SUCCESS;
			};

			GReturn EnableConsoleLogging(bool _value) override
			{
				isConsoleLogged = _value;
				return GReturn::SUCCESS;
			};

			GReturn Flush() override
			{
				conditional.notify_all();
				return GReturn::SUCCESS;
			};

			GReturn LockAsyncRead() const override { return GThreadSharedImplementation::LockAsyncRead(); }
			GReturn UnlockAsyncRead() const override { return GThreadSharedImplementation::UnlockAsyncRead(); }
			GReturn LockSyncWrite() override { return GThreadSharedImplementation::LockSyncWrite(); }
			GReturn UnlockSyncWrite() override { return GThreadSharedImplementation::UnlockSyncWrite(); }
		};
	} //end namespace I
} // end namespace GW

#undef MAX_QUEUE_SIZE
#undef THREAD_SLEEP_TIME
#undef TIME_BUFFER

#elif defined(_WIN32)
	



#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <queue>
#include <atomic>
#include <mutex>
#include <sstream>
#include <iostream>
#include <condition_variable>

#define MAX_QUEUE_SIZE 20
#define THREAD_SLEEP_TIME 1
#define TIME_BUFFER 40

namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface,
			protected GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GFile logFile;
			GW::SYSTEM::GConcurrent thread;
			std::atomic<bool> threadRunning;

			std::condition_variable conditional;
			std::mutex queueLock;
			std::queue<std::string> logQueue;

			bool isVerbose = true;
			bool isConsoleLogged = false;

			unsigned long long GetThreadID()
			{
				std::stringstream ss;
				ss << std::this_thread::get_id();
				return std::stoull(ss.str());
			};

			GReturn LauchThread()
			{
				isVerbose = true;
				isConsoleLogged = false;
				threadRunning = true;
				thread.Create(false);
				return thread.BranchSingular([&]() {
					std::unique_lock<std::mutex> localQueueLock(queueLock);
					while (threadRunning || logQueue.size() != 0)
					{
						//Will lock the mutex when awaken and unlock it when put back to sleep.
						conditional.wait_for(localQueueLock, std::chrono::seconds(THREAD_SLEEP_TIME));
						//If there is anything to write.
						if (logQueue.size() != 0)
						{
							while (logQueue.size() != 0)
							{
								logFile.WriteLine(logQueue.front().c_str());
								logQueue.pop();

								logFile.FlushFile();
							}
						}
					}
				});
			}
		public:
			~GLogImplementation()
			{
				threadRunning = false;
				thread.Converge(0);
			}

			GReturn Create(const char* const _fileName)
			{
				GReturn rv = logFile.Create();
				if (G_FAIL(rv))
					return rv;

				rv = logFile.AppendTextWrite(_fileName);
				if (G_FAIL(rv))
					return rv;

				return LauchThread();
			}

			GReturn Create(SYSTEM::GFile _file)
			{
				if (!_file)
					return GReturn::INVALID_ARGUMENT;
				logFile = _file;

				return LauchThread();
			}

			GReturn Log(const char* const _log) override
			{
				if (_log == nullptr)
					return GReturn::INVALID_ARGUMENT;

				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse the time out to readable time.
					struct tm buf;
					localtime_s(&buf, &t);
					asctime_s(timeBuffer, TIME_BUFFER, &buf);

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Create our log string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the log and a newline.
				logStream << _log << "\r\n";

				//Lock the mutex to push the new message.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				OutputDebugStringW(INTERNAL::G_TO_UTF16(logStream.str()).c_str());
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				if (_category == nullptr || _log == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				//The stream that will contain the full message.
				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse time to readable time.
					struct tm buf;
					localtime_s(&buf, &t);
					asctime_s(timeBuffer, TIME_BUFFER, &buf);

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Build the string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the category and message.
				logStream << "[" << _category << "]\t" << _log << "\r\n";

				//Lock the mutex to push the new msg.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				OutputDebugStringW(INTERNAL::G_TO_UTF16(logStream.str()).c_str());
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn EnableVerboseLogging(bool _value) override
			{
				isVerbose = _value;
				return GReturn::SUCCESS;
			};

			GReturn EnableConsoleLogging(bool _value) override
			{
				isConsoleLogged = _value;
				return GReturn::SUCCESS;
			};

			GReturn Flush() override
			{
				conditional.notify_all();
				return GReturn::SUCCESS;
			};

			GReturn LockAsyncRead() const override { return GThreadSharedImplementation::LockAsyncRead(); }
			GReturn UnlockAsyncRead() const override { return GThreadSharedImplementation::UnlockAsyncRead(); }
			GReturn LockSyncWrite() override { return GThreadSharedImplementation::LockSyncWrite(); }
			GReturn UnlockSyncWrite() override { return GThreadSharedImplementation::UnlockSyncWrite(); }
		};
	} //end namespace I
} // end namespace GW

#undef MAX_QUEUE_SIZE
#undef THREAD_SLEEP_TIME
#undef TIME_BUFFER

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GLog final 
			: public I::GProxy<I::GLogInterface, I::GLogImplementation, const char * const>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GLog)
			GATEWARE_FUNCTION(Log)
			GATEWARE_FUNCTION(LogCategorized)
			GATEWARE_FUNCTION(EnableVerboseLogging)
			GATEWARE_FUNCTION(EnableConsoleLogging)
			GATEWARE_FUNCTION(Flush)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GLOG_H

/*---------------------------------
|	End of GLog.h
----------------------------------*/


/*---------------------------------
|	Begin of GWindow.h
----------------------------------*/
#ifndef GWINDOW_H
#define GWINDOW_H





namespace GW
{
	namespace I
	{
		class GWindowInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				NON_EVENT,
				NOTIFY,
				MINIMIZE,
				MAXIMIZE,
				RESIZE,
				MOVE,
				DISPLAY_CLOSED,
				EVENTS_PROCESSED,
				DESTROY,
			};

			struct EVENT_DATA
			{
				Events eventFlags;
				unsigned int height;
				unsigned int width;
				unsigned int clientHeight;
				unsigned int clientWidth;
				int windowX;
				int windowY;
				void* windowHandle;
			};

			virtual GReturn ProcessWindowEvents() = 0;
			virtual GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, GW::SYSTEM::GWindowStyle _style) = 0;
			virtual GReturn SetWindowName(const char* _newName) = 0;
			virtual GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) = 0;
			virtual GReturn MoveWindow(int _x, int _y) = 0;
			virtual GReturn ResizeWindow(int _width, int _height) = 0;
			virtual GReturn Maximize() = 0;
			virtual GReturn Minimize() = 0;
			virtual GReturn ChangeWindowStyle(GW::SYSTEM::GWindowStyle _style) = 0;
			virtual GReturn	GetWidth(unsigned int& _outWidth) const = 0;
			virtual GReturn	GetHeight(unsigned int& _outHeight) const = 0;
			virtual GReturn	GetClientWidth(unsigned int& _outClientWidth) const = 0;
			virtual GReturn	GetClientHeight(unsigned int& _outClientHeight) const = 0;
			virtual GReturn	GetX(unsigned int& _outX) const = 0;
			virtual GReturn	GetY(unsigned int& _outY) const = 0;
			virtual GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const = 0;
			virtual GReturn GetWindowHandle(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const = 0;
			virtual GReturn IsFullscreen(bool& _outIsFullscreen) const = 0;
			virtual GReturn IsFocus(bool& _outIsFocus) const = 0;
		};
	}
}

// Implementaion for GWindow.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GWINDOW) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GWINDOW) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		public:
			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				return GReturn::FAILURE;
			}

			GReturn ProcessWindowEvents() override
			{
				return GReturn::FAILURE;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				return GReturn::FAILURE;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				return GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				return GReturn::FAILURE;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				return GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				return GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				return GReturn::FAILURE;
			}

			GReturn Minimize() override
			{
				return GReturn::FAILURE;
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return GReturn::FAILURE;
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE & _outUniversalWindowHandle) const override
			{
				return GReturn::FAILURE;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				return GReturn::FAILURE;
			}
			
			GReturn IsFocus(bool& _outIsFocus) const override
			{
				return GReturn::FAILURE;
			}
			
			/*GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override
			{
				return GReturn::FAILURE;
			}

			GReturn Observers(unsigned int& _outCount) const override
			{
				return GReturn::FAILURE;
			}

			GReturn Push(const GEvent & _newEvent) override
			{
				return GReturn::FAILURE;
			}*/
		};
	}
}


#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
@import AppKit;
#endif

#include <thread>


#define GWINDOW_EVENT_FLUSHES 10
#define GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES std::chrono::milliseconds(100)
// Flushes events several times. Used during certain style reconfigurations to ensure windows
// complete their transition fully. Otherwise, windows may remain partly visible when deallocated
// before the transition is complete.
#define GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES()\
int gwinEventFlushs = 0;\
if (GWINDOW_EVENT_FLUSHES > 0)\
    do\
    {\
        std::this_thread::sleep_for(GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES);\
        FlushMacEventLoop();\
    }\
    while (++gwinEventFlushs <= GWINDOW_EVENT_FLUSHES)

namespace GW
{
    namespace I
    {
        class GWindowImplementation;
    }
}

namespace internal_gw
{
    // GWAppDelegate Interface
    
    // Forward declarations of GWAppDelegate methods
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWAppDelegate, void, applicationDidFinishLaunching, NSNotification* notification);

    // Creates the GWAppDelegate class at runtime when G_OBJC_GET_CLASS(GWAppDelegate) is called.
    G_OBJC_CLASS_BEGIN(GWAppDelegate, NSObject<NSApplicationDelegate>)
    {
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWAppDelegate, applicationDidFinishLaunching, "v@:@", :);
    }
    G_OBJC_CLASS_END(GWAppDelegate)

    // GWAppDelegate Interface End



    // GWResponder Interface
    // The GWResponder is our interpretation of the NSResponder that will propagate window messages to other responders

    // Forward declarations of GWResponder methods
    G_OBJC_HEADER_INSTANCE_METHOD(GWResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWResponder, bool, acceptsFirstMouse, NSEvent* event);
    
    // Creates the GWResponder class at runtime when G_OBJC_GET_CLASS(GWResponder) is called.
    G_OBJC_CLASS_BEGIN(GWResponder, NSResponder)
    {
        G_OBJC_CLASS_METHOD(GWResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWResponder, acceptsFirstMouse, "B@:@", :);
    }
    G_OBJC_CLASS_END(GWResponder)

    // GWResponder Interface End



    // GWDelegate Interface
    // The GWDelegate will be the delegate of the main window which will receive window events

    // Data members of GWDelegate
    G_OBJC_DATA_MEMBERS_STRUCT(GWDelegate)
    {
        GW::I::GWindowImplementation* pWindow;
        GW::I::GWindowInterface::EVENT_DATA eventData;
        GW::GEvent gevent;
        GW::SYSTEM::GWindowStyle* gWindowStyle;
        bool* windowNeedsRedirecting;
        bool* windowStyleNeedsUpdating;
    };

    // Forward declarations of GWDelegate methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GWDelegate);

    G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(GWDelegate, void, doNothing, id threadID);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, NSSize, windowWillResize, NSWindow* sender, NSSize frameSize);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidResize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMove, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMiniaturize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidDeminiaturize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidEnterFullScreen, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidExitFullScreen, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowWillClose, NSNotification* notification);

    // Creates the GWDelegate class at runtime when G_OBJC_GET_CLASS(GWDelegate) is called
    G_OBJC_CLASS_BEGIN(GWDelegate, NSObject<NSWindowDelegate>)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GWDelegate);

        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, doNothing, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowWillResize, "@@:@@", ::);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidResize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidMove, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidMiniaturize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidDeminiaturize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidEnterFullScreen, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidExitFullScreen, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowWillClose, "v@:@", :);
    }
    G_OBJC_CLASS_END(GWDelegate)

    // GWDelegate Interface End
}

#include <atomic>
#include <mutex>
#include <string.h>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 1
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 2
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'a'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "development"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x6d438ef0d0
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v1.2a"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v1.2a (development) [6d438ef0d0]"

#endif



namespace GW
{
    namespace I
    {
        class GWindowImplementation :   public virtual GWindowInterface,
                                        public GEventGeneratorImplementation
        {
        private:
            NSWindow* window;
            NSAutoreleasePool* pool;

            std::atomic<int> xPos;
            std::atomic<int> yPos;
            std::atomic<int> width;
            std::atomic<int> height;

            SYSTEM::GWindowStyle gWindowStyle;
            GEvent gEvent;
            GW::I::GWindowInterface::EVENT_DATA* eventData;
            __block bool windowNeedsRedirecting;
            __block bool windowStyleNeedsUpdating;
            __block bool reconfigRequiresExtraStep;

            void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
            {
                width = _width;
                height = _height;
                xPos = _x;
                yPos = _y;
                gWindowStyle = _style;
            }

            id responder;
            id delegate;
            id appDel;

            GReturn OpenWindow()
            {
                if (window)
                    return GReturn::REDUNDANT;

                responder = [internal_gw::G_OBJC_GET_CLASS(GWResponder) alloc];
                delegate = [internal_gw::G_OBJC_GET_CLASS(GWDelegate) alloc];
                appDel = [internal_gw::G_OBJC_GET_CLASS(GWAppDelegate) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& delegateDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GWDelegate, delegate);
                delegateDataMembers.pWindow = this;
                delegateDataMembers.gWindowStyle = &gWindowStyle;
                delegateDataMembers.windowNeedsRedirecting = &windowNeedsRedirecting;
                delegateDataMembers.windowStyleNeedsUpdating = &windowStyleNeedsUpdating;
                
                reconfigRequiresExtraStep = false;
                
                eventData = &delegateDataMembers.eventData;

                pool = [[NSAutoreleasePool alloc]init];

                [NSApplication sharedApplication] ;

                [NSThread detachNewThreadSelector : @selector(doNothing : ) toTarget: delegate withObject : nil] ;

                [NSApp setActivationPolicy : NSApplicationActivationPolicyRegular] ;
                [NSApp setDelegate : appDel] ;
                
                NSUInteger windowStyleMask = ConvertWindowsStyle(gWindowStyle);

                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                
                NSRect windowRect;
                if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                {
                    windowRect = NSMakeRect(xPos, screenSize.height - yPos - height, screenSize.width, screenSize.height);
                    
                    [NSMenu setMenuBarVisible:NO];
                }
                else
                {
                    windowRect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                    
                    // Adjust the window rect so the content area is the desired width and height.
                    ConvertContentRectToFrameRect(windowRect, windowStyleMask);
                    
                    [NSMenu setMenuBarVisible:YES];
                }

                window = [[NSWindow alloc]initWithContentRect:windowRect
                    styleMask : windowStyleMask
                    backing : NSBackingStoreBuffered
                    defer : NO];
                
                if (window == nil)
                    return GReturn::FAILURE;
#ifdef _DEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
                [window setTitle : @GATEWARE_WINDOW_NAME];
#undef GATEWARE_WINDOW_NAME
                
                [window setFrame : windowRect display : YES] ;

                if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
                    [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];
                else
                    [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                
                [responder setNextResponder : window.nextResponder] ;
                [window setNextResponder : responder] ;
                [window makeFirstResponder : window.contentView] ;
                [window.contentView setNextResponder : responder] ;

                [window setDelegate : delegate] ;
                [window makeKeyAndOrderFront : nil] ;

                if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                {
                    [window toggleFullScreen : nil] ;
                    FlushMacEventLoop();
                }
                else if (gWindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
                {
                    [window miniaturize : nil] ;
                    FlushMacEventLoop();
                    
                    [pool drain] ;
                    
                    if ([window isMiniaturized])
                        return GReturn::SUCCESS;
                    
                    return GReturn::FAILURE;
                }
                
                [pool drain] ;

                if ([window isVisible])
                    return GReturn::SUCCESS;
                else
                    return GReturn::FAILURE;
            }
            
            /*
                Converts a content area (aka client area) rectangle to a window frame rectangle, while taking into account
                the style mask of the window. The resultant rectangle is large enough to size a window so that contains the
                full size of the original rectangle passed to the function.
             */
            void ConvertContentRectToFrameRect(NSRect& _rect, const NSUInteger _mask) const
            {
                // Get the content area (client area) after creating a window frame with _rect.
                NSRect contentRect = [NSWindow contentRectForFrameRect:_rect styleMask:_mask];
                
                // Calculate the border size
                CGSize borderSize = NSMakeSize(
                       _rect.size.width - contentRect.size.width,
                       _rect.size.height - contentRect.size.height
                );
                
                _rect.origin.y -= borderSize.height; // Adjust the y position to account for the titlebar.
                // Add the border size to _rect to create a frame area that preserves the desired content area dimensions.
                _rect.size = NSMakeSize(
                       _rect.size.width + borderSize.width,
                       _rect.size.height + borderSize.height
                );
            }
            
            /*
                Takes a GWindowStyle and returns the corresponding NSWindowStyleMask.
             */
            NSUInteger ConvertWindowsStyle(SYSTEM::GWindowStyle _style) const
            {
                switch (_style)
                {
                    case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
                    case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
                    case SYSTEM::GWindowStyle::MINIMIZED:
                        return NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                        
                    case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
                        return NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                        
                    case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
                    case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
                        return NSWindowStyleMaskMiniaturizable;
                }
                return 0;
            }
            
        public:
            ~GWindowImplementation()
            {
                RUN_ON_UI_THREAD(^ {
                    if (window && [window acceptsMouseMovedEvents])
                    {
                        [window setAcceptsMouseMovedEvents:NO];
                        FlushMacEventLoop();
                    }
                    
                    [NSMenu setMenuBarVisible:YES];
                    FlushMacEventLoop();
                    
                    if (window)
                    {
                        bool fullscreen;
                        IsFullscreen(fullscreen);
                        
                        if (fullscreen)
                        {
                            [window toggleFullScreen : nil] ;
                            FlushMacEventLoop();
                        }
                        else if ([window isMiniaturized])
                        {
                            [window deminiaturize : nil];
                            FlushMacEventLoop();
                        }
                        
                        [window close] ;
                        FlushMacEventLoop();
                    }

                    // A paranoia check to make sure there are no remaining
                    // events that may trigger after the window is cleaned up.
                    for (int i = 0; i < 10; ++i)
                        FlushMacEventLoop();
                });
                
                if (window)
                {
                    // Remove subviews like the one added by GRasterSurface.
                    NSArray* subViewArray = [[window contentView] subviews];
                    for (id obj in subViewArray)
                        [obj removeFromSuperview];
                        
                    [window release] ;
                    window = nil;
                }
                
                if (responder)
                {
                    [responder release] ;
                    responder = nil;
                }
                
                if (delegate)
                {
                    [(delegate)release] ;
                    (delegate) = nil;
                }
                
                if (appDel)
                {
                    [appDel release] ;
                    appDel = nil;
                }
            }

            GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
            {
                this->SetInteralData(_x, _y, _width, _height, _style);
                return OpenWindow();
            }

            GReturn ProcessWindowEvents() override
            {
                if (eventData->eventFlags == Events::DESTROY)
                    return GReturn::FAILURE;
                
                RUN_ON_UI_THREAD(^ {
                    eventData->eventFlags = Events::EVENTS_PROCESSED;
                    gEvent.Write(eventData->eventFlags, eventData);
                    Push(gEvent);
                    FlushMacEventLoop();
                });

                return GReturn::SUCCESS;
            }

            GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, GW::SYSTEM::GWindowStyle _style) override
            {
                if (!window)
                    return GReturn::FAILURE;
                
                GW::SYSTEM::GWindowStyle prevStyle = gWindowStyle;
                SetInteralData(_x, _y, _width, _height, _style);
                
                switch (gWindowStyle)
                {
                case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    // If the window is minimized or fullscreen, it will need to be brought out of those states
                    // before modifying the window further.
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            // Must use RUN_ON_UI_THREAD when changing the window's look.
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true; // Marks that exiting fullscreen doesn not complete the style change.
                                [window toggleFullScreen : nil];

                                // Flush the events so they propagate.
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskBorderless;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskBorderless;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;
                        
                case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);

                    if (fullscreen)
                    {
                        if (gWindowStyle == prevStyle)
                            return GReturn::SUCCESS;
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];

                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });
                            
                            if (window)
                                return GReturn::SUCCESS;

                            return GReturn::FAILURE;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger styleMask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;

                            [NSMenu setMenuBarVisible : YES];

                            [window setStyleMask : styleMask] ;
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                            [window toggleFullScreen : nil];

                            if (reconfigRequiresExtraStep)
                            {
                                reconfigRequiresExtraStep = false;
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            }
                            else
                                FlushMacEventLoop();
                        });
                        
                        if (window)
                            return GReturn::SUCCESS;

                        return GReturn::FAILURE;
                    }
                }
                break;

                case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);

                    if (fullscreen)
                    {
                        if (gWindowStyle == prevStyle)
                            return GReturn::SUCCESS;
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];

                                FlushMacEventLoop();
                            });
                            
                            if (window)
                                return GReturn::SUCCESS;

                            return GReturn::FAILURE;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger styleMask = NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(0, 0, screenSize.width, screenSize.height);

                            [NSMenu setMenuBarVisible : NO];

                            [window setStyleMask : styleMask] ;
                            [window setFrame : rect display : YES] ;
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                            [window toggleFullScreen : nil];

                            FlushMacEventLoop();
                        });
                    }
                    
                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::MINIMIZED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                [NSMenu setMenuBarVisible : YES];
                                
                                [window setHasShadow: YES];
                                
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            [NSMenu setMenuBarVisible : YES];
                            
                            [window miniaturize : nil] ;
                            
                            FlushMacEventLoop();
                        });
                    }

                    if ([window isMiniaturized])
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;
                }
                
                return GReturn::SUCCESS;
            }

            GReturn SetWindowName(const char* _newName) override
            {
                bool operationResult = false;

                if (_newName == nil)
                    return GReturn::INVALID_ARGUMENT;

                if (!window)
                    return GReturn::REDUNDANT;

                NSString* macName = [NSString stringWithCString : _newName encoding : NSUTF8StringEncoding];

                window.title = macName;

                if (window.title == macName)
                    operationResult = true;

                if (operationResult)
                    return GReturn::SUCCESS;

                return GReturn::FAILURE;
            }

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
            {
                if (!window)
                    return GReturn::FAILURE;

                if (_argbPixels == nullptr)
                    return GReturn::INVALID_ARGUMENT;
                else if (_width <= 0 || _height <= 0)
                    return GReturn::INVALID_ARGUMENT;

                NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc]
                    initWithBitmapDataPlanes:NULL
                    pixelsWide : _width
                    pixelsHigh : _height
                    bitsPerSample : 8
                    samplesPerPixel : 4
                    hasAlpha : YES
                    isPlanar : NO
                    colorSpaceName : NSDeviceRGBColorSpace
                    bitmapFormat : NSBitmapFormatAlphaFirst
                    bytesPerRow : 0
                    bitsPerPixel : 0
                ];
                unsigned int* imagePixels = (unsigned int*)[bitmap bitmapData];
                NSImage* image = [[NSImage alloc] init];
                [image addRepresentation : bitmap] ;

                // Convert the pixels from ARGB ro BGRA
                for (size_t i = 0; i < _width * _height; ++i)
                    imagePixels[i] = (_argbPixels[i] & 0xFF000000) >> 24
                                   | (_argbPixels[i] & 0x00FF0000) >> 8
                                   | (_argbPixels[i] & 0x0000FF00) << 8
                                   | (_argbPixels[i] & 0x000000FF) << 24;
                
                [NSApplication sharedApplication].applicationIconImage = image;
                
                [image release];
                image = nil;
                
                [bitmap release];
                bitmap = nil;

                return GReturn::SUCCESS;
            }

            GReturn MoveWindow(int _x, int _y) override
            {
                if (!window)
                    return GReturn::FAILURE;

                SetInteralData(_x, _y, width, height, gWindowStyle);

                RUN_ON_UI_THREAD(^ {
                    CGSize screenSize = [[NSScreen mainScreen] frame].size;
                    
                    CGPoint newPos;
                    newPos.y = screenSize.height - yPos;
                    newPos.x = xPos;

                    NSPoint pointPos;
                    pointPos.y = newPos.y;
                    pointPos.x = newPos.x;

                    [window setFrameTopLeftPoint : pointPos] ;
                    FlushMacEventLoop();
                });

                return GReturn::SUCCESS;
            }

            GReturn ResizeWindow(int _width, int _height) override
            {
                if (!window)
                    return GReturn::FAILURE;

                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                SetInteralData(xPos, screenSize.height - yPos - _height, _width, _height, gWindowStyle);
                
                NSUInteger windowStyleMask = ConvertWindowsStyle(gWindowStyle);

                RUN_ON_UI_THREAD(^ {
                    NSRect rect = NSMakeRect(xPos, yPos, _width, _height);
                    
                    ConvertContentRectToFrameRect(rect, windowStyleMask);

                    [window setFrame : rect display : YES] ;
                    FlushMacEventLoop();
                });
                return GReturn::SUCCESS;
            }

            GReturn Maximize() override
            {
                if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || gWindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
                {
                    return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
                }
                else if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
                {
                    return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
                }
                else
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (!fullscreen)
                    {
                        if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
                        }
                        else if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
                        }
                    }
                }
                return GReturn::REDUNDANT;
            }

            GReturn Minimize() override
            {
                return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
            }

            GReturn ChangeWindowStyle(GW::SYSTEM::GWindowStyle _style) override
            {
                return ReconfigureWindow(xPos, yPos, width, height, _style);
            }

            GReturn    GetWidth(unsigned int& _outWidth) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outWidth = rect.size.width;
                return GReturn::SUCCESS;
            }

            GReturn    GetHeight(unsigned int& _outHeight) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outHeight = rect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn    GetClientWidth(unsigned int& _outClientWidth) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                _outClientWidth = contentRect.size.width;
                return GReturn::SUCCESS;
            }

            GReturn    GetClientHeight(unsigned int& _outClientHeight) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                _outClientHeight = contentRect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn    GetX(unsigned int& _outX) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outX = rect.origin.x;
                return GReturn::SUCCESS;
            }

            GReturn    GetY(unsigned int& _outY) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                _outY = screenSize.height - rect.origin.y - rect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
            {
                if (!window)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                _outX = contentRect.origin.x;
                _outY = contentRect.origin.y;
                return GReturn::SUCCESS;
            }

            GReturn GetWindowHandle(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
            {
                if (!(__bridge void*)window)
                {
                    return GReturn::FAILURE;
                }
                _outUniversalWindowHandle.window = window;
                return GReturn::SUCCESS;
            }

            GReturn IsFullscreen(bool& _outIsFullscreen) const override
            {
                __block NSWindowStyleMask winStyle;
                RUN_ON_UI_THREAD(^ { winStyle = [window styleMask]; });
                if ((winStyle & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen)
                    _outIsFullscreen = TRUE;
                else
                    _outIsFullscreen = FALSE;

                return GReturn::SUCCESS;
            }

            GReturn IsFocus(bool& _outIsFocus) const override
            {
                // mac auto filters input events based on active window
                // for conformity we may need a way to get backgroud keys
                // then this function will be needed for filtering.
                _outIsFocus = true;
                return GReturn::SUCCESS;
            }
        };
    }
}

namespace internal_gw
{
    // GWAppDelegate Implementation

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWAppDelegate, void, applicationDidFinishLaunching, NSNotification* notification)
    {
        [NSApp stop : nil] ;

        NSPoint p;
        p.x = 0;
        p.y = 0;

        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc]init];

        NSEvent* event = [NSEvent otherEventWithType : NSEventTypeApplicationDefined
            location : p
            modifierFlags : 0
            timestamp : 0
            windowNumber : 0
            context : nil
            subtype : 0
            data1 : 0
            data2 : 0];

        [NSApp postEvent : event atStart : YES] ;
        [pool drain] ;
    }

    // GWAppDelegate Implementation End



    // GWResponder Implementation

    G_OBJC_HEADER_INSTANCE_METHOD(GWResponder, bool, acceptFirstResponder)
    {
        return YES;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWResponder, bool, acceptsFirstMouse, NSEvent* event)
    {
        return YES;
    }

    // GWResponder Implementation End



    // GWDelegate Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GWDelegate);

    G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(GWDelegate, void, doNothing, id threadID) {}

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, NSSize, windowWillResize, NSWindow* sender, NSSize frameSize)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window will be resized (whether by the user or through one of the setFrame...methods
        //other than setFrame:display)
        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = frameSize.height;
        eventData.width = frameSize.width;
		NSSize contentSize = [sender contentRectForFrameRect : sender.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = sender.frame.origin.x;
        eventData.windowY = screenSize.height - sender.frame.origin.y - sender.frame.size.height;
        eventData.windowHandle = (__bridge void*)sender;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        return frameSize;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidResize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window been resized
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        if (*selfDataMembers.windowStyleNeedsUpdating)
        {
            *selfDataMembers.windowStyleNeedsUpdating = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMove, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has moved.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MOVE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMiniaturize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has been minimized.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MINIMIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidDeminiaturize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has been deminimized.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        //A window might need to be redirected to another state after becoming windowed for the following reasons:
        //    - macOS does not support minimizing directly from FullScreen.
        //    - Switching between FULLSCREENBORDERED and FULLSCREENBORDERLESS leads to empty screen spaces.
        //    - Resizing a window and exiting fullscreen causes EXC_BAD_ACCESS errors.
        if (*selfDataMembers.windowNeedsRedirecting)
        {
            *selfDataMembers.windowNeedsRedirecting = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidEnterFullScreen, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //The window has entered full-screen mode.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MAXIMIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidExitFullScreen, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //The window has left full-screen mode.
        
        if (*selfDataMembers.windowNeedsRedirecting)
        {
            *selfDataMembers.windowNeedsRedirecting = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowWillClose, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window is about to close.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::DESTROY;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    // GWDelegate Implementation End
}

#undef GWINDOW_EVENT_FLUSHES
#undef GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES
#undef GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <unistd.h>
#include <string.h>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 1
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 2
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'a'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "development"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x6d438ef0d0
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v1.2a"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v1.2a (development) [6d438ef0d0]"

#endif



// Depending on the hardware, the default color buffer size isn't always 32-bit.
// GLX is needed to create a window for OpenGL with a 32-bit color buffer.
#if defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE)
#include <GL/glx.h>
#endif

namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		private:
			Display* display;
			Window window;

			bool destroyEventIsSentByXButton;
			bool windowIsRunning;
			Atom prop_type;
			Atom prop_hidden;
			Atom prop_hMax;
			Atom prop_vMax;
			Atom prop_remove;
			Atom prop_hints;
			Atom prop_iconic;
			Atom prop_active;
			Atom wmDeleteMessage;

			struct Hint
			{
				unsigned long flags;
				unsigned long functions;
				unsigned long decorations;
				long inputMode;
				unsigned long status;

			} hint;

			int m_WindowX;
			int m_WindowY;
			int m_WindowWidth;
			int m_WindowHeight;
			SYSTEM::GWindowStyle m_WindowStyle;

			CORE::GThreadShared m_Mutex;
			GEvent m_GEvent;

			unsigned long* m_iconPixels;
			int m_iconPixelsCount;

			void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				m_WindowX = _x;
				m_WindowY = _y;
				m_WindowWidth = _width;
				m_WindowHeight = _height;
				m_WindowStyle = _style;
			}

			GReturn OpenWindow()
			{
				if (display && window)
					return GReturn::REDUNDANT;
				
				XInitThreads();
				XSetWindowAttributes attributes;
				XSizeHints rect;
				
				display = XOpenDisplay(NULL);
				if (!display)
					return GReturn::FAILURE;
					
				int screen = DefaultScreen(display);
				int depth = DefaultDepth(display, screen);
				
				unsigned long valueMask = CWBackPixel | CWBorderPixel | CWEventMask;
								
				attributes.background_pixel = XWhitePixel(display, 0);
				attributes.border_pixel = XBlackPixel(display, 0);
				attributes.event_mask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | StructureNotifyMask;

				m_iconPixels = nullptr;
				m_iconPixelsCount = 0;

// If OpenGL is enabled then we need to make sure we create a window with a 32-bit color buffer.
#if defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE)
				
				constexpr int colorBufferSize = 32;
				
				XVisualInfo visualTemplate;
				visualTemplate.screen = screen;
				
				int visualListCount = 0;
				XVisualInfo *visualList = XGetVisualInfo(display, VisualScreenMask, &visualTemplate, &visualListCount);
				
				// Search through the list of visuals for a match with our target depth and color buffer.
				XVisualInfo* visualInfo = nullptr;
				for (int i = 0; i < visualListCount; ++i)
				{
					if (visualList[i].depth == depth)
					{
						int bufferSizeAtIndex;
						glXGetConfig(display, &visualList[i], GLX_BUFFER_SIZE, &bufferSizeAtIndex);
						
						if (bufferSizeAtIndex == colorBufferSize)
						{
							visualInfo = &visualList[i];
							break;
						}
					}						
				}
				
				if (!visualInfo)
				{
					XFree(visualList);
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}

				valueMask |= CWColormap;
				attributes.colormap = XCreateColormap(display, XDefaultRootWindow(display), visualInfo->visual, AllocNone);

				window = XCreateWindow(display, XRootWindow(display, screen), m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, 5,
					visualInfo->depth, InputOutput, visualInfo->visual, valueMask, &attributes);
				
				// No longer need visual info
				XFree(visualList);
				visualInfo = nullptr;
				
#else // Use the color buffer size from the parent if OpenGL is not being used.

				window = XCreateWindow(display, XRootWindow(display, screen), m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, 5,
					depth, InputOutput, CopyFromParent, valueMask, &attributes);

#endif
				
				if (!window)
				{
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}

#ifdef _DEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
				XStoreName(display, window, GATEWARE_WINDOW_NAME);
#undef GATEWARE_WINDOW_NAME

				// Set rect hints
				memset(&rect, 0, sizeof(rect));
				rect.flags = PSize | PPosition;
				
				XSetWMNormalHints(display, window, &rect);

				if (XMapWindow(display, window))
				{
					prop_type = XInternAtom(display, "_NET_WM_STATE", False);
					prop_hidden = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
					prop_hMax = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
					prop_vMax = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
					prop_remove = XInternAtom(display, "_NET_WM_STATE_REMOVE", False);
					prop_hints = XInternAtom(display, "_MOTIF_WM_HINTS", False);
					prop_iconic = XInternAtom(display, "_NET_WM_STATE_HIDDEN", False);
					prop_active = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
					wmDeleteMessage = XInternAtom(display, "WM_DELETE_WINDOW", False);

					// The window manager may not create the window at the desired position.
					// This call to XMoveWindow ensures that the window ends up at the desired positon.
					XMoveWindow(display, window, m_WindowX, m_WindowY);
					
					if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
					{
						memset(&rect, 0, sizeof(rect));
						rect.flags = PMinSize | PMaxSize;
						rect.min_width = rect.max_width = m_WindowWidth;
						rect.min_height = rect.max_height = m_WindowHeight;
						XSetWMNormalHints(display, window, &rect);
					}
					else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
					{						
						hint.flags = 2; //2
						hint.decorations = 0; //0
						XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5);
					}
					else if (m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
					{
						if (!XIconifyWindow(display, window, DefaultScreen(display)))
						{
							//Tells the server what events to look for with these masks.
							unsigned int eventMask = ResizeRedirectMask | PropertyChangeMask | SubstructureNotifyMask | SubstructureRedirectMask;

							//Fill the correct Event structure for the action you performed on the window to update the server side.
							XEvent eventData;
							memset(&eventData, 0, sizeof eventData);
							eventData.type = ClientMessage;
							eventData.xclient.send_event = true; //True = that you are going to use XSendEvent to let the server know
							eventData.xclient.display = display;
							eventData.xclient.window = window;
							eventData.xclient.message_type = prop_hidden;

							//Send event to server and wait a bit so it can receive it.
							XSendEvent(display, window, false, eventMask, &eventData);
							return GReturn::FAILURE;
						}
					}
					
					if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
					{
						Screen* screen = DefaultScreenOfDisplay(display);
						if (!XMoveResizeWindow(display, window, 0, 0, screen->width, screen->height))
							return GReturn::FAILURE;
					}
					
					XSetWMProtocols(display, window, &wmDeleteMessage, 1);

					windowIsRunning = true;
					destroyEventIsSentByXButton = false;
					return GReturn::SUCCESS;
				}
				else
				{
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}
			}
		public:
			~GWindowImplementation()
			{
				if (!windowIsRunning)
					return;
				windowIsRunning = false;
				if (!destroyEventIsSentByXButton)
				{
					//Delete icon
					if (m_iconPixels)
					{
						delete m_iconPixels;
						m_iconPixels = nullptr;
						m_iconPixelsCount = 0;
					}

					//Send Event Data for DESTROY
					Window rootRet = 0;
					int borderSize = 0; int titleBarHeight = 0;
					unsigned int width = 0; unsigned int height = 0; unsigned int borderHeight = 0; unsigned int depth = 0;
					XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth);
					
					EVENT_DATA eventData;
					eventData.eventFlags = Events::DESTROY;
					eventData.width = 2 * borderSize + m_WindowWidth;
					eventData.height = borderSize + titleBarHeight + m_WindowHeight;
					eventData.clientWidth = m_WindowWidth;
					eventData.clientHeight = m_WindowHeight;
					eventData.windowX = m_WindowX;
					eventData.windowY = m_WindowY;
					eventData.windowHandle = display;
					m_GEvent.Write(eventData.eventFlags, eventData);
					Push(m_GEvent);

					//Close Window and Display
					XDestroyWindow(display, window);
					XCloseDisplay(display);
					window = 0;
					display = nullptr;

					//Send Event Data for DISPLAY_CLOSED
					eventData.eventFlags = Events::DISPLAY_CLOSED;
					eventData.width = 0;
					eventData.height = 0;
					eventData.clientWidth = 0;
					eventData.clientHeight = 0;
					eventData.windowX = 0;
					eventData.windowY = 0;
					eventData.windowHandle = 0;
					m_GEvent.Write(eventData.eventFlags, eventData);
					Push(m_GEvent);
				}
			}

			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				this->SetInteralData(_x, _y, _width, _height, _style);
				return OpenWindow();
			}

			GReturn ProcessWindowEvents() override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;
				Atom prop = 0;
				XEvent xEvent;
				EVENT_DATA eventData;
				Window rootRet = 0;

				Window child;
				XWindowAttributes windowAttributes;

				int x = 0;     int y = 0;
				int prevX = 0; int prevY = 0;
				int borderSize = 0; int titleBarHeight = 0;
				bool singleHitMaximize = false; bool singleHitMinimize = false;
				unsigned int width = 0;     unsigned int height = 0; unsigned int borderHeight = 0; unsigned int depth = 0;
				unsigned int prevWidth = 0; unsigned int prevHeight = 0;
				int status = 0;

				//ZeroMemory the structs
				memset(&xEvent, 0, sizeof(xEvent));
				memset(&eventData, 0, sizeof(eventData));

				Atom propType = XInternAtom(display, "_NET_WM_STATE", true);
				Atom propHidden = XInternAtom(display, "_NET_WM_STATE_HIDDEN", true);
				Atom propFullHorz = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_HORZ", true);
				Atom propFullVert = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_VERT", true);
				Atom propFull = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", true);
				Atom propClose = XInternAtom(display, "WM_DESTROY_WINDOW", true);

				Atom actual_type = 0;
				unsigned long nitems = 0;
				unsigned long bytes_after = 0;
				int actual_format = 0;

				while (XPending(display) > 0)
				{
					eventData.eventFlags = Events::DESTROY; // ensure we don't spam
					unsigned char* propRet = nullptr;
					//Also flushes the request buffer if xlib's queue does not contain an event and waits for an event to arrive from server connection
					XNextEvent(display, &xEvent);
					switch (xEvent.type)
					{
					default:
						break;
					case Expose: //Expose, when a window becomes visible on the screen, after being obscured or unmapped.
					case SelectionClear: //Clients losing ownership of a selection.
					case SelectionNotify: //A response to a ConvertSelection request when there is no owner for the selection
					case SelectionRequest: //A client requests a selection conversion by calling XConvertSelection() for the owned selection.
					case NoExpose: //Generates this event whenever a destination region could not be computed due to an obscured or out-of-bounds source region.
					case ButtonPress: //Respond to button press
						break;

					case PropertyNotify:
					{
						//PropertyNotify, when a client wants info about property changes for a specified window
						//To receive PropertyNotify events, set the PropertyChangeMask bit in the event-mask attribute of the window.
						status = XGetWindowProperty(xEvent.xproperty.display, xEvent.xproperty.window, propType, 0L, sizeof(Atom),
							false, AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after, &propRet);

						if (status == Success && propRet && nitems > 0)
						{
							prop = ((Atom*)propRet)[0];
							XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth);
							XTranslateCoordinates(display, window, rootRet, 0, 0, &x, &y, &child);
							XGetWindowAttributes(display, window, &windowAttributes);
							
							// At this point, x is the screen space location of the client area and windowAttributes.x is the distance from the top-left of the
							// window to the top-left of the client view. To get the top-left screenspace postition of the window we need to subtract the two.
							int windowFrameX = x - windowAttributes.x;
							int windowFrameY = y - windowAttributes.y;
							// To get the frame dimensions, the border and title bar need to be added to the client dimensions.
							int windowFrameWidth = 2 * borderSize + width;
							int windowFrameHeight = borderSize + titleBarHeight + height;
							
							if (prop == propHidden && !singleHitMinimize)
							{
								eventData.eventFlags = Events::MINIMIZE;
								singleHitMinimize = true;
								singleHitMaximize = false;
							}
							else if ((prop == 301 || prop == 302 || prop == propFull || prop == propFullHorz || prop == propFullVert) && !singleHitMaximize)
							{
								eventData.eventFlags = Events::MAXIMIZE;
								singleHitMaximize = true;
								singleHitMinimize = false;
							}
							else if (prevX != windowFrameX || prevY != windowFrameY)
							{
								eventData.eventFlags = Events::MOVE;
								singleHitMinimize = false;
								singleHitMaximize = false;
							}
							else if (prevHeight != windowFrameHeight || prevWidth != windowFrameWidth)
							{
								eventData.eventFlags = Events::RESIZE;
								singleHitMinimize = false;
								singleHitMaximize = false;
							}

							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = width;
							eventData.clientHeight = height;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowFrameHeight; prevWidth = windowFrameWidth;
						}
						XFree(propRet);
					}
					break;

					case ConfigureNotify:
					{
						//ConfigureNotify, when a client wants info about the actual changes to a window's state,
						//such as size, position, border, and stacking order.
						if (XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth) == 0)
						{
							break;
						}

						XTranslateCoordinates(display, window, rootRet, 0, 0, &x, &y, &child);
						XGetWindowAttributes(display, window, &windowAttributes);
						
						int windowFrameX = x - windowAttributes.x;
						int windowFrameY = y - windowAttributes.y;
						int windowFrameWidth = 2 * borderSize + width;
						int windowFrameHeight = borderSize + titleBarHeight + height;
						
						// if the previous position is not equal to the current position then we moved.
						if (prevX != windowFrameX || prevY != windowFrameY)
						{
							eventData.eventFlags = Events::MOVE;
						}
						// if the previous width/height are not equal to the current width/height then we resized.
						if (prevHeight != windowFrameHeight || prevWidth != windowFrameWidth)
						{
							bool isFullscreen;
							if (+IsFullscreen(isFullscreen) && isFullscreen)
								eventData.eventFlags = Events::MAXIMIZE;
							else
								eventData.eventFlags = Events::RESIZE;
						}

						eventData.width = windowFrameWidth;
						eventData.height = windowFrameHeight;
						eventData.clientWidth = width;
						eventData.clientHeight = height;
						eventData.windowX = windowFrameX;
						eventData.windowY = windowFrameY;
						eventData.windowHandle = display;
						prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowFrameHeight; prevWidth = windowFrameWidth;
					}
					break;

					case MapNotify:
					{
						//MapNotify, when clients want info about which windows are mapped.
						//The change of a window's state from unmapped to mapped
						if (XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth) == 0)
							break;
						
						XTranslateCoordinates(display, window, rootRet, 0, 0, &x, &y, &child);
						XGetWindowAttributes(display, window, &windowAttributes);
						
						int windowFrameX = x - windowAttributes.x;
						int windowFrameY = y - windowAttributes.y;
						int windowFrameWidth = 2 * borderSize + width;
						int windowFrameHeight = borderSize + titleBarHeight + height;
						
						eventData.eventFlags = Events::MAXIMIZE;
						eventData.width = windowFrameWidth;
						eventData.height = windowFrameHeight;
						eventData.clientWidth = width;
						eventData.clientHeight = height;
						eventData.windowX = windowFrameX;
						eventData.windowY = windowFrameY;
						eventData.windowHandle = display;
						prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowFrameHeight; prevWidth = windowFrameWidth;
					}
					break;

					case ClientMessage:
					{
						// Primarily used for transferring selection data,
						// also might be used in a private interclient
						// protocol
						if (xEvent.xclient.message_type == propHidden)
						{
							if (XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth) == 0)
								break;
							XTranslateCoordinates(display, window, rootRet, 0, 0, &x, &y, &child);
							XGetWindowAttributes(display, window, &windowAttributes);
						
							int windowFrameX = x - windowAttributes.x;
							int windowFrameY = y - windowAttributes.y;
							int windowFrameWidth = 2 * borderSize + width;
							int windowFrameHeight = borderSize + titleBarHeight + height;
						
							eventData.eventFlags = Events::MINIMIZE;
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = width;
							eventData.clientHeight = height;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowFrameHeight; prevWidth = windowFrameWidth;
						}
						else if (xEvent.xclient.data.l[0] == wmDeleteMessage)
						{
							windowIsRunning = false;
							destroyEventIsSentByXButton = true;
							XGetGeometry(display, window, &rootRet, &borderSize, &titleBarHeight, &width, &height, &borderHeight, &depth);
							XTranslateCoordinates(display, window, rootRet, 0, 0, &x, &y, &child);
							XGetWindowAttributes(display, window, &windowAttributes);
						
							int windowFrameX = x - windowAttributes.x;
							int windowFrameY = y - windowAttributes.y;
							int windowFrameWidth = 2 * borderSize + width;
							int windowFrameHeight = borderSize + titleBarHeight + height;
						
							prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowFrameHeight; prevWidth = windowFrameWidth;
							eventData.eventFlags = Events::DESTROY;
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = width;
							eventData.clientHeight = height;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							m_GEvent.Write(eventData.eventFlags, eventData);
							Push(m_GEvent);
							XDestroyWindow(display, window);
							XCloseDisplay(display);
							window = 0;
							display = nullptr;


							//Send Event Data for DISPLAY_CLOSED
							eventData.eventFlags = Events::DISPLAY_CLOSED;
							eventData.width = 0;
							eventData.height = 0;
							eventData.clientWidth = 0;
							eventData.clientHeight = 0;
							eventData.windowX = 0;
							eventData.windowY = 0;
							eventData.windowHandle = 0;
							m_GEvent.Write(eventData.eventFlags, eventData);
							Push(m_GEvent);
							
							return GReturn::FAILURE;
						}
					}
					break;
					}

					if (eventData.eventFlags != Events::DESTROY)
					{
						m_GEvent.Write(eventData.eventFlags, eventData);
						Push(m_GEvent);
					}
				}
				
				eventData.eventFlags = Events::EVENTS_PROCESSED;
				m_GEvent.Write(eventData.eventFlags, eventData);
				Push(m_GEvent);
				
				return GReturn::SUCCESS;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				SYSTEM::GWindowStyle previousStyle = m_WindowStyle;
				SetInteralData(_x, _y, _width, _height, _style);

				switch (m_WindowStyle)
				{
				case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				{
					XClientMessageEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = ClientMessage;
					ev.window = window;
					ev.message_type = prop_active;
					ev.format = 32;
					ev.data.l[0] = 1;
					ev.data.l[1] = CurrentTime;
					ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;

					if (!XSendEvent(display, RootWindow(display, XDefaultScreen(display)), False,
						SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev))
					{
						return GReturn::FAILURE;
					}

					memset(&hint, 0, sizeof(hint));
					hint.flags = 2;
					hint.decorations = 5;

					if (!XMoveResizeWindow(display, window, m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight))
					{
						return GReturn::FAILURE;
					}

					if (!XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5))
					{
						return GReturn::FAILURE;
					}

					XSizeHints rect;
					memset(&rect, 0, sizeof(rect));
					rect.flags = PMinSize | PMaxSize;
					rect.min_width = rect.min_height = 0;
					rect.max_width = rect.max_height = 0x7FFFFFFF; // max int value
					XSetWMNormalHints(display, window, &rect);
					
					XEvent unMaxEvent;
					unMaxEvent.type = ClientMessage;
					unMaxEvent.xclient.window = window;
					unMaxEvent.xclient.message_type = prop_type;
					unMaxEvent.xclient.format = 32;
					unMaxEvent.xclient.data.l[0] = 0;
					unMaxEvent.xclient.data.l[1] = prop_hMax;
					unMaxEvent.xclient.data.l[2] = prop_vMax;
					unMaxEvent.xclient.data.l[3] = 0;
					unMaxEvent.xclient.data.l[4] = 0;

					if (!XSendEvent(display, DefaultRootWindow(display), False,
						SubstructureNotifyMask | SubstructureRedirectMask, &unMaxEvent))
					{
						return GReturn::FAILURE;
					}
				}
				break;

				case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				{
					XClientMessageEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = ClientMessage;
					ev.window = window;
					ev.message_type = prop_active;
					ev.format = 32;
					ev.data.l[0] = 1;
					ev.data.l[1] = CurrentTime;
					ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;

					if (!XSendEvent(display, RootWindow(display, XDefaultScreen(display)), False,
						SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev))
						return GReturn::FAILURE;

					hint.flags = 2;
					hint.decorations = 0;

					if (!XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5))
						return GReturn::FAILURE;

					if (!XMoveResizeWindow(display, window, m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight))
						return GReturn::FAILURE;

					XSizeHints rect;
					memset(&rect, 0, sizeof(rect));
					rect.flags = PMinSize | PMaxSize;
					rect.min_width = rect.min_height = 0;
					rect.max_width = rect.max_height = 0x7FFFFFFF; // max int value
					XSetWMNormalHints(display, window, &rect);
					
					XEvent unMaxEvent;
					unMaxEvent.type = ClientMessage;
					unMaxEvent.xclient.window = window;
					unMaxEvent.xclient.message_type = prop_type;
					unMaxEvent.xclient.format = 32;
					unMaxEvent.xclient.data.l[0] = 0;
					unMaxEvent.xclient.data.l[1] = prop_hMax;
					unMaxEvent.xclient.data.l[2] = prop_vMax;
					unMaxEvent.xclient.data.l[3] = 0;
					unMaxEvent.xclient.data.l[4] = 0;

					if (!XSendEvent(display, window, False,
						SubstructureNotifyMask | SubstructureRedirectMask, &unMaxEvent))
						return GReturn::FAILURE;
				}
				break;
				
				case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
				{
					XClientMessageEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = ClientMessage;
					ev.window = window;
					ev.message_type = prop_active;
					ev.format = 32;
					ev.data.l[0] = 1;
					ev.data.l[1] = CurrentTime;
					ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;

					if (!XSendEvent(display, RootWindow(display, XDefaultScreen(display)), False,
						SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev))
					{
						return GReturn::FAILURE;
					}

					memset(&hint, 0, sizeof(hint));
					hint.flags = 2;
					hint.decorations = 5;

					if (!XMoveResizeWindow(display, window, m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight))
					{
						return GReturn::FAILURE;
					}

					if (!XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5))
					{
						return GReturn::FAILURE;
					}
					
					XSizeHints rect;
					memset(&rect, 0, sizeof(rect));
					rect.flags = PMinSize | PMaxSize;
					rect.min_width = rect.max_width = m_WindowWidth;
					rect.min_height = rect.max_height = m_WindowHeight;
					XSetWMNormalHints(display, window, &rect);

					XEvent unMaxEvent;
					unMaxEvent.type = ClientMessage;
					unMaxEvent.xclient.window = window;
					unMaxEvent.xclient.message_type = prop_type;
					unMaxEvent.xclient.format = 32;
					unMaxEvent.xclient.data.l[0] = 0;
					unMaxEvent.xclient.data.l[1] = prop_hMax;
					unMaxEvent.xclient.data.l[2] = prop_vMax;
					unMaxEvent.xclient.data.l[3] = 0;
					unMaxEvent.xclient.data.l[4] = 0;

					if (!XSendEvent(display, DefaultRootWindow(display), False,
						SubstructureNotifyMask | SubstructureRedirectMask, &unMaxEvent))
					{
						return GReturn::FAILURE;
					}
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
				{
					XClientMessageEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = ClientMessage;
					ev.window = window;
					ev.message_type = prop_active;
					ev.format = 32;
					ev.data.l[0] = 1;
					ev.data.l[1] = CurrentTime;
					ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;

					if (!XSendEvent(display, RootWindow(display, XDefaultScreen(display)), False,
						SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev))
						return GReturn::FAILURE;

					hint.flags = 2;
					hint.decorations = 5;

					XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5);

					XMapWindow(display, window);
					
					XSizeHints rect;
					memset(&rect, 0, sizeof(rect));
					rect.flags = PMinSize | PMaxSize;
					rect.min_width = rect.min_height = 0;
					rect.max_width = rect.max_height = 0x7FFFFFFF; // max int value
					XSetWMNormalHints(display, window, &rect);
					
					//Tells the server what events to look for with these masks.
					unsigned int eventMask = ResizeRedirectMask | PropertyChangeMask | SubstructureNotifyMask | SubstructureRedirectMask;
					
					//Fill the correct Event structure for the action you performed on the window to update the server side.
					XEvent eventData;
					memset(&eventData, 0, sizeof eventData);
					eventData.type = MapNotify;
					eventData.xmap.send_event = true; //True = that you are going to use XSendEvent to let the server know
					eventData.xmap.display = display;
					eventData.xmap.window = window;

					//Send event to server and wait a bit so it can receive it.
					XSendEvent(display, window, false, eventMask, &eventData);
					
					Screen* screen = DefaultScreenOfDisplay(display);
					if (!XMoveResizeWindow(display, window, 0, 0, screen->width, screen->height))
						return GReturn::FAILURE;
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
				{
					XClientMessageEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = ClientMessage;
					ev.window = window;
					ev.message_type = prop_active;
					ev.format = 32;
					ev.data.l[0] = 1;
					ev.data.l[1] = CurrentTime;
					ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;

					if (!XSendEvent(display, RootWindow(display, XDefaultScreen(display)), False,
						SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev))
						return GReturn::FAILURE;

					hint.flags = 2;
					hint.decorations = 0;

					XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5);

					XMapWindow(display, window);
					
					XSizeHints rect;
					memset(&rect, 0, sizeof(rect));
					rect.flags = PMinSize | PMaxSize;
					rect.min_width = rect.min_height = 0;
					rect.max_width = rect.max_height = 0x7FFFFFFF; // max int value
					XSetWMNormalHints(display, window, &rect);
					
					//Create an event "message" to pass to the server letting it know you Resized the window.
					//Tells the server what events to look for with these masks.
					unsigned int eventMask = ResizeRedirectMask | PropertyChangeMask | SubstructureNotifyMask | SubstructureRedirectMask;

					//Fill the correct Event structure for the action you performed on the window to update the server side.
					XEvent eventData;
					memset(&eventData, 0, sizeof eventData);
					eventData.type = MapNotify;
					eventData.xmap.send_event = true; //True = that you are going to use XSendEvent to let the server know
					eventData.xmap.display = display;
					eventData.xmap.window = window;

					//Send event to server and wait a bit so it can receive it.
					XSendEvent(display, window, false, eventMask, &eventData);
					
					Screen* screen = DefaultScreenOfDisplay(display);
					if (!XMoveResizeWindow(display, window, 0, 0, screen->width, screen->height))
						return GReturn::FAILURE;
				}
				break;

				case SYSTEM::GWindowStyle::MINIMIZED:
				{
					if (!XIconifyWindow(display, window, DefaultScreen(display)))
					{
						//Tells the server what events to look for with these masks.
						unsigned int eventMask = ResizeRedirectMask | PropertyChangeMask | SubstructureNotifyMask | SubstructureRedirectMask;

						//Fill the correct Event structure for the action you performed on the window to update the server side.
						XEvent eventData;
						memset(&eventData, 0, sizeof eventData);
						eventData.type = ClientMessage;
						eventData.xclient.send_event = true; //True = that you are going to use XSendEvent to let the server know
						eventData.xclient.display = display;
						eventData.xclient.window = window;
						eventData.xclient.message_type = prop_hidden;

						//Send event to server and wait a bit so it can receive it.
						XSendEvent(display, window, false, eventMask, &eventData);
						return GReturn::FAILURE;
					}
				}
				break;
				}
				return GReturn::SUCCESS;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				if (_newName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (!windowIsRunning)
					return GReturn::FAILURE;

				return XStoreName(display, window, _newName) != 0 ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				if (!window)
					return GReturn::FAILURE;
				
				if (_argbPixels == nullptr)
					return GReturn::INVALID_ARGUMENT;
				else if (_width <= 0 || _height <= 0)
					return GReturn::INVALID_ARGUMENT;
				
				Atom netWMIcon = XInternAtom(display, "_NET_WM_ICON", false);
				if (!netWMIcon)
					return GReturn::FAILURE;
				
				Atom cardinal = XInternAtom(display, "CARDINAL", false);
				if (!cardinal)
					return GReturn::FAILURE;
				
				const int convertedLength = 2 + _width * _height;
				unsigned long convertedPixels[convertedLength] = { 
					(unsigned long)_width, 
					(unsigned long)_height 
				}; // The pixels array of the icon is prepended with the icon size.
				
				for (int i = 2; i < convertedLength; ++i)
					convertedPixels[i] = (unsigned long)_argbPixels[i - 2];
				
				if (!m_iconPixels)
				{
					m_iconPixelsCount = convertedLength;
					m_iconPixels = new unsigned long[m_iconPixelsCount];
					
					memcpy(m_iconPixels, convertedPixels, sizeof(unsigned long) * m_iconPixelsCount);
				}
				else
				{
					int iconStartIndex = 0;
					int existingIconWidth, existingIconHeight;
					bool iconSizeExists = false;
					
					// Search for an existing icon of the same size.
					while (iconStartIndex < m_iconPixelsCount)
					{
						existingIconWidth = m_iconPixels[iconStartIndex];
						existingIconHeight = m_iconPixels[iconStartIndex + 1];
						
						if (existingIconWidth == _width && existingIconHeight == _height)
						{
							iconSizeExists = true;
							break;
						}
						else
							iconStartIndex += 2 + existingIconWidth * existingIconHeight;
					}
					
					// Overwrite the icon if the same size icon exists.
					if (iconSizeExists)
					{
						for (int i = 2; i < convertedLength; ++i)
							m_iconPixels[iconStartIndex + i] = convertedPixels[i];
					}
					else // Otherwise, append the new icon to the existing array.
					{
						const int tempPixelsCount = m_iconPixelsCount + convertedLength;
						unsigned long* tempPixels = new unsigned long[tempPixelsCount];
						
						memcpy(tempPixels, m_iconPixels, sizeof(unsigned long) * m_iconPixelsCount);
						
						for (int i = 0; i < convertedLength; ++i)
							tempPixels[m_iconPixelsCount + i] = convertedPixels[i];
						
						delete m_iconPixels;
						
						m_iconPixels = tempPixels;
						m_iconPixelsCount = tempPixelsCount;
					}
				}
				
				// The window system will choose the icon whose size is closest to the icon display area. 
				// Icons will automatically be stretched or squashed as needed.
				XChangeProperty(display, window, netWMIcon, cardinal, 32, PropModeReplace, (const unsigned char*)m_iconPixels, m_iconPixelsCount);
				
				return GReturn::SUCCESS;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				SetInteralData(_x, _y, m_WindowWidth, m_WindowHeight, m_WindowStyle);
				if (XMoveWindow(display, window, m_WindowX, m_WindowY))
				{
					//Create an event "message" to pass to the server letting it know you Moved the window.
					//Tells the server what events to look for with these masks.
					unsigned int eventMask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | SubstructureRedirectMask;

					//Fill the correct Event structure for the action you performed on the window to update the server side.
					XEvent eventData;
					memset(&eventData, 0, sizeof eventData);
					eventData.type = ConfigureNotify; //You are changing window position that a config msg.
					eventData.xconfigure.x = m_WindowX;
					eventData.xconfigure.y = m_WindowY;
					eventData.xconfigure.width = m_WindowWidth;
					eventData.xconfigure.height = m_WindowHeight;
					eventData.xconfigure.display = display;
					eventData.xconfigure.window = window;
					eventData.xconfigure.send_event = true; //True = that you are going to use XSendEvent to let the server know
					XSendEvent(display, window, false, eventMask, &eventData);
					return GReturn::SUCCESS;
				}
				return  GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				SetInteralData(m_WindowX, m_WindowY, _width, _height, m_WindowStyle);
				if (XResizeWindow(display, window, m_WindowWidth, m_WindowHeight))
				{
					//Create an event "message" to pass to the server letting it know you Resized the window.
					//Tells the server what events to look for with these masks.
					unsigned int eventMask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | SubstructureRedirectMask;
					//Fill the correct Event structure for the action you performed on the window to update the server side.
					XEvent eventData;
					memset(&eventData, 0, sizeof eventData);
					eventData.type = ConfigureNotify; //You are changing window size that a config msg.
					eventData.xconfigure.x = m_WindowX;
					eventData.xconfigure.y = m_WindowY;
					eventData.xconfigure.width = m_WindowWidth;
					eventData.xconfigure.height = m_WindowHeight;
					eventData.xconfigure.display = display;
					eventData.xconfigure.window = window;
					eventData.xconfigure.send_event = true; //True = that you are going to use XSendEvent to let the server know
					XSendEvent(display, window, false, eventMask, &eventData);
					return GReturn::SUCCESS;
				}
				return  GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				return  GReturn::REDUNDANT;
			}

			GReturn Minimize() override
			{
				return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return ReconfigureWindow(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, _style);
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				Window root;
				int borderSize = 0; int titleBarHeight = 0;
				unsigned int w, h, bord, depth;
				if (!XGetGeometry(display, window, &root, &borderSize, &titleBarHeight, &w, &h, &bord, &depth))
					return GReturn::FAILURE;
				_outWidth = 2 * borderSize + w; //client's width plus the border.
				return  GReturn::SUCCESS;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;
					
				Window root;
				int borderSize = 0; int titleBarHeight = 0;
				unsigned int w, h, bord, depth;
				if (!XGetGeometry(display, window, &root, &borderSize, &titleBarHeight, &w, &h, &bord, &depth))
					return GReturn::FAILURE;
				_outHeight = borderSize + titleBarHeight + h; //Client's height plus border.
				return  GReturn::SUCCESS;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				Window root;
				int x, y;
				unsigned int w, h, bord, depth;
				if (!XGetGeometry(display, window, &root, &x, &y, &w, &h, &bord, &depth))
					return GReturn::FAILURE;
				_outClientWidth = w; //The width filled out is the client's width.
				return  GReturn::SUCCESS;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				Window root;
				int x, y;
				unsigned int w, h, bord, depth;
				if (!XGetGeometry(display, window, &root, &x, &y, &w, &h, &bord, &depth))
					return GReturn::FAILURE;
				_outClientHeight = h; //The width filled out is the client's width.
				return GReturn::SUCCESS;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				int x, y;
				Window child;
				XWindowAttributes windowAttributes;
				XTranslateCoordinates( display, window, XDefaultRootWindow(display), 0, 0, &x, &y, &child );
				XGetWindowAttributes( display, window, &windowAttributes );
				_outX = x - windowAttributes.x;
				return  GReturn::SUCCESS;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				int x, y;
				Window child;
				XWindowAttributes windowAttributes;
				XTranslateCoordinates( display, window, XDefaultRootWindow(display), 0, 0, &x, &y, &child );
				XGetWindowAttributes( display, window, &windowAttributes );
				_outY = y - windowAttributes.y;
				return  GReturn::SUCCESS;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				Window root;
				int x, y;
				unsigned int w, h, bord, depth;
				if (!XGetGeometry(display, window, &root, &x, &y, &w, &h, &bord, &depth))
					return GReturn::FAILURE;
				_outX = x;
				_outY = y + bord;
				return  GReturn::SUCCESS;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
			{
				if (!windowIsRunning)
					return GReturn::FAILURE;

				_outUniversalWindowHandle.window = (void*)(&window);
				_outUniversalWindowHandle.display = (void*)(display);
				return  GReturn::SUCCESS;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				if (!windowIsRunning)
					return  GReturn::FAILURE;

				unsigned int height = 0;
				unsigned int width = 0;
				unsigned int xMax = 0;
				unsigned int yMax = 0;
				int borderHeight = 0;
				int resizeBarHeight = 0;

				Screen* scr = DefaultScreenOfDisplay(display);
				xMax = scr->width;
				yMax = scr->height;

				//Testing using XGetWindowAttributes for checking if full screen
				XWindowAttributes temp;
				XGetWindowAttributes(display, window, &temp);
				int tempBW = temp.border_width;
				int tempW = temp.width + tempBW;
				int tempH = temp.height + tempBW;

				if (tempW == xMax && tempH == yMax)
					_outIsFullscreen = true;
				else
					_outIsFullscreen = false;
				return GReturn::SUCCESS;
			}

			GReturn IsFocus(bool& _outIsFocus) const override
			{
				if (!windowIsRunning)
					return  GReturn::FAILURE;
				int revert;
				Window focus;
				XGetInputFocus(display, &focus, &revert);
				_outIsFocus = (window == focus);
				return GReturn::SUCCESS;
			}
		};
	}
}


#elif defined(_WIN32)
    #define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <string>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 1
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 2
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'a'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "development"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x6d438ef0d0
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v1.2a"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v1.2a (development) [6d438ef0d0]"

#endif



namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		private:
			HWND wndHandle = nullptr;
			std::wstring className;
			bool destroyEventIsSentByWndProc = false;
			int m_WindowX = -1;
			int m_WindowY = -1;
			int m_WindowWidth = -1;
			int m_WindowHeight = -1;
			SYSTEM::GWindowStyle m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERED;

			GEvent m_GEvent;
			EVENT_DATA m_EventData;

			HICON m_IconSmall = NULL;
			HICON m_IconBig = NULL;

			void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				m_WindowWidth = _width;
				m_WindowHeight = _height;
				m_WindowX = _x;
				m_WindowY = _y;
				m_WindowStyle = _style;
			}

			LRESULT DispatchEventAndData(UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);

				switch (uMsg)
				{
				case WM_SIZE:
				{
					m_EventData.eventFlags = Events::NON_EVENT;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = (unsigned int)HIWORD(lParam);
					m_EventData.clientWidth = (unsigned int)LOWORD(lParam);
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					switch (wParam)
					{
					case SIZE_MAXIMIZED: { m_EventData.eventFlags = Events::MAXIMIZE; } break;
					case SIZE_MINIMIZED: { m_EventData.eventFlags = Events::MINIMIZE; } break;
					case SIZE_RESTORED: { m_EventData.eventFlags = Events::RESIZE; } break;
					}

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				break;

				case WM_MOVE:
				{
					RECT clientRect;
					::GetClientRect(wndHandle, &clientRect);

					m_EventData.eventFlags = Events::MOVE;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				break;

				case WM_CLOSE:
				{
					RECT clientRect;
					::GetClientRect(wndHandle, &clientRect);

					m_EventData.eventFlags = Events::DESTROY;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
					destroyEventIsSentByWndProc = true;
				}
				break;

				case WM_DESTROY: { ::PostQuitMessage(0); } break;
				default: { return ::DefWindowProc(wndHandle, uMsg, wParam, lParam); }
				}
				return ::DefWindowProc(wndHandle, uMsg, wParam, lParam);
			}

			static LRESULT CALLBACK GWindowProcedure(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				GWindowImplementation* self;
				if (uMsg == WM_NCCREATE)
				{
					LPCREATESTRUCT lpcs = reinterpret_cast<LPCREATESTRUCT>(lParam);
					self = reinterpret_cast<GWindowImplementation*>(lpcs->lpCreateParams);
					self->wndHandle = hwnd;
					::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LPARAM>(self));
				}
				else
				{
					self = reinterpret_cast<GWindowImplementation*>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
				}
				if (self)
				{
					return self->DispatchEventAndData(uMsg, wParam, lParam);
				}
				else
				{
					return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
				}
			}

			GReturn OpenWindow()
			{
				if (wndHandle)
					return GReturn::REDUNDANT;

				auto hasGUI = GetDesktopWindow();
				if (!hasGUI)
					return GReturn::INTERFACE_UNSUPPORTED;

				destroyEventIsSentByWndProc = false;
				WNDCLASSEX winClass;
				ZeroMemory(&winClass, sizeof(WNDCLASSEX));

				// Generate random string based on a given length. This is because if the end-user want to create multiple GWindow instances,
				// class name have to be unique to the GWindow.
				auto randomString = [](size_t length) -> std::string
				{
					auto randchar = []() -> char
					{
						const char charset[] =
							"0123456789"
							"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
							"abcdefghijklmnopqrstuvwxyz";
						const size_t max_index = (sizeof(charset) - 1);
						return charset[rand() % max_index];
					};
					std::string str(length, 0);
					std::generate_n(str.begin(), length, randchar);
					return str;
				};
				std::string randName = randomString(9);
				std::wstring wcharName = L"GatewareWindow:";
				wcharName += std::wstring(randName.begin(), randName.end());
				className = std::move(wcharName);

				// Icon members are not set to the default icon (IDI_APPLICATION) because shared icons should not be destroyed.
				ZeroMemory(&m_IconSmall, sizeof(HICON));
				m_IconSmall = NULL;
				ZeroMemory(&m_IconBig, sizeof(HICON));
				m_IconBig = NULL;

				winClass.cbSize = sizeof(WNDCLASSEX);
				winClass.hbrBackground = (HBRUSH)COLOR_WINDOW;
				winClass.hCursor = LoadCursorW(NULL, IDC_ARROW);
				winClass.hIcon = LoadIconW(0, IDI_APPLICATION);
				winClass.lpfnWndProc = GWindowProcedure;
				winClass.lpszClassName = className.data();
				winClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
				winClass.hInstance = GetModuleHandleW(0);

				if (!::RegisterClassExW(&winClass))
				{
					::printf("RegisterClassExW Error : %d \n", GetLastError());
					return GReturn::INTERFACE_UNSUPPORTED;
				}

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0) // Creates a rect for a window frame that can fit the desired client size.
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

#ifndef NDEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
				wndHandle = ::CreateWindowW(className.data(), L"" GATEWARE_WINDOW_NAME, windowsStyle, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, NULL, NULL, GetModuleHandleW(0), this);
#undef GATEWARE_WINDOW_NAME

				if (wndHandle && (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS))
				{
					if (::ShowWindow(wndHandle, SW_MAXIMIZE) != 0)
					{
						::printf("ShowWindow Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}
					else
					{
						return GReturn::SUCCESS;
					}
				}
				else if (wndHandle && m_WindowStyle != SYSTEM::GWindowStyle::MINIMIZED)
				{
					if (::ShowWindow(wndHandle, SW_SHOWDEFAULT) != 0)
					{
						::printf("ShowWindow Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}
					else
					{
						return GReturn::SUCCESS;
					}
				}
				else if (wndHandle && m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
				{
					::ShowWindow(wndHandle, SW_MINIMIZE);
					return GReturn::SUCCESS;
				}
				return GReturn::FAILURE;
			}

			DWORD GetWindowsStyle(GW::SYSTEM::GWindowStyle _style)
			{
				switch (m_WindowStyle)
				{
				case GW::SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				case GW::SYSTEM::GWindowStyle::FULLSCREENBORDERED:
					return WS_OVERLAPPEDWINDOW;

				case GW::SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				case GW::SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
					return WS_POPUP;

				case GW::SYSTEM::GWindowStyle::MINIMIZED:
					return WS_MINIMIZE;

				case GW::SYSTEM::GWindowStyle::WINDOWEDLOCKED:
					return  WS_OVERLAPPEDWINDOW ^ WS_SIZEBOX ^ WS_MAXIMIZEBOX;
				}
				return 0;
			}

		public:
			~GWindowImplementation()
			{
				if (!destroyEventIsSentByWndProc)
				{
					if (m_IconBig)
						DestroyIcon(m_IconBig);

					if (m_IconSmall)
						DestroyIcon(m_IconSmall);

					RECT windowRect = { 0,0,0,0 };
					RECT clientRect = { 0,0,0,0 };
					if (wndHandle)
					{
						::GetWindowRect(wndHandle, &windowRect);
						::GetClientRect(wndHandle, &clientRect);
					}

					m_EventData.eventFlags = Events::DESTROY;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				if (!wndHandle)
					return;
				::SetWindowLongPtr(wndHandle, GWLP_USERDATA, reinterpret_cast<LPARAM>(nullptr));
				::DestroyWindow(wndHandle);
				wndHandle = nullptr;
				if (!::UnregisterClassW(className.data(), GetModuleHandleW(0)))
				{
					::printf("UnregisterClassW Error Message : %d \n", GetLastError());
				}
			}

			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				this->SetInteralData(_x, _y, _width, _height, _style);
				return OpenWindow();
			}

			GReturn ProcessWindowEvents() override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				if (destroyEventIsSentByWndProc)
					return GReturn::FAILURE;

				MSG msg;
				ZeroMemory(&msg, sizeof(MSG));
				// Processes all messages in the current queue 
				while (PeekMessage(&msg, wndHandle, 0, 0, PM_REMOVE))
				{
					//Translate messages
					TranslateMessage(&msg);
					//Send to WindowProc
					DispatchMessage(&msg);
				}

				m_EventData.eventFlags = Events::EVENTS_PROCESSED;
				m_GEvent.Write(m_EventData.eventFlags, m_EventData);
				Push(m_GEvent);

				return GReturn::SUCCESS;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				SYSTEM::GWindowStyle previousStyle = m_WindowStyle;
				SetInteralData(_x, _y, _width, _height, _style);

				switch (m_WindowStyle)
				{
				case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE); // Restore the window prior to making changes to it. Otherwise, they may not take effect.

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW | SWP_FRAMECHANGED);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDBORDERED);
				}
				break;

				case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE);

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDBORDERLESS);
				}
				break;

				case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE);

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW | SWP_FRAMECHANGED);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDLOCKED);
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
				{
					RECT windowRect;
					::GetWindowRect(wndHandle, &windowRect);

					::SetWindowLongPtr(wndHandle, GWL_STYLE, WS_OVERLAPPEDWINDOW);
					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, windowRect.left, windowRect.top, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SWP_NOREDRAW);
					if (winRet == 0)
						return  GReturn::FAILURE;

					::ShowWindow(wndHandle, SW_MAXIMIZE);
					::GetWindowRect(wndHandle, &windowRect);
					SetInteralData(0, 0, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
				{
					RECT windowRect;
					::GetWindowRect(wndHandle, &windowRect);

					::SetWindowLongPtr(wndHandle, GWL_STYLE, WS_POPUP);
					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, windowRect.left, windowRect.top, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SWP_NOREDRAW);
					if (winRet == 0)
						return  GReturn::FAILURE;

					::ShowWindow(wndHandle, SW_MAXIMIZE);
					::GetWindowRect(wndHandle, &windowRect);
					SetInteralData(0, 0, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				}
				break;

				case SYSTEM::GWindowStyle::MINIMIZED:
				{
					::ShowWindow(wndHandle, SW_MINIMIZE);
					SetInteralData(0, 0, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::MINIMIZED);
				}
				break;
				}
				return  GReturn::SUCCESS;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				if (_newName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (wndHandle == nullptr)
					return GReturn::FAILURE;

				return ::SetWindowTextW(wndHandle, INTERNAL::G_TO_UTF16(_newName).c_str()) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				if (_argbPixels == nullptr)
					return GReturn::INVALID_ARGUMENT;
				else if (_width <= 0 || _height <= 0)
					return GReturn::INVALID_ARGUMENT;

				const bool usingBigIcon = _width > 16 || _height > 16;

				if (usingBigIcon)
				{
					if (m_IconBig)
					{
						DestroyIcon(m_IconBig);
						ZeroMemory(&m_IconBig, sizeof(HICON));
					}
				}
				else
				{
					if (m_IconSmall)
					{
						DestroyIcon(m_IconSmall);
						ZeroMemory(&m_IconSmall, sizeof(HICON));
					}
				}

				ICONINFO iconInfo = { TRUE, NULL, NULL, NULL, NULL };

				iconInfo.hbmColor = CreateBitmap(_width, _height, 1, 32, _argbPixels);
				if (!iconInfo.hbmColor)
					return GReturn::FAILURE;

				HDC dc = GetDC(wndHandle);
				iconInfo.hbmMask = CreateCompatibleBitmap(dc, _width, _height);
				DeleteDC(dc);

				if (!iconInfo.hbmMask)
					return GReturn::FAILURE;

				if (usingBigIcon)
				{
					m_IconBig = CreateIconIndirect(&iconInfo);

					if (!m_IconBig)
					{
						ZeroMemory(&m_IconBig, sizeof(HICON));
						return GReturn::FAILURE;
					}

					SendMessage(wndHandle, WM_SETICON, ICON_BIG, (LPARAM)m_IconBig);

					// This fixes a few issues that occur if m_IconSmall icon is set.
					if (m_IconSmall)
					{						
						SendMessage(wndHandle, WM_SETICON, ICON_SMALL, NULL); // Needed so the taskbar icon will change to m_IconBig.
						SendMessage(wndHandle, WM_SETICON, ICON_SMALL, (LPARAM)m_IconSmall); // Needed to keep the window icon as m_IconSmall.
					}
				}
				else
				{
					m_IconSmall = CreateIconIndirect(&iconInfo);

					if (!m_IconSmall)
					{
						ZeroMemory(&m_IconSmall, sizeof(HICON));
						return GReturn::FAILURE;
					}

					SendMessage(wndHandle, WM_SETICON, ICON_SMALL, (LPARAM)m_IconSmall);
				}

				return GReturn::SUCCESS;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				SetInteralData(_x, _y, m_WindowWidth, m_WindowHeight, m_WindowStyle);
				return ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, _width, _height };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				SetInteralData(m_WindowX, m_WindowY, _width, _height, m_WindowStyle);
				return ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || 
					m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED || 
					m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				return GReturn::REDUNDANT;
			}

			GReturn Minimize() override
			{
				return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return ReconfigureWindow(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, _style);
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outWidth = windowRect.right - windowRect.left;
				return  GReturn::SUCCESS;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outHeight = windowRect.bottom - windowRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT clientRect;
				::GetClientRect(wndHandle, &clientRect);
				_outClientWidth = clientRect.right - clientRect.left;
				return GReturn::SUCCESS;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT clientRect;
				::GetClientRect(wndHandle, &clientRect);
				_outClientHeight = clientRect.bottom - clientRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outX = windowRect.left;
				return GReturn::SUCCESS;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outY = windowRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				POINT clientAreaTopLeft = { 0, 0 };
				::ClientToScreen(wndHandle, &clientAreaTopLeft);
				_outX = clientAreaTopLeft.x;
				_outY = clientAreaTopLeft.y;
				return GReturn::SUCCESS;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				_outUniversalWindowHandle.window = wndHandle;
				_outUniversalWindowHandle.display = nullptr;
				return GReturn::SUCCESS;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				unsigned int height = 0;
				unsigned int width = 0;
				int mainWindowWidth = 0;
				int mainWindowHeight = 0;
				int borderHeight = 0;
				int resizeBarWidth = 0;
				int resizeBarHeight = 0;

				if (G_FAIL(GetWidth(width)) || G_FAIL(GetHeight(height)))
				{
					return GReturn::FAILURE;
				}
				// mainWindowWidth and mainWindowHeight does not refer to application window,
				// but the main desktop window
				mainWindowWidth = ::GetSystemMetrics(SM_CXFULLSCREEN);
				mainWindowHeight = ::GetSystemMetrics(SM_CYFULLSCREEN);
				borderHeight = ::GetSystemMetrics(SM_CYCAPTION);
				resizeBarWidth = ::GetSystemMetrics(SM_CXBORDER);
				resizeBarHeight = ::GetSystemMetrics(SM_CYBORDER);

				if (((int)width + resizeBarWidth) >= mainWindowWidth && ((int)height + borderHeight + resizeBarHeight) >= mainWindowHeight)
					_outIsFullscreen = true;
				else
					_outIsFullscreen = false;

				return GReturn::SUCCESS;
			}

			GReturn IsFocus(bool& _outIsFocus) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;
				// determine if HWND is the foreground window
				_outIsFocus = (wndHandle == GetForegroundWindow());
				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GWindow final
			: public I::GProxy<I::GWindowInterface, I::GWindowImplementation, int, int, int, int, GW::SYSTEM::GWindowStyle>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GWindow)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(ProcessWindowEvents)
			GATEWARE_FUNCTION(ReconfigureWindow)
			GATEWARE_FUNCTION(SetWindowName)
			GATEWARE_FUNCTION(SetIcon)
			GATEWARE_FUNCTION(MoveWindow)
			GATEWARE_FUNCTION(ResizeWindow)
			GATEWARE_FUNCTION(Maximize)
			GATEWARE_FUNCTION(Minimize)
			GATEWARE_FUNCTION(ChangeWindowStyle)
			GATEWARE_CONST_FUNCTION(GetWidth)
			GATEWARE_CONST_FUNCTION(GetHeight)
			GATEWARE_CONST_FUNCTION(GetClientWidth)
			GATEWARE_CONST_FUNCTION(GetClientHeight)
			GATEWARE_CONST_FUNCTION(GetX)
			GATEWARE_CONST_FUNCTION(GetY)
			GATEWARE_CONST_FUNCTION(GetClientTopLeft)
			GATEWARE_CONST_FUNCTION(GetWindowHandle)
			GATEWARE_CONST_FUNCTION(IsFullscreen)
			GATEWARE_CONST_FUNCTION(IsFocus)

			// reimplemented functions from GEventGenerator
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)
			

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
}
#endif // GWINDOW_H

/*---------------------------------
|	End of GWindow.h
----------------------------------*/


/*---------------------------------
|	Begin of GVector.h
----------------------------------*/
#ifndef GVECTOR_H
#define GVECTOR_H





namespace GW
{
	namespace I
	{
		class GVectorInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GVector.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GVECTOR) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GVECTOR) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GVectorImplementation : public virtual GVectorInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			//float vector
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD) 
			{
				return GReturn::FAILURE; 
			}

			//double vector
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector) 
			{
				return GReturn::FAILURE;
			}
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF) 
			{
				return GReturn::FAILURE; 
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GVectorImplementation : public virtual GVectorInterface,
			private GInterfaceImplementation
		{
		public:

			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			//float vector
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;
				_outVector.w = _vector1.w + _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;
				_outVector.w = _vector1.w - _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;
				_outVector.w = _scalar * _vector.w;

				return GReturn::SUCCESS;
			}
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z) + (_vector1.w * _vector2.w);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v1 = _vector1;
				MATH::GVECTORF _v2 = _vector2;
				_outVector.x = (_v1.y * _v2.z) - (_v1.z * _v2.y);
				_outVector.y = (_v1.z * _v2.x) - (_v1.x * _v2.z);
				_outVector.z = (_v1.x * _v2.y) - (_v1.y * _v2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v = _vector;

				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * _matrix.row4.x);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * _matrix.row4.y);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * _matrix.row4.z);
				_outVector.w = (_v.x * _matrix.row1.w) + (_v.y * _matrix.row2.w) + (_v.z * _matrix.row3.w) + (_v.w * _matrix.row4.w);

				return GReturn::SUCCESS;
			}
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v = _vector;

				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * 0.0f);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * 0.0f);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * 0.0f);
				_outVector.w = 1.0f;

				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrtf((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z) + (_vector.w * _vector.w));
				if(G_COMPARISON_STANDARD_F( _outMagnitude, 0 ))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector)
			{
				float magnitude = 0.0f;
				if(MagnitudeF( _vector, magnitude ) != GReturn::SUCCESS)
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;
				_outVector.w = _vector.w / magnitude;

				return GReturn::SUCCESS;
			}
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector)
			{
				_outVector.x = G_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G_LERP(_vector1.z, _vector2.z, _ratio);
				_outVector.w = G_LERP(_vector1.w, _vector2.w, _ratio);

				return GReturn::SUCCESS;
			}
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF p0 = _vector1;
				MATH::GVECTORF p1 = _vector2;
				MATH::GVECTORF p2 = _vector3;
				MATH::GVECTORF p3 = _vector4;

				float t0 = 0.0f;
				float t1 = powf(sqrtf(powf((p1.x - p0.x), 2) + powf((p1.y - p0.y), 2) + powf((p1.z - p0.z), 2)), 0.5f) + t0;
				float t2 = powf(sqrtf(powf((p2.x - p1.x), 2) + powf((p2.y - p1.y), 2) + powf((p2.z - p1.z), 2)), 0.5f) + t1;
				float t3 = powf(sqrtf(powf((p3.x - p2.x), 2) + powf((p3.y - p2.y), 2) + powf((p3.z - p2.z), 2)), 0.5f) + t2;

				MATH::GVECTORF A1;
				MATH::GVECTORF A2;
				MATH::GVECTORF A3;
				MATH::GVECTORF B1;
				MATH::GVECTORF B2;

				float t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 3; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}
				_outVector.w = 0;

				return GReturn::SUCCESS;
			}
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD)
			{
				_outVectorD.x = static_cast<double>(_vectorF.x);
				_outVectorD.y = static_cast<double>(_vectorF.y);
				_outVectorD.z = static_cast<double>(_vectorF.z);
				_outVectorD.w = static_cast<double>(_vectorF.w);

				return GReturn::SUCCESS;
			}





			//double vector
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;
				_outVector.w = _vector1.w + _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;
				_outVector.w = _vector1.w - _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;
				_outVector.w = _scalar * _vector.w;

				return GReturn::SUCCESS;
			}
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z) + (_vector1.w * _vector2.w);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v1 = _vector1;
				MATH::GVECTORD _v2 = _vector2;
				_outVector.x = (_v1.y * _v2.z) - (_v1.z * _v2.y);
				_outVector.y = (_v1.z * _v2.x) - (_v1.x * _v2.z);
				_outVector.z = (_v1.x * _v2.y) - (_v1.y * _v2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v = _vector;
				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * _matrix.row4.x);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * _matrix.row4.y);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * _matrix.row4.z);
				_outVector.w = (_v.x * _matrix.row1.w) + (_v.y * _matrix.row2.w) + (_v.z * _matrix.row3.w) + (_v.w * _matrix.row4.w);

				return GReturn::SUCCESS;
			}
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v = _vector;
				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * 0.0f);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * 0.0f);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * 0.0f);
				_outVector.w = 1.0;

				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z) + (_vector.w * _vector.w));
				if (G_COMPARISON_STANDARD_D(_outMagnitude, 0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector)
			{
				double magnitude = 0.0;
				if (MagnitudeD(_vector, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;
				_outVector.w = _vector.w / magnitude;

				return GReturn::SUCCESS;
			}
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector)
			{
				_outVector.x = G_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G_LERP(_vector1.z, _vector2.z, _ratio);
				_outVector.w = G_LERP(_vector1.w, _vector2.w, _ratio);

				return GReturn::SUCCESS;
			}
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD p0 = _vector1;
				MATH::GVECTORD p1 = _vector2;
				MATH::GVECTORD p2 = _vector3;
				MATH::GVECTORD p3 = _vector4;

				double t0 = 0.0;
				double t1 = t1 = pow(sqrt(pow((p1.x - p0.x), 2.0) + pow((p1.y - p0.y), 2.0) + pow((p1.z - p0.z), 2.0)), 0.5) + t0;
				double t2 = t2 = pow(sqrt(pow((p2.x - p1.x), 2.0) + pow((p2.y - p1.y), 2.0) + pow((p2.z - p1.z), 2.0)), 0.5) + t1;
				double t3 = t3 = pow(sqrt(pow((p3.x - p2.x), 2.0) + pow((p3.y - p2.y), 2.0) + pow((p3.z - p2.z), 2.0)), 0.5) + t2;

				MATH::GVECTORD A1;
				MATH::GVECTORD A2;
				MATH::GVECTORD A3;
				MATH::GVECTORD B1;
				MATH::GVECTORD B2;

				double t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 3; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}
				_outVector.w = 0;
				return GReturn::SUCCESS;
			}
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF)
			{
				_outVectorF.x = static_cast<float>(_vectorD.x);
				_outVectorF.y = static_cast<float>(_vectorD.y);
				_outVectorF.z = static_cast<float>(_vectorD.z);
				_outVectorF.w = static_cast<float>(_vectorD.w);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH
	{
		class GVector final
			: public I::GProxy<I::GVectorInterface, I::GVectorImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVector)
			GATEWARE_STATIC_FUNCTION(AddVectorF)
			GATEWARE_STATIC_FUNCTION(SubtractVectorF)
			GATEWARE_STATIC_FUNCTION(ScaleF)
			GATEWARE_STATIC_FUNCTION(DotF)
			GATEWARE_STATIC_FUNCTION(CrossVector2F)
			GATEWARE_STATIC_FUNCTION(CrossVector3F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixF)
			GATEWARE_STATIC_FUNCTION(TransformF)
			GATEWARE_STATIC_FUNCTION(MagnitudeF)
			GATEWARE_STATIC_FUNCTION(NormalizeF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(SplineF)
			GATEWARE_STATIC_FUNCTION(Upgrade)

			// doubles
			GATEWARE_STATIC_FUNCTION(AddVectorD)
			GATEWARE_STATIC_FUNCTION(SubtractVectorD)
			GATEWARE_STATIC_FUNCTION(ScaleD)
			GATEWARE_STATIC_FUNCTION(DotD)
			GATEWARE_STATIC_FUNCTION(CrossVector2D)
			GATEWARE_STATIC_FUNCTION(CrossVector3D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixD)
			GATEWARE_STATIC_FUNCTION(TransformD)
			GATEWARE_STATIC_FUNCTION(MagnitudeD)
			GATEWARE_STATIC_FUNCTION(NormalizeD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(SplineD)
			GATEWARE_STATIC_FUNCTION(Downgrade)
				
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVECTOR_H

/*---------------------------------
|	End of GVector.h
----------------------------------*/


/*---------------------------------
|	Begin of GMatrix.h
----------------------------------*/
#ifndef GMATRIX_H
#define GMATRIX_H





namespace GW
{
	namespace I
	{
		class GMatrixInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) { return GReturn::NO_IMPLEMENTATION; }

			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}// end CORE namespace
}// end GW namespace

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GMatrix.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GMATRIX) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GMATRIX) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{

		class GMatrixImplementation : public virtual GMatrixInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create() { return GReturn::FEATURE_UNSUPPORTED; }
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue) { return GReturn::FAILURE; }
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion) { return GReturn::FAILURE; }
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) { return GReturn::FAILURE; }

			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue) { return GReturn::FAILURE; }
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion) { return GReturn::FAILURE; }
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::FAILURE; }
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::FAILURE; }
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GMatrixImplementation : public virtual GMatrixInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] + _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] - _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;

				_outMatrix.data[0] = _m1.data[0] * _m2.data[0] + _m1.data[1] * _m2.data[4] + _m1.data[2] * _m2.data[8] + _m1.data[3] * _m2.data[12];
				_outMatrix.data[1] = _m1.data[0] * _m2.data[1] + _m1.data[1] * _m2.data[5] + _m1.data[2] * _m2.data[9] + _m1.data[3] * _m2.data[13];
				_outMatrix.data[2] = _m1.data[0] * _m2.data[2] + _m1.data[1] * _m2.data[6] + _m1.data[2] * _m2.data[10] + _m1.data[3] * _m2.data[14];
				_outMatrix.data[3] = _m1.data[0] * _m2.data[3] + _m1.data[1] * _m2.data[7] + _m1.data[2] * _m2.data[11] + _m1.data[3] * _m2.data[15];

				_outMatrix.data[4] = _m1.data[4] * _m2.data[0] + _m1.data[5] * _m2.data[4] + _m1.data[6] * _m2.data[8] + _m1.data[7] * _m2.data[12];
				_outMatrix.data[5] = _m1.data[4] * _m2.data[1] + _m1.data[5] * _m2.data[5] + _m1.data[6] * _m2.data[9] + _m1.data[7] * _m2.data[13];
				_outMatrix.data[6] = _m1.data[4] * _m2.data[2] + _m1.data[5] * _m2.data[6] + _m1.data[6] * _m2.data[10] + _m1.data[7] * _m2.data[14];
				_outMatrix.data[7] = _m1.data[4] * _m2.data[3] + _m1.data[5] * _m2.data[7] + _m1.data[6] * _m2.data[11] + _m1.data[7] * _m2.data[15];

				_outMatrix.data[8] = _m1.data[8] * _m2.data[0] + _m1.data[9] * _m2.data[4] + _m1.data[10] * _m2.data[8] + _m1.data[11] * _m2.data[12];
				_outMatrix.data[9] = _m1.data[8] * _m2.data[1] + _m1.data[9] * _m2.data[5] + _m1.data[10] * _m2.data[9] + _m1.data[11] * _m2.data[13];
				_outMatrix.data[10] = _m1.data[8] * _m2.data[2] + _m1.data[9] * _m2.data[6] + _m1.data[10] * _m2.data[10] + _m1.data[11] * _m2.data[14];
				_outMatrix.data[11] = _m1.data[8] * _m2.data[3] + _m1.data[9] * _m2.data[7] + _m1.data[10] * _m2.data[11] + _m1.data[11] * _m2.data[15];

				_outMatrix.data[12] = _m1.data[12] * _m2.data[0] + _m1.data[13] * _m2.data[4] + _m1.data[14] * _m2.data[8] + _m1.data[15] * _m2.data[12];
				_outMatrix.data[13] = _m1.data[12] * _m2.data[1] + _m1.data[13] * _m2.data[5] + _m1.data[14] * _m2.data[9] + _m1.data[15] * _m2.data[13];
				_outMatrix.data[14] = _m1.data[12] * _m2.data[2] + _m1.data[13] * _m2.data[6] + _m1.data[14] * _m2.data[10] + _m1.data[15] * _m2.data[14];
				_outMatrix.data[15] = _m1.data[12] * _m2.data[3] + _m1.data[13] * _m2.data[7] + _m1.data[14] * _m2.data[11] + _m1.data[15] * _m2.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector)
			{
				GW::MATH::GVECTORF _v = _vector;

				_outVector.x = _v.data[0] * _matrix.data[0] + _v.data[1] * _matrix.data[4] + _v.data[2] * _matrix.data[8] + _v.data[3] * _matrix.data[12];
				_outVector.y = _v.data[0] * _matrix.data[1] + _v.data[1] * _matrix.data[5] + _v.data[2] * _matrix.data[9] + _v.data[3] * _matrix.data[13];
				_outVector.z = _v.data[0] * _matrix.data[2] + _v.data[1] * _matrix.data[6] + _v.data[2] * _matrix.data[10] + _v.data[3] * _matrix.data[14];
				_outVector.w = _v.data[0] * _matrix.data[3] + _v.data[1] * _matrix.data[7] + _v.data[2] * _matrix.data[11] + _v.data[3] * _matrix.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix)
			{
				float xx2 = 2 * _quaternion.x * _quaternion.x;
				float yy2 = 2 * _quaternion.y * _quaternion.y;
				float zz2 = 2 * _quaternion.z * _quaternion.z;

				float xy2 = 2 * _quaternion.x * _quaternion.y;
				float xz2 = 2 * _quaternion.x * _quaternion.z;
				float yz2 = 2 * _quaternion.y * _quaternion.z;

				float wx2 = 2 * _quaternion.w * _quaternion.x;
				float wy2 = 2 * _quaternion.w * _quaternion.y;
				float wz2 = 2 * _quaternion.w * _quaternion.z;

				_outMatrix.data[0] = 1.0f - yy2 - zz2;
				_outMatrix.data[1] = xy2 - wz2;
				_outMatrix.data[2] = xz2 + wy2;
				_outMatrix.data[3] = 0.0f;
				_outMatrix.data[4] = xy2 + wz2;
				_outMatrix.data[5] = 1.0f - xx2 - zz2;
				_outMatrix.data[6] = yz2 - wx2;
				_outMatrix.data[7] = 0.0f;
				_outMatrix.data[8] = xz2 - wy2;
				_outMatrix.data[9] = yz2 + wx2;
				_outMatrix.data[10] = 1.0f - xx2 - yy2;
				_outMatrix.data[11] = 0.0f;
				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m.data[i] * _scalar;
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue)
			{
				float a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				float a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				float a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				float a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				float a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				float a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				float b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				float b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				float b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				float b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				float b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				float b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				_outValue = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				_outMatrix.data[0] = _m.data[0];
				_outMatrix.data[1] = _m.data[4];
				_outMatrix.data[2] = _m.data[8];
				_outMatrix.data[3] = _m.data[12];
				_outMatrix.data[4] = _m.data[1];
				_outMatrix.data[5] = _m.data[5];
				_outMatrix.data[6] = _m.data[9];
				_outMatrix.data[7] = _m.data[13];
				_outMatrix.data[8] = _m.data[2];
				_outMatrix.data[9] = _m.data[6];
				_outMatrix.data[10] = _m.data[10];
				_outMatrix.data[11] = _m.data[14];
				_outMatrix.data[12] = _m.data[3];
				_outMatrix.data[13] = _m.data[7];
				_outMatrix.data[14] = _m.data[11];
				_outMatrix.data[15] = _m.data[15];
				return GW::GReturn::SUCCESS;
			}
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				float det;
				float a0 = _m.data[0] * _m.data[5] - _m.data[1] * _m.data[4];
				float a1 = _m.data[0] * _m.data[6] - _m.data[2] * _m.data[4];
				float a2 = _m.data[0] * _m.data[7] - _m.data[3] * _m.data[4];
				float a3 = _m.data[1] * _m.data[6] - _m.data[2] * _m.data[5];
				float a4 = _m.data[1] * _m.data[7] - _m.data[3] * _m.data[5];
				float a5 = _m.data[2] * _m.data[7] - _m.data[3] * _m.data[6];
				float b0 = _m.data[8] * _m.data[13] - _m.data[9] * _m.data[12];
				float b1 = _m.data[8] * _m.data[14] - _m.data[10] * _m.data[12];
				float b2 = _m.data[8] * _m.data[15] - _m.data[11] * _m.data[12];
				float b3 = _m.data[9] * _m.data[14] - _m.data[10] * _m.data[13];
				float b4 = _m.data[9] * _m.data[15] - _m.data[11] * _m.data[13];
				float b5 = _m.data[10] * _m.data[15] - _m.data[11] * _m.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
				if(G_COMPARISON_STANDARD_F(det, 0.0f))
				{
					return GW::GReturn::FAILURE;
				}
				_outMatrix.data[0] = _m.data[5] * b5 - _m.data[6] * b4 + _m.data[7] * b3;
				_outMatrix.data[1] = -_m.data[1] * b5 + _m.data[2] * b4 - _m.data[3] * b3;
				_outMatrix.data[2] = _m.data[13] * a5 - _m.data[14] * a4 + _m.data[15] * a3;
				_outMatrix.data[3] = -_m.data[9] * a5 + _m.data[10] * a4 - _m.data[11] * a3;

				_outMatrix.data[4] = -_m.data[4] * b5 + _m.data[6] * b2 - _m.data[7] * b1;
				_outMatrix.data[5] = _m.data[0] * b5 - _m.data[2] * b2 + _m.data[3] * b1;
				_outMatrix.data[6] = -_m.data[12] * a5 + _m.data[14] * a2 - _m.data[15] * a1;
				_outMatrix.data[7] = _m.data[8] * a5 - _m.data[10] * a2 + _m.data[11] * a1;

				_outMatrix.data[8] = _m.data[4] * b4 - _m.data[5] * b2 + _m.data[7] * b0;
				_outMatrix.data[9] = -_m.data[0] * b4 + _m.data[1] * b2 - _m.data[3] * b0;
				_outMatrix.data[10] = _m.data[12] * a4 - _m.data[13] * a2 + _m.data[15] * a0;
				_outMatrix.data[11] = -_m.data[8] * a4 + _m.data[9] * a2 - _m.data[11] * a0;

				_outMatrix.data[12] = -_m.data[4] * b3 + _m.data[5] * b1 - _m.data[6] * b0;
				_outMatrix.data[13] = _m.data[0] * b3 - _m.data[1] * b1 + _m.data[2] * b0;
				_outMatrix.data[14] = -_m.data[12] * a3 + _m.data[13] * a1 - _m.data[14] * a0;
				_outMatrix.data[15] = _m.data[8] * a3 - _m.data[9] * a1 + _m.data[10] * a0;

				MultiplyNumF(_outMatrix, 1.0f / det, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				float det;
				float sx = sqrt(_m.data[0] * _m.data[0] + _m.data[4] * _m.data[4] + _m.data[8] * _m.data[8]);
				float sy = sqrt(_m.data[1] * _m.data[1] + _m.data[5] * _m.data[5] + _m.data[9] * _m.data[9]);
				float sz = sqrt(_m.data[2] * _m.data[2] + _m.data[6] * _m.data[6] + _m.data[10] * _m.data[10]);
				DeterminantF(_m, det);

				if(G_COMPARISON_STANDARD_F(det, 0.0f))
					return GW::GReturn::FAILURE;

				if(det < 0)
				{
					sx = -sx;
				}

				GW::MATH::GMATRIXF Rotation = _m;
				Rotation.data[0] /= sx;
				Rotation.data[4] /= sx;
				Rotation.data[8] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[5] /= sy;
				Rotation.data[9] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[6] /= sz;
				Rotation.data[10] /= sz;


				float trace = Rotation.data[0] + Rotation.data[5] + Rotation.data[10] + 1;

				if(trace > G_EPSILON_F)
				{
					float s = 0.5f / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25f / s;
				}
				else
				{
					if(Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25f / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if(Rotation.row2.y > Rotation.row3.z)
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25f / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25f / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector)
			{
				_outVector = _matrix.row4;
				_outVector.w = 0;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector)
			{
				float det;

				_outVector.x = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				_outVector.y = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				_outVector.z = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				_outVector.w = 0;

				DeterminantF(_matrix, det);
				if(det < 0)
				{
					_outVector.x = -_outVector.x;
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				GW::MATH::GMATRIXF RotationX;
				GW::MATH::GMATRIXF RotationY;
				GW::MATH::GMATRIXF RotationZ;
				GW::MATH::GMATRIXF reuslt;
				RotateZGlobalF(GW::MATH::GIdentityMatrixF, _roll, RotationZ);
				RotateXGlobalF(GW::MATH::GIdentityMatrixF, _pitch, RotationX);
				RotateYGlobalF(GW::MATH::GIdentityMatrixF, _yaw, RotationY);

				MultiplyMatrixF(RotationX, RotationY, reuslt);
				MultiplyMatrixF(RotationZ, reuslt, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float x = _vector.x;
				float y = _vector.y;
				float z = _vector.z;

				float magnitude = x * x + y * y + z * z;
				if(!G_COMPARISON_STANDARD_F(magnitude, 1))
				{
					magnitude = sqrt(magnitude);
					if(!G_COMPARISON_STANDARD_F(magnitude, 0))
					{
						magnitude = 1.0f / magnitude;
						x = x * magnitude;
						y = y * magnitude;
						z = z * magnitude;
					}
					else return GW::GReturn::FAILURE;
				}
				float c = cos(_radian);
				float s = sin(_radian);

				float t = 1.0f - c;
				float tx = t * x;
				float ty = t * y;
				float tz = t * z;
				float txy = tx * y;
				float txz = tx * z;
				float tyz = ty * z;
				float sx = s * x;
				float sy = s * y;
				float sz = s * z;

				_outMatrix.data[0] = c + tx * x;
				_outMatrix.data[1] = txy + sz;
				_outMatrix.data[2] = txz - sy;
				_outMatrix.data[3] = 0.0f;

				_outMatrix.data[4] = txy - sz;
				_outMatrix.data[5] = c + ty * y;
				_outMatrix.data[6] = tyz + sx;
				_outMatrix.data[7] = 0.0f;

				_outMatrix.data[8] = txz + sy;
				_outMatrix.data[9] = tyz - sx;
				_outMatrix.data[10] = c + tz * z;
				_outMatrix.data[11] = 0.0f;

				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) {
				GW::MATH::GMATRIXF Translation = GW::MATH::GIdentityMatrixF;
				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixF(_matrix, Translation, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF Translation = GW::MATH::GIdentityMatrixF;
				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixF(Translation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF Scale = GW::MATH::GIdentityMatrixF;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Scale, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) {
				GW::MATH::GMATRIXF Scale = GW::MATH::GIdentityMatrixF;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				MultiplyMatrixF(Scale, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;

				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = G_LERP(_m1.data[i], _m2.data[i], _ratio);
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY / 2.0f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0f;
				_outMatrix.row4.data[2] = -_zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY / 0.5f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = -(_zf + _zn) * z;
				_outMatrix.row3.data[3] = (-2.0f * _zf * _zn) * z;
				_outMatrix.row4.data[2] = -1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY * 0.5f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0f;
				_outMatrix.row4.data[2] = -(_zf * _zn) / (_zf - _zn);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY * 0.5f);
				float z = _zf / (_zn - _zf);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = -1.0f;
				_outMatrix.row4.data[2] = _zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				GW::MATH::GVECTORF temp;
				GW::MATH::GVECTORF camDir;	  //zaxis
				GW::MATH::GVECTORF camRight;	  //xaxis
				GW::MATH::GVECTORF camUp;		  //yaxis
				float magnitudeX;
				float magnitudeZ;

				camDir.x = _at.x - _eye.x;
				camDir.y = _at.y - _eye.y;
				camDir.z = _at.z - _eye.z;

				magnitudeZ = sqrt((camDir.x * camDir.x) + (camDir.y * camDir.y) + (camDir.z * camDir.z));
				if(G_COMPARISON_STANDARD_F(magnitudeZ, 0.0f)) return GW::GReturn::FAILURE;


				camDir.x /= magnitudeZ;
				camDir.y /= magnitudeZ;
				camDir.z /= magnitudeZ;


				camRight.x = (_up.y * camDir.z) - (_up.z * camDir.y);
				camRight.y = (_up.z * camDir.x) - (_up.x * camDir.z);
				camRight.z = (_up.x * camDir.y) - (_up.y * camDir.x);

				magnitudeX = sqrt((camRight.x * camRight.x) + (camRight.y * camRight.y) + (camRight.z * camRight.z));
				if(G_COMPARISON_STANDARD_F(magnitudeX, 0.0f)) return GW::GReturn::FAILURE;


				camRight.x /= magnitudeX;
				camRight.y /= magnitudeX;
				camRight.z /= magnitudeX;


				camUp.x = (camDir.y * camRight.z) - (camDir.z * camRight.y);
				camUp.y = (camDir.z * camRight.x) - (camDir.x * camRight.z);
				camUp.z = (camDir.x * camRight.y) - (camDir.y * camRight.x);

				temp.x = camRight.x * _eye.x + camRight.y * _eye.y + camRight.z * _eye.z;
				temp.y = camUp.x * _eye.x + camUp.y * _eye.y + camUp.z * _eye.z;
				temp.z = camDir.x * _eye.x + camDir.y * _eye.y + camDir.z * _eye.z;

				_outMatrix.data[0] = camRight.x;
				_outMatrix.data[4] = camRight.y;
				_outMatrix.data[8] = camRight.z;
				_outMatrix.data[12] = -temp.x;

				_outMatrix.data[1] = camUp.x;
				_outMatrix.data[5] = camUp.y;
				_outMatrix.data[9] = camUp.z;
				_outMatrix.data[13] = -temp.y;

				_outMatrix.data[2] = camDir.x;
				_outMatrix.data[6] = camDir.y;
				_outMatrix.data[10] = camDir.z;
				_outMatrix.data[14] = -temp.z;
				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF inverseMatrix2; 
				InverseF(_matrix2, inverseMatrix2);

				MultiplyMatrixF(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) 
			{
				MultiplyMatrixF(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) 
			{
				for (int i = 0; i < 16; i++)
				{
					_outMatrixD.data[i] = static_cast<double>(_matrixF.data[i]);
				}

				return GReturn::SUCCESS;
			}




			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] + _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] - _matrix2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				_outMatrix.data[0] = _m1.data[0] * _m2.data[0] + _m1.data[1] * _m2.data[4] + _m1.data[2] * _m2.data[8] + _m1.data[3] * _m2.data[12];
				_outMatrix.data[1] = _m1.data[0] * _m2.data[1] + _m1.data[1] * _m2.data[5] + _m1.data[2] * _m2.data[9] + _m1.data[3] * _m2.data[13];
				_outMatrix.data[2] = _m1.data[0] * _m2.data[2] + _m1.data[1] * _m2.data[6] + _m1.data[2] * _m2.data[10] + _m1.data[3] * _m2.data[14];
				_outMatrix.data[3] = _m1.data[0] * _m2.data[3] + _m1.data[1] * _m2.data[7] + _m1.data[2] * _m2.data[11] + _m1.data[3] * _m2.data[15];

				_outMatrix.data[4] = _m1.data[4] * _m2.data[0] + _m1.data[5] * _m2.data[4] + _m1.data[6] * _m2.data[8] + _m1.data[7] * _m2.data[12];
				_outMatrix.data[5] = _m1.data[4] * _m2.data[1] + _m1.data[5] * _m2.data[5] + _m1.data[6] * _m2.data[9] + _m1.data[7] * _m2.data[13];
				_outMatrix.data[6] = _m1.data[4] * _m2.data[2] + _m1.data[5] * _m2.data[6] + _m1.data[6] * _m2.data[10] + _m1.data[7] * _m2.data[14];
				_outMatrix.data[7] = _m1.data[4] * _m2.data[3] + _m1.data[5] * _m2.data[7] + _m1.data[6] * _m2.data[11] + _m1.data[7] * _m2.data[15];

				_outMatrix.data[8] = _m1.data[8] * _m2.data[0] + _m1.data[9] * _m2.data[4] + _m1.data[10] * _m2.data[8] + _m1.data[11] * _m2.data[12];
				_outMatrix.data[9] = _m1.data[8] * _m2.data[1] + _m1.data[9] * _m2.data[5] + _m1.data[10] * _m2.data[9] + _m1.data[11] * _m2.data[13];
				_outMatrix.data[10] = _m1.data[8] * _m2.data[2] + _m1.data[9] * _m2.data[6] + _m1.data[10] * _m2.data[10] + _m1.data[11] * _m2.data[14];
				_outMatrix.data[11] = _m1.data[8] * _m2.data[3] + _m1.data[9] * _m2.data[7] + _m1.data[10] * _m2.data[11] + _m1.data[11] * _m2.data[15];

				_outMatrix.data[12] = _m1.data[12] * _m2.data[0] + _m1.data[13] * _m2.data[4] + _m1.data[14] * _m2.data[8] + _m1.data[15] * _m2.data[12];
				_outMatrix.data[13] = _m1.data[12] * _m2.data[1] + _m1.data[13] * _m2.data[5] + _m1.data[14] * _m2.data[9] + _m1.data[15] * _m2.data[13];
				_outMatrix.data[14] = _m1.data[12] * _m2.data[2] + _m1.data[13] * _m2.data[6] + _m1.data[14] * _m2.data[10] + _m1.data[15] * _m2.data[14];
				_outMatrix.data[15] = _m1.data[12] * _m2.data[3] + _m1.data[13] * _m2.data[7] + _m1.data[14] * _m2.data[11] + _m1.data[15] * _m2.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				_outVector.x = _vector.data[0] * _m.data[0] + _vector.data[1] * _m.data[4] + _vector.data[2] * _m.data[8] + _vector.data[3] * _m.data[12];
				_outVector.y = _vector.data[0] * _m.data[1] + _vector.data[1] * _m.data[5] + _vector.data[2] * _m.data[9] + _vector.data[3] * _m.data[13];
				_outVector.z = _vector.data[0] * _m.data[2] + _vector.data[1] * _m.data[6] + _vector.data[2] * _m.data[10] + _vector.data[3] * _m.data[14];
				_outVector.w = _vector.data[0] * _m.data[3] + _vector.data[1] * _m.data[7] + _vector.data[2] * _m.data[11] + _vector.data[3] * _m.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix)
			{
				double xx2 = 2 * _quaternion.x * _quaternion.x;
				double yy2 = 2 * _quaternion.y * _quaternion.y;
				double zz2 = 2 * _quaternion.z * _quaternion.z;

				double xy2 = 2 * _quaternion.x * _quaternion.y;
				double xz2 = 2 * _quaternion.x * _quaternion.z;
				double yz2 = 2 * _quaternion.y * _quaternion.z;

				double wx2 = 2 * _quaternion.w * _quaternion.x;
				double wy2 = 2 * _quaternion.w * _quaternion.y;
				double wz2 = 2 * _quaternion.w * _quaternion.z;

				_outMatrix.data[0] = 1.0f - yy2 - zz2;
				_outMatrix.data[1] = xy2 - wz2;
				_outMatrix.data[2] = xz2 + wy2;
				_outMatrix.data[3] = 0.0f;
				_outMatrix.data[4] = xy2 + wz2;
				_outMatrix.data[5] = 1.0f - xx2 - zz2;
				_outMatrix.data[6] = yz2 - wx2;
				_outMatrix.data[7] = 0.0f;
				_outMatrix.data[8] = xz2 - wy2;
				_outMatrix.data[9] = yz2 + wx2;
				_outMatrix.data[10] = 1.0f - xx2 - yy2;
				_outMatrix.data[11] = 0.0f;
				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m.data[i] * _scalar;
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue)
			{
				double a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				double a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				double a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				double a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				double a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				double a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				double b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				double b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				double b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				double b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				double b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				double b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				_outValue = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				_outMatrix.data[0] = _m.data[0];
				_outMatrix.data[1] = _m.data[4];
				_outMatrix.data[2] = _m.data[8];
				_outMatrix.data[3] = _m.data[12];
				_outMatrix.data[4] = _m.data[1];
				_outMatrix.data[5] = _m.data[5];
				_outMatrix.data[6] = _m.data[9];
				_outMatrix.data[7] = _m.data[13];
				_outMatrix.data[8] = _m.data[2];
				_outMatrix.data[9] = _m.data[6];
				_outMatrix.data[10] = _m.data[10];
				_outMatrix.data[11] = _m.data[14];
				_outMatrix.data[12] = _m.data[3];
				_outMatrix.data[13] = _m.data[7];
				_outMatrix.data[14] = _m.data[11];
				_outMatrix.data[15] = _m.data[15];
				return GW::GReturn::SUCCESS;
			}
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				double det;
				double a0 = _m.data[0] * _m.data[5] - _m.data[1] * _m.data[4];
				double a1 = _m.data[0] * _m.data[6] - _m.data[2] * _m.data[4];
				double a2 = _m.data[0] * _m.data[7] - _m.data[3] * _m.data[4];
				double a3 = _m.data[1] * _m.data[6] - _m.data[2] * _m.data[5];
				double a4 = _m.data[1] * _m.data[7] - _m.data[3] * _m.data[5];
				double a5 = _m.data[2] * _m.data[7] - _m.data[3] * _m.data[6];
				double b0 = _m.data[8] * _m.data[13] - _m.data[9] * _m.data[12];
				double b1 = _m.data[8] * _m.data[14] - _m.data[10] * _m.data[12];
				double b2 = _m.data[8] * _m.data[15] - _m.data[11] * _m.data[12];
				double b3 = _m.data[9] * _m.data[14] - _m.data[10] * _m.data[13];
				double b4 = _m.data[9] * _m.data[15] - _m.data[11] * _m.data[13];
				double b5 = _m.data[10] * _m.data[15] - _m.data[11] * _m.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
				if(G_COMPARISON_STANDARD_D(det, 0))
				{
					return GW::GReturn::FAILURE;
				}
				_outMatrix.data[0] = _m.data[5] * b5 - _m.data[6] * b4 + _m.data[7] * b3;
				_outMatrix.data[1] = -_m.data[1] * b5 + _m.data[2] * b4 - _m.data[3] * b3;
				_outMatrix.data[2] = _m.data[13] * a5 - _m.data[14] * a4 + _m.data[15] * a3;
				_outMatrix.data[3] = -_m.data[9] * a5 + _m.data[10] * a4 - _m.data[11] * a3;

				_outMatrix.data[4] = -_m.data[4] * b5 + _m.data[6] * b2 - _m.data[7] * b1;
				_outMatrix.data[5] = _m.data[0] * b5 - _m.data[2] * b2 + _m.data[3] * b1;
				_outMatrix.data[6] = -_m.data[12] * a5 + _m.data[14] * a2 - _m.data[15] * a1;
				_outMatrix.data[7] = _m.data[8] * a5 - _m.data[10] * a2 + _m.data[11] * a1;

				_outMatrix.data[8] = _m.data[4] * b4 - _m.data[5] * b2 + _m.data[7] * b0;
				_outMatrix.data[9] = -_m.data[0] * b4 + _m.data[1] * b2 - _m.data[3] * b0;
				_outMatrix.data[10] = _m.data[12] * a4 - _m.data[13] * a2 + _m.data[15] * a0;
				_outMatrix.data[11] = -_m.data[8] * a4 + _m.data[9] * a2 - _m.data[11] * a0;

				_outMatrix.data[12] = -_m.data[4] * b3 + _m.data[5] * b1 - _m.data[6] * b0;
				_outMatrix.data[13] = _m.data[0] * b3 - _m.data[1] * b1 + _m.data[2] * b0;
				_outMatrix.data[14] = -_m.data[12] * a3 + _m.data[13] * a1 - _m.data[14] * a0;
				_outMatrix.data[15] = _m.data[8] * a3 - _m.data[9] * a1 + _m.data[10] * a0;

				MultiplyNumD(_outMatrix, 1.0f / det, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion)
			{
				double det;
				double sx = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				double sy = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				double sz = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				DeterminantD(_matrix, det);
				if(G_COMPARISON_STANDARD_D(det, 0))
				{
					return GW::GReturn::FAILURE;
				}
				if(det < 0)
				{
					sx = -sx;
				}
				GW::MATH::GMATRIXD Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				double trace = Rotation.data[0] + Rotation.data[5] + Rotation.data[10] + 1;

				if(trace > G_EPSILON_D)
				{
					double s = 0.5 / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25 / s;
				}
				else
				{
					if(Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						double s = 0.5f / sqrt(1.0 + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25 / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if(Rotation.row2.y > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25 / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25 / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector)
			{
				_outVector = _matrix.row4;
				_outVector.w = 0;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector)
			{
				double det;

				_outVector.x = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				_outVector.y = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				_outVector.z = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				_outVector.w = 0;

				DeterminantD(_matrix, det);
				if(det < 0)
				{
					_outVector.x = -_outVector.x;
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				GW::MATH::GMATRIXD RotationX;
				GW::MATH::GMATRIXD RotationY;
				GW::MATH::GMATRIXD RotationZ;
				GW::MATH::GMATRIXD reuslt;
				RotateZGlobalD(GW::MATH::GIdentityMatrixD, _roll, RotationZ);
				RotateXGlobalD(GW::MATH::GIdentityMatrixD, _pitch, RotationX);
				RotateYGlobalD(GW::MATH::GIdentityMatrixD, _yaw, RotationY);

				MultiplyMatrixD(RotationX, RotationY, reuslt);
				MultiplyMatrixD(RotationZ, reuslt, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double x = _vector.x;
				double y = _vector.y;
				double z = _vector.z;

				double magnitude = x * x + y * y + z * z;
				if(!G_COMPARISON_STANDARD_D(magnitude, 1))
				{
					magnitude = sqrt(magnitude);
					if(!G_COMPARISON_STANDARD_D(magnitude, 0))
					{
						magnitude = 1.0 / magnitude;
						x = x * magnitude;
						y = y * magnitude;
						z = z * magnitude;
					}
					else return GW::GReturn::FAILURE;
				}
				double c = cos(_radian);
				double s = sin(_radian);

				double t = 1.0f - c;
				double tx = t * x;
				double ty = t * y;
				double tz = t * z;
				double txy = tx * y;
				double txz = tx * z;
				double tyz = ty * z;
				double sx = s * x;
				double sy = s * y;
				double sz = s * z;

				_outMatrix.data[0] = c + tx * x;
				_outMatrix.data[1] = txy + sz;
				_outMatrix.data[2] = txz - sy;
				_outMatrix.data[3] = 0.0f;

				_outMatrix.data[4] = txy - sz;
				_outMatrix.data[5] = c + ty * y;
				_outMatrix.data[6] = tyz + sx;
				_outMatrix.data[7] = 0.0f;

				_outMatrix.data[8] = txz + sy;
				_outMatrix.data[9] = tyz - sx;
				_outMatrix.data[10] = c + tz * z;
				_outMatrix.data[11] = 0.0f;

				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Translation = GW::MATH::GIdentityMatrixD;

				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixD(_matrix, Translation, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Translation = GW::MATH::GIdentityMatrixD;

				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixD(Translation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Scale = GW::MATH::GIdentityMatrixD;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Scale, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Scale = GW::MATH::GIdentityMatrixD;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				MultiplyMatrixD(Scale, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = G_LERP(_m1.data[i], _m2.data[i], _ratio);
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY / 2.0);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0;
				_outMatrix.row4.data[2] = -_zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY / 0.5);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = -(_zf + _zn) * z;
				_outMatrix.row3.data[3] = (-2.0 * _zf * _zn) * z;
				_outMatrix.row4.data[2] = -1.0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY * 0.5);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0;
				_outMatrix.row4.data[2] = -(_zf * _zn) / (_zf - _zn);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY * 0.5);
				double z = _zf / (_zn - _zf);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = -1.0;
				_outMatrix.row4.data[2] = _zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				GW::MATH::GVECTORD temp;
				GW::MATH::GVECTORD camDir;	  //zaxis
				GW::MATH::GVECTORD camRight;	  //xaxis
				GW::MATH::GVECTORD camUp;		  //yaxis
				double magnitudeX;
				double magnitudeZ;

				camDir.x = _at.x - _eye.x;
				camDir.y = _at.y - _eye.y;
				camDir.z = _at.z - _eye.z;

				magnitudeZ = sqrt((camDir.x * camDir.x) + (camDir.y * camDir.y) + (camDir.z * camDir.z));
				if(G_COMPARISON_STANDARD_F(static_cast<float>(magnitudeZ), 0)) return GW::GReturn::FAILURE;

				camDir.x /= magnitudeZ;
				camDir.y /= magnitudeZ;
				camDir.z /= magnitudeZ;


				camRight.x = (_up.y * camDir.z) - (_up.z * camDir.y);
				camRight.y = (_up.z * camDir.x) - (_up.x * camDir.z);
				camRight.z = (_up.x * camDir.y) - (_up.y * camDir.x);

				magnitudeX = sqrt((camRight.x * camRight.x) + (camRight.y * camRight.y) + (camRight.z * camRight.z));
				if(G_COMPARISON_STANDARD_F(static_cast<float>(magnitudeX), 0)) return GW::GReturn::FAILURE;


				camRight.x /= magnitudeX;
				camRight.y /= magnitudeX;
				camRight.z /= magnitudeX;


				camUp.x = (camDir.y * camRight.z) - (camDir.z * camRight.y);
				camUp.y = (camDir.z * camRight.x) - (camDir.x * camRight.z);
				camUp.z = (camDir.x * camRight.y) - (camDir.y * camRight.x);

				temp.x = camRight.x * _eye.x + camRight.y * _eye.y + camRight.z * _eye.z;
				temp.y = camUp.x * _eye.x + camUp.y * _eye.y + camUp.z * _eye.z;
				temp.z = camDir.x * _eye.x + camDir.y * _eye.y + camDir.z * _eye.z;

				_outMatrix.data[0] = camRight.x;
				_outMatrix.data[4] = camRight.y;
				_outMatrix.data[8] = camRight.z;
				_outMatrix.data[12] = -temp.x;

				_outMatrix.data[1] = camUp.x;
				_outMatrix.data[5] = camUp.y;
				_outMatrix.data[9] = camUp.z;
				_outMatrix.data[13] = -temp.y;

				_outMatrix.data[2] = camDir.x;
				_outMatrix.data[6] = camDir.y;
				_outMatrix.data[10] = camDir.z;
				_outMatrix.data[14] = -temp.z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD inverseMatrix2;
				InverseD(_matrix2, inverseMatrix2);

				MultiplyMatrixD(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				MultiplyMatrixD(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) 
			{
				for (int i = 0; i < 16; i++)
				{
					_outMatrixF.data[i] = static_cast<float>(_matrixD.data[i]);
				}

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH
	{
		class GMatrix final
			: public I::GProxy<I::GMatrixInterface, I::GMatrixImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMatrix)
			GATEWARE_STATIC_FUNCTION(AddMatrixF)
			GATEWARE_STATIC_FUNCTION(SubtractMatrixF)
			GATEWARE_STATIC_FUNCTION(MultiplyMatrixF)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixF)
			GATEWARE_STATIC_FUNCTION(ConvertQuaternionF)
			GATEWARE_STATIC_FUNCTION(MultiplyNumF)
			GATEWARE_STATIC_FUNCTION(DeterminantF)
			GATEWARE_STATIC_FUNCTION(TransposeF)
			GATEWARE_STATIC_FUNCTION(InverseF)
			GATEWARE_STATIC_FUNCTION(IdentityF)
			GATEWARE_STATIC_FUNCTION(GetRotationF)
			GATEWARE_STATIC_FUNCTION(GetTranslationF)
			GATEWARE_STATIC_FUNCTION(GetScaleF)
			GATEWARE_STATIC_FUNCTION(RotateXGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateXLocalF)
			GATEWARE_STATIC_FUNCTION(RotateYGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateYLocalF)
			GATEWARE_STATIC_FUNCTION(RotateZGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateZLocalF)
			GATEWARE_STATIC_FUNCTION(RotationYawPitchRollF)
			GATEWARE_STATIC_FUNCTION(RotationByVectorF)
			GATEWARE_STATIC_FUNCTION(TranslateGlobalF)
			GATEWARE_STATIC_FUNCTION(TranslateLocalF)
			GATEWARE_STATIC_FUNCTION(ScaleGlobalF)
			GATEWARE_STATIC_FUNCTION(ScaleLocalF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(ProjectionDirectXLHF)
			GATEWARE_STATIC_FUNCTION(ProjectionOpenGLRHF)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanLHF)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanRHF)
			GATEWARE_STATIC_FUNCTION(LookAtLHF)
			GATEWARE_STATIC_FUNCTION(MakeRelativeF)
			GATEWARE_STATIC_FUNCTION(MakeSeparateF)
			GATEWARE_STATIC_FUNCTION(Upgrade)


			GATEWARE_STATIC_FUNCTION(AddMatrixD)
			GATEWARE_STATIC_FUNCTION(SubtractMatrixD)
			GATEWARE_STATIC_FUNCTION(MultiplyMatrixD)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixD)
			GATEWARE_STATIC_FUNCTION(ConvertQuaternionD)
			GATEWARE_STATIC_FUNCTION(MultiplyNumD)
			GATEWARE_STATIC_FUNCTION(DeterminantD)
			GATEWARE_STATIC_FUNCTION(TransposeD)
			GATEWARE_STATIC_FUNCTION(InverseD)
			GATEWARE_STATIC_FUNCTION(IdentityD)
			GATEWARE_STATIC_FUNCTION(GetRotationD)
			GATEWARE_STATIC_FUNCTION(GetTranslationD)
			GATEWARE_STATIC_FUNCTION(GetScaleD)
			GATEWARE_STATIC_FUNCTION(RotateXGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateXLocalD)
			GATEWARE_STATIC_FUNCTION(RotateYGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateYLocalD)
			GATEWARE_STATIC_FUNCTION(RotateZGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateZLocalD)
			GATEWARE_STATIC_FUNCTION(RotationYawPitchRollD)
			GATEWARE_STATIC_FUNCTION(RotationByVectorD)
			GATEWARE_STATIC_FUNCTION(TranslateGlobalD)
			GATEWARE_STATIC_FUNCTION(TranslateLocalD)
			GATEWARE_STATIC_FUNCTION(ScaleGlobalD)
			GATEWARE_STATIC_FUNCTION(ScaleLocalD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(ProjectionDirectXLHD)
			GATEWARE_STATIC_FUNCTION(ProjectionOpenGLRHD)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanLHD)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanRHD)
			GATEWARE_STATIC_FUNCTION(LookAtLHD)
			GATEWARE_STATIC_FUNCTION(MakeRelativeD)
			GATEWARE_STATIC_FUNCTION(MakeSeparateD)
			GATEWARE_STATIC_FUNCTION(Downgrade)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GMATRIX_H

/*---------------------------------
|	End of GMatrix.h
----------------------------------*/


/*---------------------------------
|	Begin of GCollision2D.h
----------------------------------*/
#ifndef GCOLLISION2D_H
#define GCOLLISION2D_H





namespace GW
{
	namespace I
	{
		class GCollision2DInterface : public virtual GInterfaceInterface
		{
		public:
			enum class GCollisionCheck2D
			{
				ERROR_NO_RESULT = -3,
				ABOVE = -2,
				BELOW = -1,
				NO_COLLISION = 0,
				COLLISION = 1
			};

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}


// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GCollision2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are separated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GCOLLISION2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GCOLLISION2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GCollision2DImplementation : public virtual GCollision2DInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric) { return GReturn::FAILURE; }
			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
namespace GW
{
	namespace I
	{
		class GCollision2DImplementation : public virtual GCollision2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult)
			{
				//									A				      x                       B                    y                                       C
				_outEquationResult = ((_line.start.y - _line.end.y) * _point.x) + ((_line.end.x - _line.start.x) * _point.y) + ((_line.start.x * _line.end.y) - (_line.start.y * _line.end.x));

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance)
			{
				float sqLineLength = SqDistancePointToPointF(_line.start, _line.end);

				// _line.start == _line.end case
				if (G2D_COMPARISON_STANDARD_F(sqLineLength, 0.0f))
				{
					_outDistance = SqDistancePointToPointF(_point, _line.start);
					return GReturn::SUCCESS;
				}

				// Consider the line extending the segment vw, parameterized as: v + t(w - v).
				// We find projection of _point onto the line.
				// It falls at t where t = dot((p-v), (w-v)) / ||w-v||^2
				// We clamp t from 0-1 to handle points outside the segment vw.

				MATH2D::GVECTOR2F PminusV{ _point.x - _line.start.x, _point.y - _line.start.y };
				MATH2D::GVECTOR2F WminusV{ _line.end.x - _line.start.x, _line.end.y - _line.start.y };

				float dot = (PminusV.x * WminusV.x) + (PminusV.y * WminusV.y);

				// clamp t
				float t = G2D_MAX(0.0f, G2D_MIN(1.0f, dot / sqLineLength));

				// projection falls on the segment
				MATH2D::GVECTOR2F projection{ (WminusV.x * t) + _line.start.x, (WminusV.y * t) + _line.start.y };

				_outDistance = SqDistancePointToPointF(_point, projection);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance)
			{
				// implementation is based around the fact that our rectangles are axis-aligned

				// center of rectangle
				MATH2D::GVECTOR2F c = { (_rectangle.min.x + _rectangle.max.x) / 2.0f, (_rectangle.min.y + _rectangle.max.y) / 2.0f };
				float width = G2D_ABS(_rectangle.min.x - _rectangle.max.x);
				float height = G2D_ABS(_rectangle.min.y - _rectangle.min.y);

				float dx = G2D_MAX(G2D_ABS(_point.x - c.x) - width / 2.0f, 0.0f);
				float dy = G2D_MAX(G2D_ABS(_point.y - c.y) - height / 2.0f, 0.0f);

				_outDistance = dx * dx + dy * dy;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance)
			{
				GCollisionCheck2D collisionResult;
				TestPointToPolygon2F(_point, _polygon, _numVerts, collisionResult);

				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outDistance = 0.0f;
					return GReturn::SUCCESS;
				}

				unsigned int j = _numVerts - 1;
				float smallestDistance = 3.402823466e+38F; // float max
				float temp;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					SqDistancePointToLine2F(_point, { _polygon[i], _polygon[j] }, temp);
					smallestDistance = G2D_MIN(smallestDistance, temp);
				}

				_outDistance = smallestDistance;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult)
			{
				// handle cases where point is at start or end of line and where line is actually a point
				if (PointsAreEqualF(_point, _line.start) || PointsAreEqualF(_point, _line.end))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				float equationResult;
				ImplicitLineEquationF(_point, _line, equationResult);

				GCollisionCheck2D collisionResult = GCollisionCheck2D::NO_COLLISION;
				if (G2D_COMPARISON_STANDARD_F(equationResult, 0.0f)) // if the point is on the vector of the line
				{
					if (_line.start.x == _line.end.x) // if its a vertical line with undefined slope
					{
						if (_line.start.y < _line.end.y) // if the slope would be positive
						{
							if (_line.start.y < _point.y && _point.y < _line.end.y) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.y < _point.y && _point.y < _line.start.y)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
					else // if its a horizontal line with 0 slope, or any other line
					{
						if (_line.start.x < _line.end.x) // if the slope would be positive
						{
							if (_line.start.x < _point.x && _point.x < _line.end.x) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.x < _point.x && _point.x < _line.start.x)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
				}
				else if (equationResult > 0.0f) { collisionResult = GCollisionCheck2D::ABOVE; }
				else { collisionResult = GCollisionCheck2D::BELOW; }

				_outResult = collisionResult;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointF(_point, _circle.pos) <= (_circle.radius * _circle.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangle
				MATH2D::GVECTOR2F botLeft{ G2D_MIN(_rectangle.min.x, _rectangle.max.x), G2D_MIN(_rectangle.min.y, _rectangle.max.y) };
				MATH2D::GVECTOR2F topRight{ G2D_MAX(_rectangle.min.x, _rectangle.max.x), G2D_MAX(_rectangle.min.y, _rectangle.max.y) };

				if (_point.x >= botLeft.x &&
					_point.x <= topRight.x &&
					_point.y >= botLeft.y &&
					_point.y <= topRight.y)
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				bool collision = false;
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					// in any compiler that implements C, when executing the code a && b, if a is false, then b must not be evaluated, which means we dont have to check for devide-by-zero
					if (((_polygon[i].y > _point.y) != (_polygon[j].y > _point.y)) &&
						(_point.x < (_polygon[j].x - _polygon[i].x) * (_point.y - _polygon[i].y) / (_polygon[j].y - _polygon[i].y) + _polygon[i].x))
					{
						collision = !collision;
					}
				}

				_outResult = collision == true ? GCollisionCheck2D::COLLISION : GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult)
			{
				// line equation for line1: Ax + By = C
				float A1 = _line1.end.y - _line1.start.y;
				float B1 = _line1.start.x - _line1.end.x;
				float C1 = A1 * _line1.start.x + B1 * _line1.start.y;

				// line equation for line2
				float A2 = _line2.end.y - _line2.start.y;
				float B2 = _line2.start.x - _line2.end.x;
				float C2 = A2 * _line2.start.x + B2 * _line2.start.y;

				float det = A1 * B2 - A2 * B1;

				if (det == 0) // lines are parallel. need to check if one line is a subsegment of the other
				{
					if (A1 * _line2.start.x + B1 * _line2.start.y == C1 ||
						A1 * _line2.end.x + B1 * _line2.end.y == C1 ||
						A2 * _line1.start.x + B2 * _line1.start.y == C2 ||
						A2 * _line1.end.x + B2 * _line1.end.y == C2)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}
				else
				{
					// lines are not parallel, find the intersection
					float x = (B2 * C1 - B1 * C2) / det;
					float y = (A1 * C2 - A2 * C1) / det;

					// find minXY and maxXY for both lines
					MATH2D::GVECTOR2F min1{ G2D_MIN(_line1.start.x, _line1.end.x), G2D_MIN(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2F max1{ G2D_MAX(_line1.start.x, _line1.end.x), G2D_MAX(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2F min2{ G2D_MIN(_line2.start.x, _line2.end.x), G2D_MIN(_line2.start.y, _line2.end.y) };
					MATH2D::GVECTOR2F max2{ G2D_MAX(_line2.start.x, _line2.end.x), G2D_MAX(_line2.start.y, _line2.end.y) };

					// test if the intersection falls within both line segments
					if (x >= min1.x &&
						x >= min2.x &&
						x <= max1.x &&
						x <= max2.x &&
						y >= min1.y &&
						y >= min2.y &&
						y <= max1.y &&
						y <= max2.y)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult)
			{
				float sqDistanceToLine;
				SqDistancePointToLine2F(_circle.pos, _line, sqDistanceToLine);

				_outResult = sqDistanceToLine <= _circle.radius * _circle.radius
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult)
			{
				// handle case where both start and/or end of _line are inside _rectangle
				float distanceFromStartToRect, distanceFromEndToRect;

				SqDistancePointToRectangle2F(_line.start, _rectangle, distanceFromStartToRect);
				if (G2D_COMPARISON_STANDARD_F(distanceFromStartToRect, 0.0f))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				SqDistancePointToRectangle2F(_line.end, _rectangle, distanceFromEndToRect);
				if (G2D_COMPARISON_STANDARD_F(distanceFromEndToRect, 0.0f))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}



				// handle everything else
				GCollisionCheck2D left, right, top, bottom;

				TestLineToLine2F(_line, { _rectangle.min, {_rectangle.min.x, _rectangle.max.y} }, left);
				if (left == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { {_rectangle.max.x, _rectangle.min.y}, _rectangle.max }, right);
				if (right == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { {_rectangle.min.x, _rectangle.max.y}, _rectangle.max }, top);
				if (top == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { _rectangle.min, {_rectangle.max.x, _rectangle.min.y} }, bottom);
				if (bottom == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				// handle case where start and/or end of _line are inside _polygon
				GCollisionCheck2D cStart, cEnd;

				TestPointToPolygon2F(_line.start, _polygon, _numVerts, cStart);
				if (cStart == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPolygon2F(_line.start, _polygon, _numVerts, cEnd);
				if (cEnd == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				unsigned int j = _numVerts - 1;
				GCollisionCheck2D lineCollision;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToLine2F(_line, { _polygon[i], _polygon[j] }, lineCollision);
					if (lineCollision == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointF(_circle1.pos, _circle2.pos) <= (_circle1.radius + _circle2.radius) * (_circle1.radius + _circle2.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangles and width and height
				MATH2D::GVECTOR2F botLeft1{ G2D_MIN(_rectangle1.min.x, _rectangle1.max.x), G2D_MIN(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2F topRight1{ G2D_MAX(_rectangle1.min.x, _rectangle1.max.x), G2D_MAX(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2F botLeft2{ G2D_MIN(_rectangle2.min.x, _rectangle2.max.x), G2D_MIN(_rectangle2.min.y, _rectangle2.max.y) };
				MATH2D::GVECTOR2F topRight2{ G2D_MAX(_rectangle2.min.x, _rectangle2.max.x), G2D_MAX(_rectangle2.min.y, _rectangle2.max.y) };

				if (botLeft1.x > topRight2.x ||
					topRight1.x < botLeft2.x ||
					botLeft1.y > topRight2.y ||
					topRight1.y < botLeft2.y)
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// rectangle could be inside polygon
				TestPointToPolygon2F(_rectangle.min, _polygon, _numVerts, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// polygon could be inside rectangle
				TestPointToRectangle2F(_polygon[0], _rectangle, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the rectangle to every edge of the polygon
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToRectangle2F({ _polygon[i], _polygon[j] }, _rectangle, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// polygon2 could be inside polygon1
				TestPointToPolygon2F(_polygon2[0], _polygon1, _numVerts1, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the edges of polygon1 to polygon2
				unsigned int j = _numVerts1 - 1;
				for (unsigned int i = 0; i < _numVerts1; j = i++)
				{
					TestLineToPolygon2F({ _polygon1[i], _polygon1[j] }, _polygon2, _numVerts2, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric)
			{
				float rectArea;
				ImplicitLineEquationF(_trianglePoint1, { _trianglePoint3, _trianglePoint2 }, rectArea);

				if (G2D_COMPARISON_STANDARD_F(rectArea, 0.0f))
				{
					return GReturn::FAILURE; // would get a devide-by-zero error
				}

				float a, b;
				ImplicitLineEquationF(_point, { _trianglePoint3, _trianglePoint2 }, a);
				ImplicitLineEquationF(_point, { _trianglePoint1, _trianglePoint3 }, b);

				_outBarycentric.alpha = a / rectArea;
				_outBarycentric.beta = b / rectArea;
				_outBarycentric.gamma = 1.0f - _outBarycentric.alpha - _outBarycentric.beta;

				return GReturn::SUCCESS;
			}




			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult)
			{
				//									A				      x                       B                    y                                       C
				_outEquationResult = ((_line.start.y - _line.end.y) * _point.x) + ((_line.end.x - _line.start.x) * _point.y) + ((_line.start.x * _line.end.y) - (_line.start.y * _line.end.x));

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance)
			{
				double sqLineLength = SqDistancePointToPointD(_line.start, _line.end);

				// _line.start == _line.end case
				if (G2D_COMPARISON_STANDARD_D(sqLineLength, 0.0))
				{
					_outDistance = SqDistancePointToPointD(_point, _line.start);
					return GReturn::SUCCESS;
				}

				// Consider the line extending the segment vw, parameterized as: v + t(w - v).
				// We find projection of _point onto the line.
				// It falls at t where t = dot((p-v), (w-v)) / ||w-v||^2
				// We clamp t from 0-1 to handle points outside the segment vw.

				MATH2D::GVECTOR2D PminusV{ _point.x - _line.start.x, _point.y - _line.start.y };
				MATH2D::GVECTOR2D WminusV{ _line.end.x - _line.start.x, _line.end.y - _line.start.y };

				double dot = (PminusV.x * WminusV.x) + (PminusV.y * WminusV.y);

				// clamp t
				double t = G2D_MAX(0.0, G2D_MIN(1.0, dot / sqLineLength));

				// projection falls on the segment
				MATH2D::GVECTOR2D projection{ (WminusV.x * t) + _line.start.x, (WminusV.y * t) + _line.start.y };

				_outDistance = SqDistancePointToPointD(_point, projection);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance)
			{
				// implementation is based around the fact that our rectangles are axis-aligned

				// center of rectangle
				MATH2D::GVECTOR2D c = { (_rectangle.min.x + _rectangle.max.x) / 2.0, (_rectangle.min.y + _rectangle.max.y) / 2.0 };
				double width = G2D_ABS(_rectangle.min.x - _rectangle.max.x);
				double height = G2D_ABS(_rectangle.min.y - _rectangle.min.y);

				double dx = G2D_MAX(G2D_ABS(_point.x - c.x) - width / 2.0, 0.0);
				double dy = G2D_MAX(G2D_ABS(_point.y - c.y) - height / 2.0, 0.0);

				_outDistance = dx * dx + dy * dy;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance)
			{
				GCollisionCheck2D collisionResult;
				TestPointToPolygon2D(_point, _polygon, _numVerts, collisionResult);

				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outDistance = 0.0;
					return GReturn::SUCCESS;
				}

				unsigned int j = _numVerts - 1;
				double smallestDistance = 1.7976931348623158e+308; // double max
				double temp;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					SqDistancePointToLine2D(_point, { _polygon[i], _polygon[j] }, temp);
					smallestDistance = G2D_MIN(smallestDistance, temp);
				}

				_outDistance = smallestDistance;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult)
			{
				if (PointsAreEqualD(_point, _line.start) || PointsAreEqualD(_point, _line.end))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				double equationResult;
				ImplicitLineEquationD(_point, _line, equationResult);

				GCollisionCheck2D collisionResult = GCollisionCheck2D::NO_COLLISION;
				if (G2D_COMPARISON_STANDARD_D(equationResult, 0.0)) // if the point is on the vector of the line
				{
					if (_line.start.x == _line.end.x) // if its a vertical line with undefined slope
					{
						if (_line.start.y < _line.end.y) // if the slope would be positive
						{
							if (_line.start.y < _point.y && _point.y < _line.end.y) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.y < _point.y && _point.y < _line.start.y)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
					else // if its a horizontal line with 0 slope, or any other line
					{
						if (_line.start.x < _line.end.x) // if the slope would be positive
						{
							if (_line.start.x < _point.x && _point.x < _line.end.x) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.x < _point.x && _point.x < _line.start.x)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
				}
				else if (equationResult > 0.0) { collisionResult = GCollisionCheck2D::ABOVE; }
				else { collisionResult = GCollisionCheck2D::BELOW; }

				_outResult = collisionResult;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointD(_point, _circle.pos) <= (_circle.radius * _circle.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangle
				MATH2D::GVECTOR2D botLeft{ G2D_MIN(_rectangle.min.x, _rectangle.max.x), G2D_MIN(_rectangle.min.y, _rectangle.max.y) };
				MATH2D::GVECTOR2D topRight{ G2D_MAX(_rectangle.min.x, _rectangle.max.x), G2D_MAX(_rectangle.min.y, _rectangle.max.y) };

				if (_point.x >= botLeft.x &&
					_point.x <= topRight.x &&
					_point.y >= botLeft.y &&
					_point.y <= topRight.y)
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				bool collision = false;
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					// when executing the code a && b, if a is false, then b must not be evaluated, which means we dont have to check for devide-by-zero
					if (((_polygon[i].y > _point.y) != (_polygon[j].y > _point.y)) &&
						(_point.x < (_polygon[j].x - _polygon[i].x) * (_point.y - _polygon[i].y) / (_polygon[j].y - _polygon[i].y) + _polygon[i].x))
					{
						collision = !collision;
					}
				}

				_outResult = collision == true ? GCollisionCheck2D::COLLISION : GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult)
			{
				// line equation for line1: Ax + By = C
				double A1 = _line1.end.y - _line1.start.y;
				double B1 = _line1.start.x - _line1.end.x;
				double C1 = A1 * _line1.start.x + B1 * _line1.start.y;

				// line equation for line2
				double A2 = _line2.end.y - _line2.start.y;
				double B2 = _line2.start.x - _line2.end.x;
				double C2 = A2 * _line2.start.x + B2 * _line2.start.y;

				double det = A1 * B2 - A2 * B1;

				if (det == 0) // lines are parallel. need to check if one line is a subsegment of the other
				{
					if (A1 * _line2.start.x + B1 * _line2.start.y == C1 ||
						A1 * _line2.end.x + B1 * _line2.end.y == C1 ||
						A2 * _line1.start.x + B2 * _line1.start.y == C2 ||
						A2 * _line1.end.x + B2 * _line1.end.y == C2)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}
				else
				{
					// lines are not parallel, find the intersection
					double x = (B2 * C1 - B1 * C2) / det;
					double y = (A1 * C2 - A2 * C1) / det;

					// find minXY and maxXY for both lines
					MATH2D::GVECTOR2D min1{ G2D_MIN(_line1.start.x, _line1.end.x), G2D_MIN(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2D max1{ G2D_MAX(_line1.start.x, _line1.end.x), G2D_MAX(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2D min2{ G2D_MIN(_line2.start.x, _line2.end.x), G2D_MIN(_line2.start.y, _line2.end.y) };
					MATH2D::GVECTOR2D max2{ G2D_MAX(_line2.start.x, _line2.end.x), G2D_MAX(_line2.start.y, _line2.end.y) };

					// test if the intersection falls within both line segments
					if (x >= min1.x &&
						x >= min2.x &&
						x <= max1.x &&
						x <= max2.x &&
						y >= min1.y &&
						y >= min2.y &&
						y <= max1.y &&
						y <= max2.y)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult)
			{
				double sqDistanceToLine;
				SqDistancePointToLine2D(_circle.pos, _line, sqDistanceToLine);

				_outResult = sqDistanceToLine <= _circle.radius * _circle.radius
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult)
			{
				// handle case where both start and/or end of _line are inside _rectangle
				double distanceFromStartToRect, distanceFromEndToRect;

				SqDistancePointToRectangle2D(_line.start, _rectangle, distanceFromStartToRect);
				if (G2D_COMPARISON_STANDARD_D(distanceFromStartToRect, 0.0))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				SqDistancePointToRectangle2D(_line.end, _rectangle, distanceFromEndToRect);
				if (G2D_COMPARISON_STANDARD_D(distanceFromEndToRect, 0.0))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				GCollisionCheck2D left, right, top, bottom;

				TestLineToLine2D(_line, { _rectangle.min, {_rectangle.min.x, _rectangle.max.y} }, left);
				if (left == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { {_rectangle.max.x, _rectangle.min.y}, _rectangle.max }, right);
				if (right == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { {_rectangle.min.x, _rectangle.max.y}, _rectangle.max }, top);
				if (top == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { _rectangle.min, {_rectangle.max.x, _rectangle.min.y} }, bottom);
				if (bottom == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				// handle case where start and/or end of _line are inside _polygon
				GCollisionCheck2D cStart, cEnd;

				TestPointToPolygon2D(_line.start, _polygon, _numVerts, cStart);
				if (cStart == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPolygon2D(_line.start, _polygon, _numVerts, cEnd);
				if (cEnd == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				unsigned int j = _numVerts - 1;
				GCollisionCheck2D lineCollision;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToLine2D(_line, { _polygon[i], _polygon[j] }, lineCollision);
					if (lineCollision == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointD(_circle1.pos, _circle2.pos) <= (_circle1.radius + _circle2.radius) * (_circle1.radius + _circle2.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangles and width and height
				MATH2D::GVECTOR2D botLeft1{ G2D_MIN(_rectangle1.min.x, _rectangle1.max.x), G2D_MIN(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2D topRight1{ G2D_MAX(_rectangle1.min.x, _rectangle1.max.x), G2D_MAX(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2D botLeft2{ G2D_MIN(_rectangle2.min.x, _rectangle2.max.x), G2D_MIN(_rectangle2.min.y, _rectangle2.max.y) };
				MATH2D::GVECTOR2D topRight2{ G2D_MAX(_rectangle2.min.x, _rectangle2.max.x), G2D_MAX(_rectangle2.min.y, _rectangle2.max.y) };

				if (botLeft1.x > topRight2.x ||
					topRight1.x < botLeft2.x ||
					botLeft1.y > topRight2.y ||
					topRight1.y < botLeft2.y)
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// rectangle could be inside polygon
				TestPointToPolygon2D(_rectangle.min, _polygon, _numVerts, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// polygon could be inside rectangle
				TestPointToRectangle2D(_polygon[0], _rectangle, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the rectangle to every edge of the polygon
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToRectangle2D({ _polygon[i], _polygon[j] }, _rectangle, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// polygon2 could be inside polygon1
				TestPointToPolygon2D(_polygon2[0], _polygon1, _numVerts1, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the edges of polygon1 to polygon2
				unsigned int j = _numVerts1 - 1;
				for (unsigned int i = 0; i < _numVerts1; j = i++)
				{
					TestLineToPolygon2D({ _polygon1[i], _polygon1[j] }, _polygon2, _numVerts2, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric)
			{
				double rectArea;
				ImplicitLineEquationD(_trianglePoint1, { _trianglePoint3, _trianglePoint2 }, rectArea);

				if (G2D_COMPARISON_STANDARD_D(rectArea, 0.0))
				{
					return GReturn::FAILURE; // would get a devide-by-zero error
				}

				double a, b;
				ImplicitLineEquationD(_point, { _trianglePoint3, _trianglePoint2 }, a);
				ImplicitLineEquationD(_point, { _trianglePoint1, _trianglePoint3 }, b);

				_outBarycentric.alpha = a / rectArea;
				_outBarycentric.beta = b / rectArea;
				_outBarycentric.gamma = 1.0 - _outBarycentric.alpha - _outBarycentric.beta;

				return GReturn::SUCCESS;

				return GReturn::SUCCESS;
			}

		private:
			static bool PointsAreEqualF(MATH2D::GVECTOR2F _p1, MATH2D::GVECTOR2F _p2)
			{
				return (G2D_COMPARISON_STANDARD_F(_p1.x, _p2.x) && G2D_COMPARISON_STANDARD_F(_p1.y, _p2.y));
			}

			static bool PointsAreEqualD(MATH2D::GVECTOR2D _p1, MATH2D::GVECTOR2D _p2)
			{
				return (G2D_COMPARISON_STANDARD_D(_p1.x, _p2.x) && G2D_COMPARISON_STANDARD_D(_p1.y, _p2.y));
			}

			static float SqDistancePointToPointF(MATH2D::GVECTOR2F _p1, MATH2D::GVECTOR2F _p2)
			{
				return ((_p2.x - _p1.x) * (_p2.x - _p1.x)) + ((_p2.y - _p1.y) * (_p2.y - _p1.y));
			}

			static double SqDistancePointToPointD(MATH2D::GVECTOR2D _p1, MATH2D::GVECTOR2D _p2)
			{
				return ((_p2.x - _p1.x) * (_p2.x - _p1.x)) + ((_p2.y - _p1.y) * (_p2.y - _p1.y));
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH2D
	{
		class GCollision2D final
			: public I::GProxy<I::GCollision2DInterface, I::GCollision2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GCollision2D)
			GATEWARE_TYPEDEF(GCollisionCheck2D)
			// floats
			GATEWARE_STATIC_FUNCTION(ImplicitLineEquationF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLine2F)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRectangle2F)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestPointToLine2F)
			GATEWARE_STATIC_FUNCTION(TestPointToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestPointToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestPointToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestLineToLine2F)
			GATEWARE_STATIC_FUNCTION(TestLineToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestLineToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestLineToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestCircleToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestRectangleToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestRectangleToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestPolygonToPolygon2F)
			GATEWARE_STATIC_FUNCTION(FindBarycentricF)
			// doubles
			GATEWARE_STATIC_FUNCTION(ImplicitLineEquationD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLine2D)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRectangle2D)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestPointToLine2D)
			GATEWARE_STATIC_FUNCTION(TestPointToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestPointToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestPointToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestLineToLine2D)
			GATEWARE_STATIC_FUNCTION(TestLineToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestLineToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestLineToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestCircleToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestRectangleToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestRectangleToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestPolygonToPolygon2D)
			GATEWARE_STATIC_FUNCTION(FindBarycentricD)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GCOLLISION2D_H

/*---------------------------------
|	End of GCollision2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GCollision.h
----------------------------------*/
#ifndef GCOLLISION_H
#define GCOLLISION_H







namespace GW
{
	namespace I
	{
		class GCollisionInterface : public virtual GInterfaceInterface
		{
		public:

			enum class GCollisionCheck
			{
				ERROR_NO_RESULT = -3,
				ABOVE = -2,
				BELOW = -1,
				NO_COLLISION = 0,
				COLLISION = 1
			};

			// float
			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB, const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMF& _outAABB) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult, MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c, const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			// double
			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB, const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GCollision.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are separated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GCOLLISION) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GCOLLISION) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GCollisionImplementation : public virtual GCollisionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			// float
			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM)
			{
				return GReturn::FAILURE;
			}

			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB, const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane)
			{
				return GReturn::FAILURE;
			}

			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMF& _outAABB)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult, MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c, const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			//double

			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM)
			{
				return GReturn::FAILURE;
			}

			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB, const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane)
			{
				return GReturn::FAILURE;
			}

			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric)
			{
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#include <cfloat>

namespace GW
{
	namespace I
	{
		class GCollisionImplementation : public virtual GCollisionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM)
			{
				_outAABBMM.min =
				{
					{
						{
							_aabbCE.center.x - _aabbCE.extent.x,
							_aabbCE.center.y - _aabbCE.extent.y,
							_aabbCE.center.z - _aabbCE.extent.z
						}
					}
				};

				_outAABBMM.max =
				{
					{
						{
							_aabbCE.center.x + _aabbCE.extent.x,
							_aabbCE.center.y + _aabbCE.extent.y,
							_aabbCE.center.z + _aabbCE.extent.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE)
			{
				_outAABCE.center =
				{
					{
						{
							(_aabbMM.min.x + _aabbMM.max.x) * 0.5f,
							(_aabbMM.min.y + _aabbMM.max.y) * 0.5f,
							(_aabbMM.min.z + _aabbMM.max.z) * 0.5f
						}
					}
				};

				_outAABCE.extent =
				{
					{
						{
							_aabbMM.max.x - _outAABCE.center.x,
							_aabbMM.max.y - _outAABCE.center.y,
							_aabbMM.max.z - _outAABCE.center.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB,
										 const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_planePositionB,
					_planePositionA,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_planePositionC,
					_planePositionA,
					difference_ca);

				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					_outPlane.data);

				if(GW::MATH::GVector::NormalizeF(_outPlane.data, _outPlane.data) == GReturn::FAILURE)
				{
					 // ba and ca are parallel which degenerates to a line.
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::DotF(
					_outPlane.data,
					_planePositionA.xyz(),
					_outPlane.distance);

				return GReturn::SUCCESS;
			}

			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.b,
					_triangle.a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.c,
					_triangle.a,
					difference_ca);

				MATH::GVECTORF triangle_normal = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ba,
					difference_ca,
					triangle_normal);

				float triangle_area = 0.0f;
				GW::MATH::GVector::DotF(
					triangle_normal,
					triangle_normal,
					triangle_area);

				_outResult = (G_ABS(triangle_area) < 0.000001f) ? GCollisionCheck::NO_COLLISION : GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints,
													 const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				if(!_polygonPoints || _pointsCount < 3)
				{
					return GReturn::FAILURE;
				}

				auto Collinear = [&](const GW::MATH::GVECTORF p, const GW::MATH::GLINEF l)
				{
					if(p.x <= G_LARGER(l.start.x, l.end.x) && p.x <= G_SMALLER(l.start.x, l.end.x) &&
					   p.y <= G_LARGER(l.start.y, l.end.y) && p.y <= G_SMALLER(l.start.y, l.end.y))
					{
						return true;
					}

					return false;
				};

				auto Area2D = [&](const MATH::GVECTORF a, const MATH::GVECTORF b, const MATH::GVECTORF p)
				{
					float winding = 0;

					GW::MATH::GVECTORF difference_pa = {};
					GW::MATH::GVector::SubtractVectorF(
						p,
						a,
						difference_pa);

					GW::MATH::GVECTORF difference_ba = {};
					GW::MATH::GVector::SubtractVectorF(
						b,
						a,
						difference_ba);

					GW::MATH::GVector::CrossVector2F(
						difference_pa,
						difference_ba,
						winding);

					if(G_ABS(winding) < 0.000001f)
					{
						return 0;
					}
					else if(winding > 0.0f)
					{
						return 1;
					}
					else
					{
						return -1;
					}
				};

				auto IsCrossing = [&](const GW::MATH::GLINEF l1, const GW::MATH::GLINEF l2)
				{
					int winding1 = Area2D(l1.start, l1.end, l2.start);
					int winding2 = Area2D(l1.start, l1.end, l2.end);
					int winding3 = Area2D(l2.start, l2.end, l1.start);
					int winding4 = Area2D(l2.start, l2.end, l1.end);

					if(winding1 != winding2 && winding3 != winding4)
					{
						return true;
					}
					if(winding1 == 0 && Collinear(l2.start, l1))
					{
						return true;
					}
					if(winding2 == 0 && Collinear(l2.end, l1))
					{
						return true;
					}
					if(winding3 == 0 && Collinear(l1.start, l2))
					{
						return true;
					}
					if(winding4 == 0 && Collinear(l1.end, l2))
					{
						return true;
					}

					return false;
				};

				GW::MATH::GLINEF inf_line =
				{
					{
						{
							{{{_queryPoint.x , _queryPoint.y, 0.0f, 0.0f}}},
							{{{static_cast<float>(0xffffffff), _queryPoint.y}}}
						}
					}
				};

				int count = 0;
				int i = 0;

				do
				{
					GW::MATH::GLINEF side = {};
					side.start = _polygonPoints[i];
					side.end = _polygonPoints[(i + 1) % _pointsCount];

					if(IsCrossing(side, inf_line))
					{
						if(Area2D(side.start, _queryPoint, side.end) == 0)
						{
							_outResult = Collinear(_queryPoint, side) ? GCollisionCheck::COLLISION : GCollisionCheck::NO_COLLISION;
							return GReturn::SUCCESS;
						}
						count++;
					}

					i = (i + 1) % _pointsCount;
				}
				while(i != 0);

				_outResult = static_cast<GCollisionCheck>(count & 1);
				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint,
											   MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF line_a = _line.start.xyz();

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					line_a,
					difference_ba);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_ba,
					interval);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 0.000001f)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = G_CLAMP(
					interval,
					0.0f,
					1.0f);

				GW::MATH::GVector::ScaleF(
					difference_ba,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2,
														MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2)
			{
				MATH::GLINEF line1 =
				{
					{
						{
							_line1.start.xyz(),
							_line1.end.xyz()
						}
					}
				};

				MATH::GLINEF line2 =
				{
					{
						{
							_line2.start.xyz(),
							_line2.end.xyz()
						}
					}
				};

				MATH::GVECTORF direction1 = {};
				GW::MATH::GVector::SubtractVectorF(
					line1.end,
					line1.start,
					direction1);

				MATH::GVECTORF direction2 = {};
				GW::MATH::GVector::SubtractVectorF(
					line2.end,
					line2.start,
					direction2);

				MATH::GVECTORF distance = {};
				GW::MATH::GVector::SubtractVectorF(
					line1.start,
					line2.start,
					distance);

				float sq_length1 = 0.0f;
				GW::MATH::GVector::DotF(
					direction1,
					direction1,
					sq_length1);

				float sq_length2 = 0.0f;
				GW::MATH::GVector::DotF(
					direction2,
					direction2,
					sq_length2);

				float f = 0.0f;
				GW::MATH::GVector::DotF(
					direction2,
					distance,
					f);

				float interval1 = 0.0f;
				float interval2 = 0.0f;

				int use_cases = 0x00;

				// First line degenerates to a point.
				if(sq_length1 <= 0.000001f)
				{
					use_cases |= 0x01;
				}

				// Second line degenerates to a point.
				if(sq_length2 <= 0.000001f)
				{
					use_cases |= 0x02;
				}

				switch(use_cases)
				{
					// First line degenerates to a point.
					case 0x01:
					{
						interval2 = f / sq_length2;
						interval2 = G_CLAMP(
							interval2,
							0.0f,
							1.0f);
					}
					break;
					// Second line degenerates to a point.
					case 0x02:
					{
						float c = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							distance,
							c);

						interval1 = G_CLAMP(
							-c / sq_length1,
							0.0f,
							1.0f);
					}
					break;
					// Both lines degenerate to a point.
					case 0x03:
					{
						_outPoint1 = line1.start.xyz();
						_outPoint2 = line2.start.xyz();
						return GReturn::SUCCESS;
					}
					break;
					default:
					{
						float c = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							distance,
							c);

						float b = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							direction2,
							b);

						float denom = sq_length1 * sq_length2 - b * b;

						// Get interval for the first line from the second line unless lines are parallel.
						if(denom != 0.0f)
						{
							interval1 = G_CLAMP(
								(b * f - c * sq_length2) / denom,
								0.0f,
								1.0f);
						}
						else
						{
							interval1 = 0.0f;
						}

						// Get interval for the second line.
						interval2 = (b * interval1 + f) / sq_length2;

						if(interval2 < 0.0f)
						{
							interval2 = 0.0f;

							interval1 = G_CLAMP(
								-c / sq_length1,
								0.0f,
								1.0f);
						}
						else if(interval2 > 1.0f)
						{
							interval2 = 1.0f;

							interval1 = G_CLAMP(
								(b - c) / sq_length1,
								0.0f,
								1.0f);
						}
					}
					break;
				}

				GW::MATH::GVector::ScaleF(
					direction1,
					interval1,
					direction1);

				GW::MATH::GVector::AddVectorF(
					line1.start,
					direction1,
					_outPoint1);

				GW::MATH::GVector::ScaleF(
					direction2,
					interval2,
					direction2);

				GW::MATH::GVector::AddVectorF(
					line2.start,
					direction2,
					_outPoint2);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint,
											  MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF line_a = _ray.position.xyz();
				MATH::GVECTORF line_direction = _ray.direction.xyz();

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					line_direction,
					interval);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					line_direction,
					line_direction,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 0.000001f)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = interval < 0.0f ? 0.0f : interval;

				GW::MATH::GVector::ScaleF(
					line_direction,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint,
												   MATH::GVECTORF& _outPoint)
			{
				GW::MATH::GVECTORF a = _triangle.a.xyz();
				GW::MATH::GVECTORF b = _triangle.b.xyz();
				GW::MATH::GVECTORF c = _triangle.c.xyz();
				GW::MATH::GVECTORF p = _queryPoint.xyz();

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					b,
					a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					c,
					a,
					difference_ca);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					a,
					difference_pa);

				float dot1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pa,
					dot1);

				float dot2 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pa,
					dot2);

				// p is closest to vertex a
				if(dot1 <= 0.000001f && dot2 <= 0.000001f)
				{
					_outPoint = a;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pb = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					b,
					difference_pb);

				float dot3 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pb,
					dot3);

				float dot4 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pb,
					dot4);

				// p is closest to vertex b
				if(dot3 >= 0.000001f && dot4 <= dot3)
				{
					_outPoint = b;
					return GReturn::SUCCESS;
				}

				float vc = dot1 * dot4 - dot3 * dot2;

				// p is closest to edge ab
				if(vc <= 0.000001f && dot1 >= 0.000001f && dot3 <= 0.000001f)
				{
					float interval = dot1 / (dot1 - dot3);

					GW::MATH::GVector::ScaleF(
						difference_ba,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pc = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					c,
					difference_pc);

				float dot5 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pc,
					dot5);

				float dot6 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pc,
					dot6);

				// p is closest to vertex c
				if(dot5 >= 0.000001f && dot6 <= dot5)
				{
					_outPoint = c;
					return GReturn::SUCCESS;
				}

				float vb = dot6 * dot2 - dot1 * dot5;
				// p is closest to edge ac
				if(vb <= 0.000001f && dot2 >= 0.000001f && dot5 <= 0.000001f)
				{
					float interval = dot2 / (dot2 - dot5);

					GW::MATH::GVector::ScaleF(
						difference_ca,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				float va = dot3 * dot5 - dot6 * dot4;
				// p is closest to edge bc
				if(va <= 0.000001f && (dot4 - dot3) >= 0.000001f && (dot6 - dot5) >= 0.000001f)
				{
					float h = dot4 - dot3;
					float interval = h / (h + dot6 - dot5);

					GW::MATH::GVector::SubtractVectorF(
						c,
						b,
						_outPoint);

					GW::MATH::GVector::ScaleF(
						_outPoint,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						b,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				// p is closest to some point on the face
				float denom = 1.0f / (va + vb + vc);
				float v = vb * denom;
				float w = vc * denom;

				GW::MATH::GVector::ScaleF(
					difference_ba,
					v,
					_outPoint);

				GW::MATH::GVECTORF acw = {};
				GW::MATH::GVector::ScaleF(
					difference_ca,
					w,
					acw);

				GW::MATH::GVector::AddVectorF(
					acw,
					_outPoint,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint,
												MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF plane_normal = _plane.data.xyz();
				MATH::GVECTORF query_point = _queryPoint.xyz();

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					plane_normal,
					query_point,
					interval);

				interval -= _plane.distance;

				GW::MATH::GVector::ScaleF(
					plane_normal,
					interval,
					_outPoint);

				GW::MATH::GVector::SubtractVectorF(
					query_point,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint,
												 MATH::GVECTORF& _outPoint)
			{
				GW::MATH::GVECTORF direction = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint,
					_sphere.data,
					direction);

				if(GW::MATH::GVector::NormalizeF(direction.xyz(), direction) == GReturn::FAILURE)
				{
					_outPoint = _queryPoint;
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::ScaleF(
					direction,
					_sphere.radius,
					direction);

				GW::MATH::GVector::AddVectorF(
					_sphere.data.xyz(),
					direction,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint,
												  MATH::GVECTORF& _outPoint)
			{
				ClosestPointToLineF(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					_queryPoint,
					_outPoint);

				return ClosestPointToSphereF(
					{{{_outPoint.x, _outPoint.y, _outPoint.z, _capsule.radius}}},
					_queryPoint,
					_outPoint);
			}

			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint,
											   MATH::GVECTORF& _outPoint)
			{
				for(int i = 0; i < 3; i++)
				{
					_outPoint.data[i] = _queryPoint.data[i];

					_outPoint.data[i] = G_LARGER(
						_outPoint.data[i],
						_aabb.min.data[i]);

					_outPoint.data[i] = G_SMALLER(
						_outPoint.data[i],
						_aabb.max.data[i]);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 0.000001f &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 0.000001f &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint,
											  MATH::GVECTORF& _outPoint)
			{
				float xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				float yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				float zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;
				float xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				float xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				float yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;
				float wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				float wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				float wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORF obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					_obb.data->xyz(),
					difference);

				_outPoint = _obb.center.xyz();

				MATH::GVECTORF world_coord = {};

				float distance = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					// Project the difference to this axis
					GW::MATH::GVector::DotF(
						difference,
						obb_rotation[i],
						distance);

					// Clamp to boundary
					distance = G_SMALLER(
						distance,
						_obb.extent.data[i]);

					distance = G_LARGER(
						distance,
						-_obb.extent.data[i]);

					GW::MATH::GVector::ScaleF(
						obb_rotation[i],
						distance,
						world_coord);

					GW::MATH::GVector::AddVectorF(
						_outPoint,
						world_coord,
						_outPoint);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 0.000001f &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 0.000001f &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere)
			{
				if(!_pointCloud || _pointsCount < 2)
				{
					return GReturn::FAILURE;
				}

				// Find a good almost bounding sphere
				unsigned int min_x = 0;
				unsigned int max_x = 0;
				unsigned int min_y = 0;
				unsigned int max_y = 0;
				unsigned int min_z = 0;
				unsigned int max_z = 0;

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_pointCloud[i].x < _pointCloud[min_x].x)
					{
						min_x = i;
					}
					if(_pointCloud[i].x > _pointCloud[max_x].x)
					{
						max_x = i;
					}

					if(_pointCloud[i].y < _pointCloud[min_y].y)
					{
						min_y = i;
					}
					if(_pointCloud[i].y > _pointCloud[max_y].y)
					{
						max_y = i;
					}

					if(_pointCloud[i].z < _pointCloud[min_z].z)
					{
						min_z = i;
					}
					if(_pointCloud[i].z > _pointCloud[max_z].z)
					{
						max_z = i;
					}
				}

				GW::MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_x],
					_pointCloud[min_x],
					difference);

				float sq_distance_x = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_x);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_y],
					_pointCloud[min_y],
					difference);

				float sq_distance_y = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_y);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_z],
					_pointCloud[min_z],
					difference);

				float sq_distance_z = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_z);

				int min = min_x;
				int max = max_x;

				if((sq_distance_y > sq_distance_x) && (sq_distance_y > sq_distance_z))
				{
					min = min_y;
					max = max_y;
				}

				if((sq_distance_z > sq_distance_x) && (sq_distance_z > sq_distance_y))
				{
					min = min_z;
					max = max_z;
				}

				GW::MATH::GVector::AddVectorF(
					_pointCloud[min].xyz(),
					_pointCloud[max].xyz(),
					_outSphere.data);

				GW::MATH::GVector::ScaleF(
					_outSphere.data,
					0.5f,
					_outSphere.data);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max].xyz(),
					_outSphere.data,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outSphere.radius);

				_outSphere.radius = sqrtf(_outSphere.radius);

				// Improve the bound and include all points
				auto UpdateSphereBounds = [&](const MATH::GVECTORF p, MATH::GSPHEREF& outSphere)
				{
					GW::MATH::GVECTORF difference = {};
					GW::MATH::GVector::SubtractVectorF(
						p.xyz(),
						outSphere.data.xyz(),
						difference);

					float sq_distance = 0.0f;
					GW::MATH::GVector::DotF(
						difference,
						difference,
						sq_distance);

					if(sq_distance > outSphere.radius* outSphere.radius)
					{
						float distance = sqrtf(sq_distance);
						float radius = (outSphere.radius + distance) * 0.5f;
						float increase = (radius - outSphere.radius) / distance;

						GW::MATH::GVector::ScaleF(
							difference,
							increase,
							difference);

						GW::MATH::GVector::AddVectorF(
							outSphere.data,
							difference,
							outSphere.data);

						outSphere.radius = radius;
					}
				};

				for(unsigned int i = 0; i < _pointsCount; i++)
				{
					UpdateSphereBounds(
						_pointCloud[i],
						_outSphere);
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount,
												  MATH::GAABBMMF& _outAABB)
			{
				if(!_pointCloud || _pointsCount == 0)
				{
					return GReturn::FAILURE;
				}

				_outAABB.min = _pointCloud[0];
				_outAABB.max = _pointCloud[0];

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_outAABB.min.x > _pointCloud[i].x)
					{
						_outAABB.min.x = _pointCloud[i].x;
					}
					if(_outAABB.max.x < _pointCloud[i].x)
					{
						_outAABB.max.x = _pointCloud[i].x;
					}

					if(_outAABB.min.y > _pointCloud[i].y)
					{
						_outAABB.min.y = _pointCloud[i].y;
					}
					if(_outAABB.max.y < _pointCloud[i].y)
					{
						_outAABB.max.y = _pointCloud[i].y;
					}

					if(_outAABB.min.z > _pointCloud[i].z)
					{
						_outAABB.min.z = _pointCloud[i].z;
					}
					if(_outAABB.max.z < _pointCloud[i].z)
					{
						_outAABB.max.z = _pointCloud[i].z;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF point = _point.xyz();

				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					difference_ba);

				float distance_ba = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					distance_ba);
				distance_ba = sqrtf(distance_ba);

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					point,
					line.start,
					difference_pa);

				float distance_pa = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_pa,
					distance_pa);
				distance_pa = sqrtf(distance_pa);

				GW::MATH::GVECTORF difference_bp = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					point,
					difference_bp);

				float distance_bp = 0.0f;
				GW::MATH::GVector::DotF(
					difference_bp,
					difference_bp,
					distance_bp);
				distance_bp = sqrtf(distance_bp);

				_outResult = (G_COMPARISON_STANDARD_F(distance_ba, distance_pa + distance_bp)) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_point.xyz(),
					_ray.position.xyz(),
					difference_pa);

				// Point is ray position
				if(GW::MATH::GVector::NormalizeF(difference_pa, difference_pa) == GReturn::FAILURE)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(difference_pa.x - _ray.direction.x) < 0.000001f &&
				   G_ABS(difference_pa.y - _ray.direction.y) < 0.000001f &&
				   G_ABS(difference_pa.z - _ray.direction.z) < 0.000001f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle,
												GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				MATH::GPLANEF plane = {};
				if(ComputePlaneF(_triangle.a, _triangle.b, _triangle.c, plane) == GReturn::FAILURE)
				{
					// Degenerate triangle.
					return GReturn::FAILURE;
				}

				TestPointToPlaneF(
					_point,
					plane,
					_outResult);

				if(static_cast<int>(_outResult) > 0)
				{
					MATH::GVECTORF barycentric = {};
					// Compute plane already handles fail case of degenerate triangle.
					BarycentricF(_triangle.a, _triangle.b, _triangle.c, _point, barycentric);

					_outResult = (barycentric.y >= 0.0f && barycentric.z >= 0.0f && (barycentric.y + barycentric.z) <= 1.0f) ?
						GCollisionCheck::COLLISION :
						GCollisionCheck::NO_COLLISION;

					if(_outBarycentric)
					{
						*_outBarycentric = barycentric;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					_point.xyz(),
					_plane.data.xyz(),
					distance);
				distance = distance - _plane.distance;

				if(distance < -0.000001f)
				{
					_outResult = GCollisionCheck::BELOW;
				}
				else if(G_ABS(distance) <= 0.000001f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_point,
					_sphere.data.xyz(),
					difference_ba);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = sq_distance <= sq_radius ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GSPHEREF sphere = {};

				if(ClosestPointToCapsuleF(_capsule, _point, sphere.data) == GReturn::FAILURE)
				{
					// Point is center of capsule
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				sphere.radius = _capsule.radius;
				return TestPointToSphereF(
					_point,
					sphere,
					_outResult);
			}

			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb.center.x - _point.x) - _aabb.extent.x > 0.000001f ||
				   G_ABS(_aabb.center.y - _point.y) - _aabb.extent.y > 0.000001f ||
				   G_ABS(_aabb.center.z - _point.z) - _aabb.extent.z > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};

				ClosestPointToOBBF(
					_obb,
					_point,
					closest_point);

				if(G_ABS(closest_point.x - _point.x) > 0.000001f ||
				   G_ABS(closest_point.y - _point.y) > 0.000001f ||
				   G_ABS(closest_point.z - _point.z) > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};

				ClosestPointsToLineFromLineF(
					_line1,
					_line2,
					closest_point1,
					closest_point2);

				if(G_ABS(closest_point1.x - closest_point2.x) > 0.000001f ||
				   G_ABS(closest_point1.y - closest_point2.y) > 0.000001f ||
				   G_ABS(closest_point1.z - closest_point2.z) > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_line.start,
					closest_point1);

				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointToRayF(
					_ray,
					_line.end,
					closest_point2);

				return TestLineToLineF(
					_line,
					{{{closest_point1, closest_point2}}},
					_outResult);
			}

			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
											   MATH::GVECTORF* _outBarycentric)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF norm = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORF difference_line = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					line.end,
					difference_line);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					triangle.a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0f || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0f || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					float over_denom = 1.0f / dot;

					barycentric.y *= over_denom;
					barycentric.z *= over_denom;

					*_outBarycentric =
					{
						{
							{
								1.0f - barycentric.y - barycentric.z,
								barycentric.y,
								barycentric.z
							}
						}
					};
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					difference_ba,
					denom);

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToLineF(
					_line,
					_sphere.data,
					closest_point);

				return TestPointToSphereF(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointsToLineFromLineF(
					_line,
					{{{_capsule.data[0],_capsule.data[1]}}},
					closest_point1,
					closest_point2);

				return TestPointToSphereF(
					closest_point1,
					{{{closest_point2.x,closest_point2.y,closest_point2.z,_capsule.radius}}},
					_outResult);
			}

			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF extent = _aabb.extent.xyz();

				GW::MATH::GVECTORF line_midpoint = {};
				GW::MATH::GVector::AddVectorF(
					line.start,
					line.end,
					line_midpoint);

				GW::MATH::GVector::ScaleF(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORF line_mid_length = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORF origin = {};
				GW::MATH::GVector::SubtractVectorF(
					line_midpoint,
					_aabb.center.xyz(),
					origin);

				GW::MATH::GVECTORF axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(origin.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 0.000001f;
				axis.y += 0.000001f;
				axis.z += 0.000001f;

				if(G_ABS(origin.y * line_mid_length.z - origin.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.z * line_mid_length.x - origin.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.x * line_mid_length.z - origin.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start,
							_line.end
						}
					}
				};
				line.start.w = 1.0f;
				line.end.w = 1.0f;

				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorF(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorF(
					line.end,
					_obb.center,
					line.end);

				return TestLineToAABBF(
					line,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
											  MATH::GVECTORF* _outBarycentric)
			{
				MATH::GRAYF ray =
				{
					{
						{
						_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF q = {};
				GW::MATH::GVector::CrossVector3F(
					ray.direction,
					difference_ca,
					q);

				float det = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float denom = 1.0f / det;

				GW::MATH::GVECTORF s = {};
				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF r = {};
				GW::MATH::GVector::CrossVector3F(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotF(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
					_outBarycentric->x = 1.0f - barycentric.y - barycentric.z;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Ray is parallel
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;
				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				// At least one real root.
				if(c <= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				float b = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					_ray.direction.xyz(),
					b);

				// Ray is outside sphere and pointing away from it.
				if(b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// The discriminant determines if there were solutions or not.
				float discriminant = b * b - c;
				_outResult = (discriminant < 0.0f) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHEREF sphere = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineF(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return TestPointToSphereF(
					closest_point1,
					sphere,
					_outResult);
			}

			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult)
			{
				float interval1 = 0.0f;
				float interval2 = 0.0f;
				float interval3 = 0.0f;
				float interval4 = 0.0f;
				float interval5 = 0.0f;
				float interval6 = 0.0f;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0f ?
						(FLT_MAX) : (FLT_MIN);
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0f ?
						(FLT_MAX) : (FLT_MIN);
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYF ray =
				{
					{
						{
							_ray.position,
							_ray.direction.xyz()
						}
					}
				};
				ray.position.w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorF(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				return TestRayToAABBF(
					ray,
					mm,
					_outResult);
			}

			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2,
												   GCollisionCheck& _outResult)
			{
				// Half plane test if triangle1 lies completely on one side to triangle2 plane
				GW::MATH::GVECTORF difference_b2a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.b.xyz(),
					_triangle2.a.xyz(),
					difference_b2a2);

				GW::MATH::GVECTORF difference_c2a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.c.xyz(),
					_triangle2.a.xyz(),
					difference_c2a2);

				GW::MATH::GVECTORF plane2 = {};
				GW::MATH::GVector::CrossVector3F(
					difference_c2a2,
					difference_b2a2,
					plane2);

				GW::MATH::GVECTORF difference_a1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.a.xyz(),
					_triangle2.a.xyz(),
					difference_a1a2);

				GW::MATH::GVECTORF det1 = {};
				GW::MATH::GVector::DotF(
					difference_a1a2,
					plane2,
					det1.x);

				GW::MATH::GVECTORF difference_b1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.b.xyz(),
					_triangle2.a.xyz(),
					difference_b1a2);

				GW::MATH::GVector::DotF(
					difference_b1a2,
					plane2,
					det1.y);

				GW::MATH::GVECTORF difference_c1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.c.xyz(),
					_triangle2.a.xyz(),
					difference_c1a2);

				GW::MATH::GVector::DotF(
					difference_c1a2,
					plane2,
					det1.z);

				if(((det1.x * det1.y) > 0.0f) && ((det1.x * det1.z) > 0.0f))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Half plane test if triangle2 lies completely on one side to triangle1 plane
				GW::MATH::GVECTORF difference_b1a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.b.xyz(),
					_triangle1.a.xyz(),
					difference_b1a1);

				GW::MATH::GVECTORF difference_c1a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.c.xyz(),
					_triangle1.a.xyz(),
					difference_c1a1);

				GW::MATH::GVECTORF plane1 = {};
				GW::MATH::GVector::CrossVector3F(
					difference_c1a1,
					difference_b1a1,
					plane1);

				GW::MATH::GVECTORF difference_a2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.a.xyz(),
					_triangle1.a.xyz(),
					difference_a2a1);

				GW::MATH::GVECTORF det2 = {};
				GW::MATH::GVector::DotF(
					difference_a2a1,
					plane1,
					det2.x);

				GW::MATH::GVECTORF difference_b2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.b.xyz(),
					_triangle1.a.xyz(),
					difference_b2a1);

				GW::MATH::GVector::DotF(
					difference_b2a1,
					plane1,
					det2.y);

				GW::MATH::GVECTORF difference_c2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.c.xyz(),
					_triangle1.a.xyz(),
					difference_c2a1);

				GW::MATH::GVector::DotF(
					difference_c2a1,
					plane1,
					det2.z);

				if(((det2.x * det2.y) > 0.0f) && ((det2.x * det2.z) > 0.0f))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Bring both triangles into canonical form
				MATH::GTRIANGLEF triangle1 = {};
				MATH::GTRIANGLEF triangle2 = {};

				if(det1.x > 0.0f)
				{
					if(det1.y > 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
							_triangle2.b
								}
							}
						};
					}
					else if(det1.z > 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
				}
				else if(det1.x < 0.0f)
				{
					if(det1.y < 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else if(det1.z < 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
				}
				else
				{
					if(det1.y < 0.0f)
					{
						if(det1.z >= 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else if(det1.y > 0.0f)
					{
						if(det1.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else
					{
						if(det1.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
						else if(det1.z < 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const float* a, const float* b, const float* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(c2, b2, b1) <= 0.0f)
									{
										if(Orient2D(a1, a2, b1) > 0.0f)
										{
											return (Orient2D(a1, b2, b1) <= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0f)
											{
												return (Orient2D(b1, c1, a2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0f)
										{
											if(Orient2D(c2, b2, c1) <= 0.0f)
											{
												return (Orient2D(b1, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(b1, c1, c2) >= 0.0f)
										{
											return (Orient2D(a1, a2, c1) >= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0f)
											{
												return (Orient2D(c2, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(a1, a2, b1) >= 0.0f)
									{
										return (Orient2D(a1, b1, c2) >= 0.0f) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0f)
										{
											return (Orient2D(c1, a1, a2) >= 0.0f) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(a1, a2, c1) >= 0.0f)
										{
											if(Orient2D(a1, c1, c2) >= 0.0f) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0f) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0f)
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORF normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLEF tri2_1 = {};
							GW::MATH::GTRIANGLEF tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				if(det2.x > 0.0f)
				{
					if(det2.y > 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z > 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else if(det2.x < 0.0f)
				{
					if(det2.y < 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z < 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else
				{
					if(det2.y < 0.0f)
					{
						if(det2.z >= 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
					}
					else if(det2.y > 0.0f)
					{
						if(det2.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
					}
					else
					{
						if(det2.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else if(det2.z < 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const float* a, const float* b, const float* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(c2, b2, b1) <= 0.0f)
									{
										if(Orient2D(a1, a2, b1) > 0.0f)
										{
											return (Orient2D(a1, b2, b1) <= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0f)
											{
												return (Orient2D(b1, c1, a2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0f)
										{
											if(Orient2D(c2, b2, c1) <= 0.0f)
											{
												return (Orient2D(b1, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(b1, c1, c2) >= 0.0f)
										{
											return (Orient2D(a1, a2, c1) >= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0f)
											{
												return (Orient2D(c2, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(a1, a2, b1) >= 0.0f)
									{
										return (Orient2D(a1, b1, c2) >= 0.0f) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0f)
										{
											return (Orient2D(c1, a1, a2) >= 0.0f) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(a1, a2, c1) >= 0.0f)
										{
											if(Orient2D(a1, c1, c2) >= 0.0f) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0f) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0f)
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORF normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLEF tri2_1 = {};
							GW::MATH::GTRIANGLEF tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				// Edges confirmed to form a line where the triangle planes meet. Check if triangles are within an interval.
				GW::MATH::GVECTORF difference_a2b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle2.a,
					triangle1.b,
					difference_a2b1);

				GW::MATH::GVECTORF difference_a1b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle1.a,
					triangle1.b,
					difference_a1b1);

				GW::MATH::GVector::CrossVector3F(
					difference_a1b1,
					difference_a2b1,
					plane1);

				GW::MATH::GVECTORF difference_b2b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle2.b,
					triangle1.b,
					difference_b2b1);

				float dot1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_b2b1,
					plane1,
					dot1);

				if(dot1 > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					triangle2.a,
					triangle1.a,
					difference_a2a1);

				GW::MATH::GVector::SubtractVectorF(
					triangle1.c,
					triangle1.a,
					difference_c1a1);

				GW::MATH::GVector::CrossVector3F(
					difference_c1a1,
					difference_a2a1,
					plane1);

				GW::MATH::GVector::SubtractVectorF(
					triangle2.c,
					triangle1.a,
					difference_c2a1);

				GW::MATH::GVector::DotF(
					difference_c2a1,
					plane1,
					dot1);

				if(dot1 > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane,
												GCollisionCheck& _outResult)
			{
				GCollisionCheck plane_test;

				TestPointToPlaneF(
					_triangle.a,
					_plane,
					plane_test);
				_outResult = plane_test;

				if (static_cast<int>(_outResult) > 0)
				{
					return GReturn::SUCCESS;
				}

				TestPointToPlaneF(
					_triangle.b,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPlaneF(
					_triangle.c,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere,
												 GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToTriangleF(
					_triangle,
					_sphere.data,
					closest_point);

				return TestPointToSphereF(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule,
												  GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToTriangleF(
					_triangle,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointToTriangleF(
					_triangle,
					_capsule.data[1],
					closest_point2);

				return TestLineToCapsuleF(
					{{{closest_point1, closest_point2}}},
					_capsule,
					_outResult);
			}

			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF right = {{{1,0,0,0}}};
				GW::MATH::GVECTORF up = {{{0,1,0,0}}};
				GW::MATH::GVECTORF forward = {{{0,0,1,0}}};

				GW::MATH::GVECTORF v0 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.a.xyz(),
					_aabb.center.xyz(),
					v0);

				GW::MATH::GVECTORF v1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.b.xyz(),
					_aabb.center.xyz(),
					v1);

				GW::MATH::GVECTORF v2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.c.xyz(),
					_aabb.center.xyz(),
					v2);

				GW::MATH::GVECTORF f0 = {};
				GW::MATH::GVector::SubtractVectorF(
					v1,
					v0,
					f0);

				GW::MATH::GVECTORF f1 = {};
				GW::MATH::GVector::SubtractVectorF(
					v2,
					v1,
					f1);

				GW::MATH::GVECTORF f2 = {};
				GW::MATH::GVector::SubtractVectorF(
					v0,
					v2,
					f2);

				GW::MATH::GVECTORF axis[9] = {};

				GW::MATH::GVector::CrossVector3F(
					right,
					f0,
					axis[0]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f0,
					axis[1]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f0,
					axis[2]);

				GW::MATH::GVector::CrossVector3F(
					right,
					f1,
					axis[3]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f1,
					axis[4]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f1,
					axis[5]);

				GW::MATH::GVector::CrossVector3F(
					right,
					f2,
					axis[6]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f2,
					axis[7]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f2,
					axis[8]);

				float p0 = 0.0f;
				float p1 = 0.0f;
				float p2 = 0.0f;
				float r = 0.0f;
				GW::MATH::GVECTORF dots = {};

				for(int i = 0; i < 9; i++)
				{
					GW::MATH::GVector::DotF(
						v0,
						axis[i],
						p0);
					GW::MATH::GVector::DotF(
						v1,
						axis[i],
						p1);
					GW::MATH::GVector::DotF(
						v2,
						axis[i],
						p2);

					GW::MATH::GVector::DotF(
						right,
						axis[i],
						dots.x);
					GW::MATH::GVector::DotF(
						up,
						axis[i],
						dots.y);
					GW::MATH::GVector::DotF(
						forward,
						axis[i],
						dots.z);

					r =
						_aabb.extent.x * G_ABS(dots.x) +
						_aabb.extent.y * G_ABS(dots.y) +
						_aabb.extent.z * G_ABS(dots.z);

					if(G_LARGER(-G_LARGER(p0, -G_LARGER(p1, p2)),
								G_SMALLER(p0, G_SMALLER(p1, p2))) > r)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test the 3 axis corresponding to the face normals of the AABB
				if(G_LARGER(v0.x, G_LARGER(v1.x, v2.x)) < -_aabb.extent.x ||
				   G_SMALLER(v0.x, G_SMALLER(v1.x, v2.x)) > _aabb.extent.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.y, G_LARGER(v1.y, v2.y)) < -_aabb.extent.y ||
				   G_SMALLER(v0.y, G_SMALLER(v1.y, v2.y)) > _aabb.extent.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.z, G_LARGER(v1.z, v2.z)) < -_aabb.extent.z ||
				   G_SMALLER(v0.z, G_SMALLER(v1.z, v2.z)) > _aabb.extent.z)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test separating axis to triangle face normal
				GW::MATH::GPLANEF plane;

				ComputePlaneF(
					_triangle.a,
					_triangle.b,
					_triangle.c,
					plane);

				return TestPlaneToAABBF(
					plane,
					_aabb,
					_outResult);
			}

			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a,
							_triangle.b,
							_triangle.c
						}
					}
				};
				triangle.a.w = 1.0f;
				triangle.b.w = 1.0f;
				triangle.c.w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.a,
					triangle.a);
				GW::MATH::GVector::AddVectorF(
					triangle.a,
					_obb.center,
					triangle.a);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.b,
					triangle.b);
				GW::MATH::GVector::AddVectorF(
					triangle.b,
					_obb.center,
					triangle.b);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.c,
					triangle.c);
				GW::MATH::GVector::AddVectorF(
					triangle.c,
					_obb.center,
					triangle.c);

				return TestTriangleToAABBF(
					triangle,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					_plane1.data.xyz(),
					_plane2.data.xyz(),
					cross);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					cross,
					cross,
					dot);

				_outResult = (dot < 0.000001f) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					_sphere.data.xyz(),
					_plane.data.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= _sphere.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				float distance_start = 0.0f;
				GW::MATH::GVector::DotF(
					_capsule.data[0].xyz(),
					_plane.data.xyz(),
					distance_start);
				distance_start -= _plane.distance;

				float distance_end = 0.0f;
				GW::MATH::GVector::DotF(
					_capsule.data[1].xyz(),
					_plane.data.xyz(),
					distance_end);
				distance_end -= _plane.distance;

				if(distance_start * distance_end < 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(distance_start) <= _capsule.radius || G_ABS(distance_end) <= _capsule.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = (distance_start > 0.0f) ?
					GCollisionCheck::ABOVE :
					GCollisionCheck::BELOW;
				return GReturn::SUCCESS;

			}

			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF plane_normal = _plane.data.xyz();

				float interval =
					_aabb.extent.x * G_ABS(_plane.x) +
					_aabb.extent.y * G_ABS(_plane.y) +
					_aabb.extent.z * G_ABS(_plane.z);

				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					plane_normal,
					_aabb.center.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF plane_normal = _plane.data.xyz();

				float xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				float yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				float zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;

				float xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				float xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				float yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;

				float wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				float wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				float wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORF obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				float interval = 0.0f;
				float s = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					GW::MATH::GVector::DotF(
						plane_normal,
						obb_rotation[i],
						s);

					interval += _obb.extent.data[i] * G_ABS(s);
				}

				GW::MATH::GVector::DotF(
					plane_normal,
					_obb.center.xyz(),
					s);

				s -= _plane.distance;

				if(G_ABS(s) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (s > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_sphere1.data.xyz(),
					_sphere2.data.xyz(),
					difference_ba);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_distance);

				float sq_radii = _sphere1.radius + _sphere2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule,
												GCollisionCheck& _outResult)
			{
				// Compute squared distance between the sphere center and capsule's start and end.
				float sq_distance = 0.0f;
				SqDistancePointToLineF(
					_sphere.data,
					{{{_capsule.data[0], _capsule.data[1]}}},
					sq_distance);

				float sq_radii = _sphere.radius + _capsule.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					_aabb,
					mm);

				float sq_distance = 0.0f;
				SqDistancePointToAABBF(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToOBBF(
					_obb,
					_sphere.data.xyz(),
					closest_point);

				GW::MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					closest_point,
					_sphere.data.xyz(),
					difference);

				float sq_radius = _sphere.radius * _sphere.radius;

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance);

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2,
												 GCollisionCheck& _outResult)
			{
				MATH::GVECTORF closest1 = {};
				MATH::GVECTORF closest2 = {};

				ClosestPointsToLineFromLineF(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					closest1,
					closest2);

				MATH::GVECTORF difference_ab = {};
				GW::MATH::GVector::SubtractVectorF(
					closest1,
					closest2,
					difference_ab);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ab,
					difference_ab,
					sq_distance);

				float sq_radii = _capsule1.radius + _capsule2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				// Expand AABB extents by capsule's radius.
				GW::MATH::GVECTORF center = _aabb.center.xyz();
				GW::MATH::GVECTORF extent = _aabb.extent.xyz();
				extent.x += _capsule.radius;
				extent.y += _capsule.radius;
				extent.z += _capsule.radius;

				GW::MATH::GVECTORF line_midpoint = {};
				GW::MATH::GVector::AddVectorF(
					_capsule.data[0].xyz(),
					_capsule.data[1].xyz(),
					line_midpoint);

				GW::MATH::GVector::ScaleF(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORF line_mid_length = {};
				GW::MATH::GVector::SubtractVectorF(
					_capsule.data[1].xyz(),
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORF o = {};
				GW::MATH::GVector::SubtractVectorF(
					line_midpoint,
					center,
					o);

				GW::MATH::GVECTORF axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(o.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 0.000001f;
				axis.y += 0.000001f;
				axis.z += 0.000001f;

				if(G_ABS(o.y * line_mid_length.z - o.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.z * line_mid_length.x - o.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.x * line_mid_length.z - o.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GCAPSULEF capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);
				GW::MATH::GVector::AddVectorF(
					capsule.data[0],
					_obb.center,
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);
				GW::MATH::GVector::AddVectorF(
					capsule.data[1],
					_obb.center,
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				return TestCapsuleToAABBF(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GOBBF obb =
				{
					{
						{
							_aabb.center,
							_aabb.extent,
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				return TestOBBToOBBF(
					obb,
					_obb,
					_outResult);
			}

			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult)
			{
				// Convert quaternions into 3 axes for both OBB1 and OBB2.
				float xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
				float yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
				float zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

				float xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
				float xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
				float yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

				float wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
				float wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
				float wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

				MATH::GVECTORF obb1_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
				yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
				zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

				xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
				xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
				yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

				wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
				wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
				wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

				MATH::GVECTORF obb2_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				float projected_radii = 0.0f;
				float projected_radii_1 = 0.0f;
				float projected_radii_2 = 0.0f;
				float test_axis = 0.0f;

				float rotation[3][3] = {};
				float abs_rotation[3][3] = {};

				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						GW::MATH::GVector::DotF(
							obb1_rotation[i],
							obb2_rotation[j],
							rotation[i][j]);
					}
				}

				// Get translation and then bring it into a's coordinate frame.
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_obb2.center,
					_obb1.center,
					difference_ba);

				MATH::GVECTORF translation_vec = {};
				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[0],
					translation_vec.x);

				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[1],
					translation_vec.y);

				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[2],
					translation_vec.z);

				// Get common values while maintaining numerical precision.
				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						abs_rotation[i][j] =
							G_ABS(rotation[i][j]) + 0.000001f;
					}
				}

				// Test axes for OBB1 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 = _obb1.extent.data[i];

					projected_radii_2 =
						_obb2.extent.data[0] * abs_rotation[i][0] +
						_obb2.extent.data[1] * abs_rotation[i][1] +
						_obb2.extent.data[2] * abs_rotation[i][2];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(translation_vec.data[i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test axes for OBB2 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 =
						_obb1.extent.data[0] * abs_rotation[0][i] +
						_obb1.extent.data[1] * abs_rotation[1][i] +
						_obb1.extent.data[2] * abs_rotation[2][i];

					projected_radii_2 = _obb2.extent.data[i];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(
						translation_vec.data[0] * rotation[0][i] +
						translation_vec.data[1] * rotation[1][i] +
						translation_vec.data[2] * rotation[2][i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test OBB1 x & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[1][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][0] -
					translation_vec.data[1] * rotation[2][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[1][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][1] -
					translation_vec.data[1] * rotation[2][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[1][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][1] +
					_obb2.extent.data[1] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][2] -
					translation_vec.data[1] * rotation[2][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][0] -
					translation_vec.data[2] * rotation[0][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][1] -
					translation_vec.data[2] * rotation[0][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][1] +
					_obb2.extent.data[1] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][2] -
					translation_vec.data[2] * rotation[0][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][0] +
					_obb1.extent.data[1] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][0] -
					translation_vec.data[0] * rotation[1][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][1] +
					_obb1.extent.data[1] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][1] -
					translation_vec.data[0] * rotation[1][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][2] +
					_obb1.extent.data[1] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][1] +
					_obb2.extent.data[1] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][2] -
					translation_vec.data[0] * rotation[1][2]);

				_outResult = test_axis > projected_radii ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle,
													GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint,
													MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection,
													float& _outInterval)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF norm = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORF difference_line = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					line.end,
					difference_line);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					triangle.a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0f || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0f || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float over_denom = 1.0f / dot;
				barycentric.y *= over_denom;
				barycentric.z *= over_denom;
				barycentric.x = 1.0f - barycentric.y - barycentric.z;
				_outInterval = interval * over_denom;

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
						barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
						barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												 float& _outInterval)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					difference_ba,
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					_outDirection = difference_ba;
					GW::MATH::GVector::NormalizeF(
						_outDirection,
						_outDirection);

					GW::MATH::GVector::ScaleF(
						difference_ba,
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_line.start.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					num -= _plane.distance;

					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												  float& _outInterval)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					_sphere.data.xyz(),
					difference_ba);

				GW::MATH::GVECTORF dir = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					dir);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					dir,
					dir,
					sq_length);

				if(GW::MATH::GVector::NormalizeF(dir, dir) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				float b = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					dir,
					b);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outDirection = dir;
				_outInterval = -b - sqrtf(discriminant);

				if(_outInterval <= 0.0f)
				{
					// Line is contained in sphere.
					// Clamp to line start.
					_outInterval = 0.0f;
					_outContactPoint = line.start;
				}
				else if(_outInterval * _outInterval >= sq_length)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}
				else
				{
					GW::MATH::GVector::ScaleF(
						_outDirection,
						_outInterval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_outContactPoint,
						line.start,
						_outContactPoint);
				}

				_outResult = GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												   float& _outInterval)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointsToLineFromLineF(
					_line,
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					closest_point2);

				MATH::GSPHEREF sphere = {};
				sphere.data = closest_point2;
				sphere.radius = _capsule.radius;

				return IntersectLineToSphereF(
					_line,
					sphere,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval);
			}

			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
												MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												float& _outInterval)
			{
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				// TODO div by 0
				float interval1 = (_aabb.min.x - _line.start.x) / _outDirection.x;
				float interval2 = (_aabb.max.x - _line.start.x) / _outDirection.x;

				float interval3 = (_aabb.min.y - _line.start.y) / _outDirection.y;
				float interval4 = (_aabb.max.y - _line.start.y) / _outDirection.y;

				float interval5 = (_aabb.min.z - _line.start.z) / _outDirection.z;
				float interval6 = (_aabb.max.z - _line.start.z) / _outDirection.z;

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f || interval_min > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0f) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_line.start.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
											   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
											   float& _outInterval)
			{
				MATH::GLINEF line = {};
				line.start = _line.start;
				line.start.w = 1.0f;
				line.end = _line.end;
				line.end.w = 1.0f;

				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorF(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorF(
					line.end,
					_obb.center,
					line.end);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				if(IntersectLineToAABBF(
					line,
					mm,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric,
												   float& _outInterval)
			{
				MATH::GRAYF ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF q = {};
				GW::MATH::GVector::CrossVector3F(
					ray.direction,
					difference_ca,
					q);

				float det = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float denom = 1.0f / det;

				GW::MATH::GVECTORF s = {};
				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF r = {};
				GW::MATH::GVector::CrossVector3F(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotF(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				barycentric.x = 1.0f - barycentric.y - barycentric.z;

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				GW::MATH::GVECTORF v = {};
				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					ray.position,
					v);
				GW::MATH::GVector::DotF(
					v,
					v,
					_outInterval);

				_outInterval = sqrtf(_outInterval);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult,
												MATH::GVECTORF& _outContactPoint,
												float& _outInterval)
			{
				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					GW::MATH::GVector::ScaleF(
						_ray.direction.xyz(),
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_ray.position.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactPoint,
												 float& _outInterval)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				float b = 0.0f;
				MATH::GVECTORF direction_n = _ray.direction.xyz();
				GW::MATH::GVector::DotF(
					difference_ba,
					direction_n,
					b);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c = c - _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = -b - sqrtf(discriminant);

				// If t is negative, ray started inside sphere so clamp t to zero
				if(_outInterval < 0.0f)
				{
					_outInterval = 0.0f;
				}

				GW::MATH::GVector::ScaleF(
					direction_n,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactPoint,
												  float& _outInterval)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHEREF sphere = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineF(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectRayToSphereF(
					_ray,
					sphere,
					_outResult,
					_outContactPoint,
					_outInterval);
			}

			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
											   MATH::GVECTORF& _outContactPoint,
											   float& _outInterval)
			{
				float interval1 = 0.0f;
				float interval2 = 0.0f;
				float interval3 = 0.0f;
				float interval4 = 0.0f;
				float interval5 = 0.0f;
				float interval6 = 0.0f;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0f) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleF(
					_ray.direction.xyz(),
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
											  MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYF ray = {};
				ray.position = _ray.position;
				ray.position.w = 1.0f;
				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorF(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				IntersectRayToAABBF(
					ray,
					mm,
					_outResult,
					_outContactPoint,
					_outInterval);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2,
													GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													float& _outDistance)
			{
				TestSphereToSphereF(
					_sphere1,
					_sphere2,
					_outResult);

				if (static_cast<int>(_outResult) < 1)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					_sphere2.data.xyz(),
					_sphere1.data.xyz(),
					_outDirection);

				GW::MATH::GVector::NormalizeF(
					_outDirection,
					_outDirection);

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_sphere1.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorF(
					_sphere1.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				GW::MATH::GVector::ScaleF(
					_outDirection,
					-_sphere2.radius,
					_outContactClosest2);

				GW::MATH::GVector::AddVectorF(
					_sphere2.data.xyz(),
					_outContactClosest2,
					_outContactClosest2);

				GW::MATH::GVECTORF difference = {};

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_outContactClosest2,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule,
													 GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													 MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													 float& _outDistance)
			{
				MATH::GSPHEREF sphere = {};

				ClosestPointToLineF(
					{{{_capsule.data[0], _capsule.data[1]}}},
					_sphere.data,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectSphereToSphereF(
					_sphere,
					sphere,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												  MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					_aabb,
					mm);

				float sq_distance = 0.0f;
				SqDistancePointToAABBF(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				if(_outResult < GCollisionCheck::COLLISION)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					_aabb.center.xyz(),
					_sphere.data.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_sphere.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorF(
					_sphere.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				for(int i = 0; i < 3; i++)
				{
					_outContactClosest2.data[i] = _sphere.data.data[i];

					_outContactClosest2.data[i] = G_LARGER(
						_outContactClosest2.data[i],
						mm.min.data[i]);

					_outContactClosest2.data[i] = G_SMALLER(
						_outContactClosest2.data[i],
						mm.max.data[i]);
				}

				// Point is inside AABB so clamp to closest face
				if(G_ABS(_sphere.x - _outContactClosest2.x) < 0.000001f ||
				   G_ABS(_sphere.y - _outContactClosest2.y) < 0.000001f ||
				   G_ABS(_sphere.z - _outContactClosest2.z) < 0.000001f)
				{
					GW::MATH::GVECTORF translation = {};
					float low = static_cast<float>(0xffffffff);
					float val = 0.0f;

					val = mm.max.x - _sphere.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0f, 0.0f}}};
						low = G_ABS(val);
					}

					val = _sphere.x - mm.min.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0f, 0.0f}}};
						low = G_ABS(val);
					}

					val = mm.max.y - _sphere.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, val, 0.0f}}};
						low = G_ABS(val);
					}

					val = _sphere.y - mm.min.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, val, 0.0f}}};
						low = G_ABS(val);
					}

					val = mm.max.z - _sphere.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, 0.0f, val}}};
						low = G_ABS(val);
					}

					val = _sphere.z - mm.min.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, 0.0f, val}}};
						low = G_ABS(val);
					}

					GW::MATH::GVector::AddVectorF(
						_outContactClosest2,
						translation,
						_outContactClosest2);
				}

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_outContactClosest1,
					_outDirection);

				GW::MATH::GVector::DotF(
					_outDirection,
					_outDirection,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												 MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GSPHEREF sphere = {};
				sphere.data = _sphere.data;
				sphere.radius = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					sphere.data,
					sphere.data);
				GW::MATH::GVector::AddVectorF(
					sphere.data,
					_obb.center,
					sphere.data);
				sphere.radius = _sphere.radius;

				IntersectSphereToAABBF(
					sphere,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2,
													  GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													  MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													  float& _outDistance)
			{
				MATH::GSPHEREF sphere1 = {};
				MATH::GSPHEREF sphere2 = {};

				ClosestPointsToLineFromLineF(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					sphere1.data,
					sphere2.data);

				sphere1.radius = _capsule1.radius;
				sphere2.radius = _capsule2.radius;

				return IntersectSphereToSphereF(
					sphere1,
					sphere2,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												   MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				// Extend AABB by capsule radius
				MATH::GAABBMMF aabbMM =
				{
					{
						{
							{{{_aabb.min.x - _capsule.radius, _aabb.min.y - _capsule.radius, _aabb.min.z - _capsule.radius , 0.0f}}},
							{{{_aabb.max.x + _capsule.radius, _aabb.max.y + _capsule.radius, _aabb.max.z + _capsule.radius}}}
						}
					}
				};

				MATH::GRAYF ray = {};
				ray.position = _capsule.data[0].xyz();

				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					_capsule.data[0].xyz(),
					ray.direction);

				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				IntersectRayToAABBF(
					ray,
					aabbMM,
					_outResult,
					_outContactClosest1,
					_outDistance);

				if (static_cast<int>(_outResult) <= 0 || _outDistance > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Flags to determine the region
				int u = 0;
				int v = 0;

				if(_outContactClosest1.x < _aabb.min.x)
				{
					u |= 1;
				}
				if(_outContactClosest1.x > _aabb.max.x)
				{
					v |= 1;
				}

				if(_outContactClosest1.y < _aabb.min.y)
				{
					u |= 2;
				}
				if(_outContactClosest1.y > _aabb.max.y)
				{
					v |= 2;
				}

				if(_outContactClosest1.z < _aabb.min.z)
				{
					u |= 4;
				}
				if(_outContactClosest1.z > _aabb.max.z)
				{
					v |= 4;
				}

				int m = u + v;

				auto Corner = [](const MATH::GAABBMMF box, const int n)->GW::MATH::GVECTORF
				{
					if(n & 1)
					{
						return GW::MATH::GVECTORF
						{
							{{box.max.x, box.max.y, box.max.z}}
						};
					}
					else
					{
						return GW::MATH::GVECTORF
						{
							{{box.min.x, box.min.y, box.min.z}}
						};
					}
				};

				GW::MATH::GCAPSULEF capsule;
				capsule.data[0] = Corner(aabbMM, v);

				// Vertex Region
				if(m == 7)
				{
					float tmin = static_cast<float>(0xffffffff);

					capsule.data[1] = Corner(aabbMM, v ^ 1);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 2);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 4);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					if(tmin == static_cast<float>(0xffffffff))
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}

					_outDistance = tmin;

					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if((m & (m - 1)) == 0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				capsule.data[1] = capsule.data[0];
				capsule.data[0] = Corner(aabbMM, u ^ 7);

				return IntersectLineToCapsuleF(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					capsule,
					_outResult,
					_outContactClosest1,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												  MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				MATH::GCAPSULEF capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				IntersectCapsuleToAABBF(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult,
												MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection,
												float& _outDistance)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				MATH::GAABBMMF aabb = {};
				aabb.min.x = G_LARGER(_aabb1.center.x - _aabb1.extent.x, _aabb2.center.x - _aabb2.extent.x);
				aabb.max.x = G_SMALLER(_aabb1.center.x + _aabb1.extent.x, _aabb2.center.x + _aabb2.extent.x);
				aabb.min.y = G_LARGER(_aabb1.center.y - _aabb1.extent.y, _aabb2.center.y - _aabb2.extent.y);
				aabb.max.y = G_SMALLER(_aabb1.center.y + _aabb1.extent.y, _aabb2.center.y + _aabb2.extent.y);
				aabb.min.z = G_LARGER(_aabb1.center.z - _aabb1.extent.z, _aabb2.center.z - _aabb2.extent.z);
				aabb.max.z = G_SMALLER(_aabb1.center.z + _aabb1.extent.z, _aabb2.center.z + _aabb2.extent.z);

				GW::MATH::GVECTORF difference = {};

				GW::MATH::GVector::SubtractVectorF(
					aabb.max,
					aabb.min,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				GW::MATH::GVector::SubtractVectorF(
					_aabb2.center,
					_aabb1.center,
					_outDirection);

				GW::MATH::GVector::NormalizeF(
					_outDirection,
					_outDirection);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			//static GReturn IntersectAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
			//								   MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
			//								   MATH::GVECTORF& _outDirection, float& _outDistance)
			//{
			//	return IntersectOBBToOBBF(
			//		{_aabb.center, _aabb.extent},
			//		_obb,
			//		_outResult,
			//		_outContactClosest1,
			//		_outContactClosest2,
			//		_outDirection,
			//		_outDistance);
			//}

			//static GReturn IntersectOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult,
			//								  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
			//								  MATH::GVECTORF& _outDirection, float& _outDistance)
			//{
			//	// Convert quaternions into 3 axes for both OBB1 and OBB2.
			//	float xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
			//	float yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
			//	float zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

			//	float xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
			//	float xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
			//	float yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

			//	float wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
			//	float wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
			//	float wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

			//	MATH::GVECTORF obb1_rotation[3] =
			//	{
			//		{ 1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2 },
			//		{ xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2 },
			//		{ xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2 }
			//	};

			//	xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
			//	yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
			//	zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

			//	xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
			//	xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
			//	yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

			//	wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
			//	wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
			//	wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

			//	MATH::GVECTORF obb2_rotation[3] =
			//	{
			//		{ 1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2 },
			//		{ xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2 },
			//		{ xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2 }
			//	};

			//	float projected_radii = 0.0f;
			//	float projected_radii_1 = 0.0f;
			//	float projected_radii_2 = 0.0f;
			//	float test_axis = 0.0f;

			//	float rotation[3][3] = {};
			//	float abs_rotation[3][3] = {};

			//	for(int i = 0; i < 3; i++)
			//	{
			//		for(int j = 0; j < 3; j++)
			//		{
			//			GW::MATH::GVector::DotF(
			//				obb1_rotation[i],
			//				obb2_rotation[j],
			//				rotation[i][j]);
			//		}
			//	}

			//	// Get translation and then bring it into a's coordinate frame.
			//	MATH::GVECTORF difference_ba = {};
			//	GW::MATH::GVector::SubtractVectorF(
			//		_obb2.center,
			//		_obb1.center,
			//		difference_ba);

			//	MATH::GVECTORF translation_vec = {};
			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[0],
			//		translation_vec.x);

			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[1],
			//		translation_vec.y);

			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[2],
			//		translation_vec.z);

			//	// Get common values while maintaining numerical precision.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		for(int j = 0; j < 3; j++)
			//		{
			//			abs_rotation[i][j] =
			//				G_ABS(rotation[i][j]) + 0.000001f;
			//		}
			//	}

			//	_outDistance = static_cast<float>(0x0);

			//	auto GetInfo = [&](
			//		float axis,
			//		float radii_1,
			//		float radii_2,
			//		GW::MATH::GVECTORF vec1,
			//		GW::MATH::GVECTORF* vec2,
			//		GW::MATH::GVECTORF& dir,
			//		float& distance)
			//	{
			//		float x = G_ABS(radii_1 - (axis - radii_2));

			//		if(x < distance)
			//		{
			//			distance = x;

			//			if(vec2)
			//			{
			//				GW::MATH::GVector::CrossVector3F(
			//					vec1,
			//					vec2[0],
			//					dir);

			//				GW::MATH::GVector::NormalizeF(
			//					dir,
			//					dir);
			//			}
			//			else
			//			{
			//				GW::MATH::GVector::NormalizeF(
			//					vec1,
			//					dir);
			//			}
			//		}
			//	};

			//	// Test axes for OBB1 x, y, z.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		projected_radii_1 = _obb1.extent.data[i];

			//		projected_radii_2 =
			//			_obb2.extent.data[0] * abs_rotation[i][0] +
			//			_obb2.extent.data[1] * abs_rotation[i][1] +
			//			_obb2.extent.data[2] * abs_rotation[i][2];

			//		projected_radii = projected_radii_1 + projected_radii_2;

			//		test_axis = G_ABS(translation_vec.data[i]);

			//		if(test_axis > projected_radii)
			//		{
			//			_outResult = GCollisionCheck::NO_COLLISION;
			//			return GReturn::SUCCESS;
			//		}
			//		else
			//		{
			//			GetInfo(
			//				test_axis,
			//				projected_radii_1,
			//				projected_radii_2,
			//				obb1_rotation[i],
			//				nullptr,
			//				_outDirection,
			//				_outDistance);
			//		}
			//	}

			//	// Test axes for OBB2 x, y, z.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		projected_radii_1 =
			//			_obb1.extent.data[0] * abs_rotation[0][i] +
			//			_obb1.extent.data[1] * abs_rotation[1][i] +
			//			_obb1.extent.data[2] * abs_rotation[2][i];

			//		projected_radii_2 = _obb2.extent.data[i];

			//		projected_radii = projected_radii_1 + projected_radii_2;

			//		test_axis = G_ABS(
			//			translation_vec.data[0] * rotation[0][i] +
			//			translation_vec.data[1] * rotation[1][i] +
			//			translation_vec.data[2] * rotation[2][i]);

			//		if(test_axis > projected_radii)
			//		{
			//			_outResult = GCollisionCheck::NO_COLLISION;
			//			return GReturn::SUCCESS;
			//		}
			//		else
			//		{
			//			GetInfo(
			//				test_axis,
			//				projected_radii_1,
			//				projected_radii_2,
			//				obb2_rotation[i],
			//				nullptr,
			//				_outDirection,
			//				_outDistance);
			//		}
			//	}

			//	// Test OBB1 x & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][0] +
			//		_obb1.extent.data[2] * abs_rotation[1][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[0][2] +
			//		_obb2.extent.data[2] * abs_rotation[0][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][0] -
			//		translation_vec.data[1] * rotation[2][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 x & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][1] +
			//		_obb1.extent.data[2] * abs_rotation[1][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[0][2] +
			//		_obb2.extent.data[2] * abs_rotation[0][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][1] -
			//		translation_vec.data[1] * rotation[2][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 x & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][2] +
			//		_obb1.extent.data[2] * abs_rotation[1][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[0][1] +
			//		_obb2.extent.data[1] * abs_rotation[0][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][2] -
			//		translation_vec.data[1] * rotation[2][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][0] +
			//		_obb1.extent.data[2] * abs_rotation[0][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[1][2] +
			//		_obb2.extent.data[2] * abs_rotation[1][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][0] -
			//		translation_vec.data[2] * rotation[0][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][1] +
			//		_obb1.extent.data[2] * abs_rotation[0][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[1][2] +
			//		_obb2.extent.data[2] * abs_rotation[1][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][1] -
			//		translation_vec.data[2] * rotation[0][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][2] +
			//		_obb1.extent.data[2] * abs_rotation[0][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[1][1] +
			//		_obb2.extent.data[1] * abs_rotation[1][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][2] -
			//		translation_vec.data[2] * rotation[0][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][0] +
			//		_obb1.extent.data[1] * abs_rotation[0][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[2][2] +
			//		_obb2.extent.data[2] * abs_rotation[2][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][0] -
			//		translation_vec.data[0] * rotation[1][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][1] +
			//		_obb1.extent.data[1] * abs_rotation[0][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[2][2] +
			//		_obb2.extent.data[2] * abs_rotation[2][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][1] -
			//		translation_vec.data[0] * rotation[1][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][2] +
			//		_obb1.extent.data[1] * abs_rotation[0][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[2][1] +
			//		_obb2.extent.data[1] * abs_rotation[2][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][2] -
			//		translation_vec.data[0] * rotation[1][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}
			//	_outDistance += 0.000001f;

			//	GW::MATH::GVector::ScaleF(
			//		_outDirection,
			//		_outDistance,
			//		_outContactClosest1);

			//	GW::MATH::GVector::AddVectorF(
			//		_outContactClosest1,
			//		_obb2.center,
			//		_outContactClosest1);

			//	GW::MATH::GVector::ScaleF(
			//		_outDirection,
			//		-(_outDistance),
			//		_outContactClosest2);

			//	GW::MATH::GVector::AddVectorF(
			//		_outContactClosest2,
			//		_obb2.center,
			//		_outContactClosest2);

			//	_outResult = GCollisionCheck::COLLISION;
			//	return GReturn::SUCCESS;
			//}

			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance)
			{
				GW::MATH::GVECTORF p = _point.xyz();

				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					difference_ba);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					line.start,
					difference_pa);

				MATH::GVECTORF difference_pb = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					line.end,
					difference_pb);

				float interval1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_ba,
					interval1);

				if(interval1 <= 0.0f)
				{
					GW::MATH::GVector::DotF(
						difference_pa,
						difference_pa,
						_outDistance);

					return GReturn::SUCCESS;
				}

				float interval2 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					interval2);

				if(interval1 >= interval2)
				{
					GW::MATH::GVector::DotF(
						difference_pb,
						difference_pb,
						_outDistance);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_pa,
					difference_pa,
					_outDistance);

				if(G_ABS(interval2) >= 0.000001f)
				{
					_outDistance -= interval1 * interval1 / interval2;
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};

				ClosestPointToRayF(
					_ray,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle,
													  float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToTriangleF(
					_triangle,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane,
												   float& _outDistance)
			{
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_point.xyz(),
					_outDistance);
				_outDistance -= _plane.distance;
				_outDistance *= _outDistance;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere,
													float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToSphereF(
					_sphere,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule,
													 float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToCapsuleF(
					_capsule,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb,
												  float& _outDistance)
			{

				_outDistance = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					float v = _point.data[i];

					if(v < _aabb.min.data[i])
					{
						_outDistance += (_aabb.min.data[i] - v) * (_aabb.min.data[i] - v);
					}

					if(v > _aabb.max.data[i])
					{
						_outDistance += (v - _aabb.max.data[i]) * (v - _aabb.max.data[i]);
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance)
			{
				MATH::GVECTORF p = {};
				ClosestPointToOBBF(
					_obb,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point,
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c,
										const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_b,
					_a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_c,
					_a,
					difference_ca);

				MATH::GVECTORF triangle_n = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ba,
					difference_ca,
					triangle_n);

				float x = G_ABS(triangle_n.x);
				float y = G_ABS(triangle_n.y);
				float z = G_ABS(triangle_n.z);

				// Degenerate triangle
				if(x + y + z < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				float nominator_u = 0.0f;
				float nominator_v = 0.0f;
				float w = 0.0f;

				// Project to yz plane
				if(x >= y && x >= z)
				{
					// Area of pbc in yz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.y - _b.y,_b.y - _c.y}}},
						GW::MATH::GVECTORF{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in yz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.y - _c.y,_c.y - _a.y}}},
						GW::MATH::GVECTORF{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0f / triangle_n.x;
				}
				// Project to the xz plane
				else if(y >= x && y >= z)
				{
					// Area of pbc in xz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORF{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in xz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORF{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0f / (-triangle_n.y);
				}
				// Project to the xy plane
				else
				{
					// Area of pbc in xy plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORF{{{_p.y - _b.y,_b.y - _c.y}}},
						nominator_u);

					// Area of pca in xy plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORF{{{_p.y - _c.y,_c.y - _a.y}}},
						nominator_v);

					w = 1.0f / triangle_n.z;
				}

				float u = nominator_u * w;
				float v = nominator_v * w;

				_outBarycentric =
				{
					{
						{
							u,
							v,
							1.0f - u - v
						}
					}
				};

				return GReturn::SUCCESS;
			}

			// DOUBLE

			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM)
			{
				_outAABBMM.min =
				{
					{
						{
							_aabbCE.center.x - _aabbCE.extent.x,
							_aabbCE.center.y - _aabbCE.extent.y,
							_aabbCE.center.z - _aabbCE.extent.z
						}
					}
				};

				_outAABBMM.max =
				{
					{
						{
							_aabbCE.center.x + _aabbCE.extent.x,
							_aabbCE.center.y + _aabbCE.extent.y,
							_aabbCE.center.z + _aabbCE.extent.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE)
			{
				_outAABCE.center =
				{
					{
						{
							(_aabbMM.min.x + _aabbMM.max.x) * 0.5,
							(_aabbMM.min.y + _aabbMM.max.y) * 0.5,
							(_aabbMM.min.z + _aabbMM.max.z) * 0.5
						}
					}
				};

				_outAABCE.extent =
				{
					{
						{
							_aabbMM.max.x - _outAABCE.center.x,
							_aabbMM.max.y - _outAABCE.center.y,
							_aabbMM.max.z - _outAABCE.center.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB,
										 const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_planePositionB,
					_planePositionA,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_planePositionC,
					_planePositionA,
					difference_ca);

				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					_outPlane.data);

				if(GW::MATH::GVector::NormalizeD(_outPlane.data, _outPlane.data) == GReturn::FAILURE)
				{
					 // ba and ca are parallel which degenerates to a line.
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::DotD(
					_outPlane.data,
					_planePositionA.xyz(),
					_outPlane.distance);

				return GReturn::SUCCESS;
			}

			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.b,
					_triangle.a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.c,
					_triangle.a,
					difference_ca);

				MATH::GVECTORD triangle_normal = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ba,
					difference_ca,
					triangle_normal);

				double triangle_area = 0;
				GW::MATH::GVector::DotD(
					triangle_normal,
					triangle_normal,
					triangle_area);

				_outResult = (G_ABS(triangle_area) < 1.192092896e-07) ? GCollisionCheck::NO_COLLISION : GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints,
													 const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				if(!_polygonPoints || _pointsCount < 3)
				{
					return GReturn::FAILURE;
				}

				auto Collinear = [&](const GW::MATH::GVECTORD p, const GW::MATH::GLINED l)
				{
					if(p.x <= G_LARGER(l.start.x, l.end.x) && p.x <= G_SMALLER(l.start.x, l.end.x) &&
					   p.y <= G_LARGER(l.start.y, l.end.y) && p.y <= G_SMALLER(l.start.y, l.end.y))
					{
						return true;
					}

					return false;
				};

				auto Area2D = [&](const MATH::GVECTORD a, const MATH::GVECTORD b, const MATH::GVECTORD p)
				{
					double winding = 0;

					GW::MATH::GVECTORD difference_pa = {};
					GW::MATH::GVector::SubtractVectorD(
						p,
						a,
						difference_pa);

					GW::MATH::GVECTORD difference_ba = {};
					GW::MATH::GVector::SubtractVectorD(
						b,
						a,
						difference_ba);

					GW::MATH::GVector::CrossVector2D(
						difference_pa,
						difference_ba,
						winding);

					if(G_ABS(winding) < 0.000001f)
					{
						return 0;
					}
					else if(winding > 0.0f)
					{
						return 1;
					}
					else
					{
						return -1;
					}
				};

				auto IsCrossing = [&](const GW::MATH::GLINED l1, const GW::MATH::GLINED l2)
				{
					int winding1 = Area2D(l1.start, l1.end, l2.start);
					int winding2 = Area2D(l1.start, l1.end, l2.end);
					int winding3 = Area2D(l2.start, l2.end, l1.start);
					int winding4 = Area2D(l2.start, l2.end, l1.end);

					if(winding1 != winding2 && winding3 != winding4)
					{
						return true;
					}
					if(winding1 == 0 && Collinear(l2.start, l1))
					{
						return true;
					}
					if(winding2 == 0 && Collinear(l2.end, l1))
					{
						return true;
					}
					if(winding3 == 0 && Collinear(l1.start, l2))
					{
						return true;
					}
					if(winding4 == 0 && Collinear(l1.end, l2))
					{
						return true;
					}

					return false;
				};

				GW::MATH::GLINED inf_line =
				{
					{
						{
							{{{_queryPoint.x, _queryPoint.y, 0.0f, 0.0f}}},
							{{{static_cast<double>(0xffffffff), _queryPoint.y}}}
						}
					}
				};

				int count = 0;
				int i = 0;

				do
				{
					GW::MATH::GLINED side = {};
					side.start = _polygonPoints[i];
					side.end = _polygonPoints[(i + 1) % _pointsCount];

					if(IsCrossing(side, inf_line))
					{
						if(Area2D(side.start, _queryPoint, side.end) == 0)
						{
							_outResult = static_cast<GCollisionCheck>(Collinear(_queryPoint, side));
							return GReturn::SUCCESS;
						}
						count++;
					}

					i = (i + 1) % _pointsCount;
				}
				while(i != 0);

				_outResult = static_cast<GCollisionCheck>(count & 1);
				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD line_a = _line.start.xyz();

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					line_a,
					difference_ba);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_ba,
					interval);

				double sq_length = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 1.192092896e-07)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = G_CLAMP(
					interval,
					0.0,
					1.0f);

				GW::MATH::GVector::ScaleD(
					difference_ba,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2)
			{
				MATH::GLINED line1 =
				{
					{
						{
							_line1.start.xyz(),
							_line1.end.xyz()
						}
					}
				};

				MATH::GLINED line2 =
				{
					{
						{
							_line2.start.xyz(),
							_line2.end.xyz()
						}
					}
				};

				MATH::GVECTORD direction1 = {};
				GW::MATH::GVector::SubtractVectorD(
					line1.end,
					line1.start,
					direction1);

				MATH::GVECTORD direction2 = {};
				GW::MATH::GVector::SubtractVectorD(
					line2.end,
					line2.start,
					direction2);

				MATH::GVECTORD distance = {};
				GW::MATH::GVector::SubtractVectorD(
					line1.start,
					line2.start,
					distance);

				double sq_length1 = 0.0;
				GW::MATH::GVector::DotD(
					direction1,
					direction1,
					sq_length1);

				double sq_length2 = 0.0;
				GW::MATH::GVector::DotD(
					direction2,
					direction2,
					sq_length2);

				double f = 0.0;
				GW::MATH::GVector::DotD(
					direction2,
					distance,
					f);

				double interval1 = 0.0;
				double interval2 = 0.0;

				int use_cases = 0x00;

				// First line degenerates to a point.
				if(sq_length1 <= 1.192092896e-07)
				{
					use_cases |= 0x01;
				}

				// Second line degenerates to a point.
				if(sq_length2 <= 1.192092896e-07)
				{
					use_cases |= 0x02;
				}

				switch(use_cases)
				{
					// First line degenerates to a point.
					case 0x01:
					{
						interval2 = f / sq_length2;
						interval2 = G_CLAMP(
							interval2,
							0.0,
							1.0f);
					}
					break;
					// Second line degenerates to a point.
					case 0x02:
					{
						double c = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							distance,
							c);

						interval1 = G_CLAMP(
							-c / sq_length1,
							0.0,
							1.0f);
					}
					break;
					// Both lines degenerate to a point.
					case 0x03:
					{
						_outPoint1 = line1.start.xyz();
						_outPoint2 = line2.start.xyz();
						return GReturn::SUCCESS;
					}
					break;
					default:
					{
						double c = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							distance,
							c);

						double b = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							direction2,
							b);

						double denom = sq_length1 * sq_length2 - b * b;

						// Get interval for the first line from the second line unless lines are parallel.
						if(denom != 0.0)
						{
							interval1 = G_CLAMP(
								(b * f - c * sq_length2) / denom,
								0.0,
								1.0f);
						}
						else
						{
							interval1 = 0.0;
						}

						// Get interval for the second line.
						interval2 = (b * interval1 + f) / sq_length2;

						if(interval2 < 0.0)
						{
							interval2 = 0.0;

							interval1 = G_CLAMP(
								-c / sq_length1,
								0.0,
								1.0f);
						}
						else if(interval2 > 1.0f)
						{
							interval2 = 1.0f;

							interval1 = G_CLAMP(
								(b - c) / sq_length1,
								0.0,
								1.0f);
						}
					}
					break;
				}

				GW::MATH::GVector::ScaleD(
					direction1,
					interval1,
					direction1);

				GW::MATH::GVector::AddVectorD(
					line1.start,
					direction1,
					_outPoint1);

				GW::MATH::GVector::ScaleD(
					direction2,
					interval2,
					direction2);

				GW::MATH::GVector::AddVectorD(
					line2.start,
					direction2,
					_outPoint2);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD line_a = _ray.position.xyz();
				MATH::GVECTORD line_direction = _ray.direction.xyz();

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					line_direction,
					interval);

				double sq_length = 0.0;
				GW::MATH::GVector::DotD(
					line_direction,
					line_direction,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 1.192092896e-07)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = interval < 0.0 ? 0.0 : interval;

				GW::MATH::GVector::ScaleD(
					line_direction,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				GW::MATH::GVECTORD a = _triangle.a.xyz();
				GW::MATH::GVECTORD b = _triangle.b.xyz();
				GW::MATH::GVECTORD c = _triangle.c.xyz();
				GW::MATH::GVECTORD p = _queryPoint.xyz();

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					b,
					a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					c,
					a,
					difference_ca);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					a,
					difference_pa);

				double dot1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pa,
					dot1);

				double dot2 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pa,
					dot2);

				// p is closest to vertex a
				if(dot1 <= 1.192092896e-07 && dot2 <= 1.192092896e-07)
				{
					_outPoint = a;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pb = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					b,
					difference_pb);

				double dot3 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pb,
					dot3);

				double dot4 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pb,
					dot4);

				// p is closest to vertex b
				if(dot3 >= 1.192092896e-07 && dot4 <= dot3)
				{
					_outPoint = b;
					return GReturn::SUCCESS;
				}

				double vc = dot1 * dot4 - dot3 * dot2;

				// p is closest to edge ab
				if(vc <= 1.192092896e-07 && dot1 >= 1.192092896e-07 && dot3 <= 1.192092896e-07)
				{
					double interval = dot1 / (dot1 - dot3);

					GW::MATH::GVector::ScaleD(
						difference_ba,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pc = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					c,
					difference_pc);

				double dot5 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pc,
					dot5);

				double dot6 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pc,
					dot6);

				// p is closest to vertex c
				if(dot5 >= 1.192092896e-07 && dot6 <= dot5)
				{
					_outPoint = c;
					return GReturn::SUCCESS;
				}

				double vb = dot6 * dot2 - dot1 * dot5;
				// p is closest to edge ac
				if(vb <= 1.192092896e-07 && dot2 >= 1.192092896e-07 && dot5 <= 1.192092896e-07)
				{
					double interval = dot2 / (dot2 - dot5);

					GW::MATH::GVector::ScaleD(
						difference_ca,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				double va = dot3 * dot5 - dot6 * dot4;
				// p is closest to edge bc
				if(va <= 1.192092896e-07 && (dot4 - dot3) >= 1.192092896e-07 && (dot6 - dot5) >= 1.192092896e-07)
				{
					double h = dot4 - dot3;
					double interval = h / (h + dot6 - dot5);

					GW::MATH::GVector::SubtractVectorD(
						c,
						b,
						_outPoint);

					GW::MATH::GVector::ScaleD(
						_outPoint,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						b,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				// p is closest to some point on the face
				double denom = 1.0 / (va + vb + vc);
				double v = vb * denom;
				double w = vc * denom;

				GW::MATH::GVector::ScaleD(
					difference_ba,
					v,
					_outPoint);

				GW::MATH::GVECTORD acw = {};
				GW::MATH::GVector::ScaleD(
					difference_ca,
					w,
					acw);

				GW::MATH::GVector::AddVectorD(
					acw,
					_outPoint,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD plane_normal = _plane.data.xyz();
				MATH::GVECTORD query_point = _queryPoint.xyz();

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					plane_normal,
					query_point,
					interval);

				interval -= _plane.distance;

				GW::MATH::GVector::ScaleD(
					plane_normal,
					interval,
					_outPoint);

				GW::MATH::GVector::SubtractVectorD(
					query_point,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				GW::MATH::GVECTORD direction = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint,
					_sphere.data,
					direction);

				if(GW::MATH::GVector::NormalizeD(direction.xyz(), direction) == GReturn::FAILURE)
				{
					_outPoint = _queryPoint;
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::ScaleD(
					direction,
					_sphere.radius,
					direction);

				GW::MATH::GVector::AddVectorD(
					_sphere.data.xyz(),
					direction,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				ClosestPointToLineD(
					{{{_capsule.data[0].xyz(),_capsule.data[1].xyz()}}},
					_queryPoint,
					_outPoint);

				return ClosestPointToSphereD(
					{{{_outPoint.x, _outPoint.y, _outPoint.z, _capsule.radius}}},
					_queryPoint,
					_outPoint);
			}

			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				for(int i = 0; i < 3; i++)
				{
					_outPoint.data[i] = _queryPoint.data[i];

					_outPoint.data[i] = G_LARGER(
						_outPoint.data[i],
						_aabb.min.data[i]);

					_outPoint.data[i] = G_SMALLER(
						_outPoint.data[i],
						_aabb.max.data[i]);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				double xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				double yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				double zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;
				double xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				double xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				double yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;
				double wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				double wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				double wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORD obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					_obb.data->xyz(),
					difference);

				_outPoint = _obb.center.xyz();

				MATH::GVECTORD world_coord = {};

				double distance = 0.0;

				for(int i = 0; i < 3; i++)
				{
					// Project the difference to this axis
					GW::MATH::GVector::DotD(
						difference,
						obb_rotation[i],
						distance);

					// Clamp to boundary
					distance = G_SMALLER(
						distance,
						_obb.extent.data[i]);

					distance = G_LARGER(
						distance,
						-_obb.extent.data[i]);

					GW::MATH::GVector::ScaleD(
						obb_rotation[i],
						distance,
						world_coord);

					GW::MATH::GVector::AddVectorD(
						_outPoint,
						world_coord,
						_outPoint);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere)
			{
				if(!_pointCloud || _pointsCount < 2)
				{
					return GReturn::FAILURE;
				}

				// Find a good almost bounding sphere
				unsigned int min_x = 0;
				unsigned int max_x = 0;
				unsigned int min_y = 0;
				unsigned int max_y = 0;
				unsigned int min_z = 0;
				unsigned int max_z = 0;

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_pointCloud[i].x < _pointCloud[min_x].x)
					{
						min_x = i;
					}
					if(_pointCloud[i].x > _pointCloud[max_x].x)
					{
						max_x = i;
					}

					if(_pointCloud[i].y < _pointCloud[min_y].y)
					{
						min_y = i;
					}
					if(_pointCloud[i].y > _pointCloud[max_y].y)
					{
						max_y = i;
					}

					if(_pointCloud[i].z < _pointCloud[min_z].z)
					{
						min_z = i;
					}
					if(_pointCloud[i].z > _pointCloud[max_z].z)
					{
						max_z = i;
					}
				}

				GW::MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_x],
					_pointCloud[min_x],
					difference);

				double sq_distance_x = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_x);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_y],
					_pointCloud[min_y],
					difference);

				double sq_distance_y = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_y);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_z],
					_pointCloud[min_z],
					difference);

				double sq_distance_z = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_z);

				int min = min_x;
				int max = max_x;

				if((sq_distance_y > sq_distance_x) && (sq_distance_y > sq_distance_z))
				{
					min = min_y;
					max = max_y;
				}

				if((sq_distance_z > sq_distance_x) && (sq_distance_z > sq_distance_y))
				{
					min = min_z;
					max = max_z;
				}

				GW::MATH::GVector::AddVectorD(
					_pointCloud[min].xyz(),
					_pointCloud[max].xyz(),
					_outSphere.data);

				GW::MATH::GVector::ScaleD(
					_outSphere.data,
					0.5f,
					_outSphere.data);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max].xyz(),
					_outSphere.data,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outSphere.radius);

				_outSphere.radius = sqrt(_outSphere.radius);

				// Improve the bound and include all points
				auto UpdateSphereBounds = [&](const MATH::GVECTORD p, MATH::GSPHERED& outSphere)
				{
					GW::MATH::GVECTORD difference = {};
					GW::MATH::GVector::SubtractVectorD(
						p.xyz(),
						outSphere.data.xyz(),
						difference);

					double sq_distance = 0.0;
					GW::MATH::GVector::DotD(
						difference,
						difference,
						sq_distance);

					if(sq_distance > outSphere.radius* outSphere.radius)
					{
						double distance = sqrt(sq_distance);
						double radius = (outSphere.radius + distance) * 0.5f;
						double increase = (radius - outSphere.radius) / distance;

						GW::MATH::GVector::ScaleD(
							difference,
							increase,
							difference);

						GW::MATH::GVector::AddVectorD(
							outSphere.data,
							difference,
							outSphere.data);

						outSphere.radius = radius;
					}
				};

				for(unsigned int i = 0; i < _pointsCount; i++)
				{
					UpdateSphereBounds(
						_pointCloud[i],
						_outSphere);
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB)
			{
				if(!_pointCloud || _pointsCount == 0)
				{
					return GReturn::FAILURE;
				}

				_outAABB.min = _pointCloud[0];
				_outAABB.max = _pointCloud[0];

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_outAABB.min.x > _pointCloud[i].x)
					{
						_outAABB.min.x = _pointCloud[i].x;
					}
					if(_outAABB.max.x < _pointCloud[i].x)
					{
						_outAABB.max.x = _pointCloud[i].x;
					}

					if(_outAABB.min.y > _pointCloud[i].y)
					{
						_outAABB.min.y = _pointCloud[i].y;
					}
					if(_outAABB.max.y < _pointCloud[i].y)
					{
						_outAABB.max.y = _pointCloud[i].y;
					}

					if(_outAABB.min.z > _pointCloud[i].z)
					{
						_outAABB.min.z = _pointCloud[i].z;
					}
					if(_outAABB.max.z < _pointCloud[i].z)
					{
						_outAABB.max.z = _pointCloud[i].z;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD point = _point.xyz();

				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					difference_ba);

				double distance_ba = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					distance_ba);
				distance_ba = sqrt(distance_ba);

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					point,
					line.start,
					difference_pa);

				double distance_pa = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_pa,
					distance_pa);
				distance_pa = sqrt(distance_pa);

				GW::MATH::GVECTORD difference_bp = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					point,
					difference_bp);

				double distance_bp = 0.0;
				GW::MATH::GVector::DotD(
					difference_bp,
					difference_bp,
					distance_bp);
				distance_bp = sqrt(distance_bp);

				_outResult = (G_COMPARISON_STANDARD_D(distance_ba, distance_pa + distance_bp)) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_point.xyz(),
					_ray.position.xyz(),
					difference_pa);

				// Point is ray position
				if(GW::MATH::GVector::NormalizeD(difference_pa, difference_pa) == GReturn::FAILURE)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(difference_pa.x - _ray.direction.x) < 1.192092896e-07 &&
				   G_ABS(difference_pa.y - _ray.direction.y) < 1.192092896e-07 &&
				   G_ABS(difference_pa.z - _ray.direction.z) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GPLANED plane = {};
				if(ComputePlaneD(_triangle.a, _triangle.b, _triangle.c, plane) == GReturn::FAILURE)
				{
					// Degenerate triangle.
					return GReturn::FAILURE;
				}

				TestPointToPlaneD(
					_point,
					plane,
					_outResult);

				if(static_cast<int>(_outResult) > 0)
				{
					MATH::GVECTORD barycentric = {};
					// Compute plane already handles fail case of degenerate triangle.
					BarycentricD(_triangle.a, _triangle.b, _triangle.c, _point, barycentric);

					_outResult = (barycentric.y >= 0.0 && barycentric.z >= 0.0 && (barycentric.y + barycentric.z) <= 1.0) ?
						GCollisionCheck::COLLISION :
						GCollisionCheck::NO_COLLISION;

					if(_outBarycentric)
					{
						*_outBarycentric = barycentric;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				double distance = 0.0;
				GW::MATH::GVector::DotD(
					_point.xyz(),
					_plane.data.xyz(),
					distance);
				distance = distance - _plane.distance;

				if(distance < -1.192092896e-07)
				{
					_outResult = GCollisionCheck::BELOW;
				}
				else if(G_ABS(distance) <= 1.192092896e-07)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_point,
					_sphere.data.xyz(),
					difference_ba);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = sq_distance <= sq_radius ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GSPHERED sphere = {};

				if(ClosestPointToCapsuleD(_capsule, _point, sphere.data) == GReturn::FAILURE)
				{
					// Point is center of capsule
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				sphere.radius = _capsule.radius;
				return TestPointToSphereD(
					_point,
					sphere,
					_outResult);
			}

			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb.center.x - _point.x) - _aabb.extent.x > 1.192092896e-07 ||
				   G_ABS(_aabb.center.y - _point.y) - _aabb.extent.y > 1.192092896e-07 ||
				   G_ABS(_aabb.center.z - _point.z) - _aabb.extent.z > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};

				ClosestPointToOBBD(
					_obb,
					_point,
					closest_point);

				if(G_ABS(closest_point.x - _point.x) > 1.192092896e-07 ||
				   G_ABS(closest_point.y - _point.y) > 1.192092896e-07 ||
				   G_ABS(closest_point.z - _point.z) > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};

				ClosestPointsToLineFromLineD(
					_line1,
					_line2,
					closest_point1,
					closest_point2);

				if(G_ABS(closest_point1.x - closest_point2.x) > 1.192092896e-07 ||
				   G_ABS(closest_point1.y - closest_point2.y) > 1.192092896e-07 ||
				   G_ABS(closest_point1.z - closest_point2.z) > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_line.start,
					closest_point1);

				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointToRayD(
					_ray,
					_line.end,
					closest_point2);

				return TestLineToLineD(
					_line,
					{{{closest_point1, closest_point2}}},
					_outResult);
			}

			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD norm = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORD difference_line = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					line.end,
					difference_line);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					triangle.a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0 || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0 || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					double over_denom = 1.0 / dot;

					barycentric.y *= over_denom;
					barycentric.z *= over_denom;

					*_outBarycentric =
					{
						{
							{
								1.0 - barycentric.y - barycentric.z,
						barycentric.y,
						barycentric.z
							}
						}
					};
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					difference_ba,
					denom);

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0 && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToLineD(
					_line,
					_sphere.data,
					closest_point);

				return TestPointToSphereD(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointsToLineFromLineD(
					_line,
					{{{_capsule.data[0],_capsule.data[1]}}},
					closest_point1,
					closest_point2);

				return TestPointToSphereD(
					closest_point1,
					{{{closest_point2.x,closest_point2.y,closest_point2.z,_capsule.radius}}},
					_outResult);
			}

			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD extent = _aabb.extent.xyz();

				GW::MATH::GVECTORD line_midpoint = {};
				GW::MATH::GVector::AddVectorD(
					line.start,
					line.end,
					line_midpoint);

				GW::MATH::GVector::ScaleD(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORD line_mid_length = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORD origin = {};
				GW::MATH::GVector::SubtractVectorD(
					line_midpoint,
					_aabb.center.xyz(),
					origin);

				GW::MATH::GVECTORD axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(origin.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 1.192092896e-07;
				axis.y += 1.192092896e-07;
				axis.z += 1.192092896e-07;

				if(G_ABS(origin.y * line_mid_length.z - origin.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.z * line_mid_length.x - origin.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.x * line_mid_length.z - origin.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start,
							_line.end
						}
					}
				};
				line.start.w = 1.0f;
				line.end.w = 1.0f;

				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorD(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorD(
					line.end,
					_obb.center,
					line.end);

				return TestLineToAABBD(
					line,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GRAYD ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD q = {};
				GW::MATH::GVector::CrossVector3D(
					ray.direction,
					difference_ca,
					q);

				double det = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double denom = 1.0f / det;

				GW::MATH::GVECTORD s = {};
				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD r = {};
				GW::MATH::GVector::CrossVector3D(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotD(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
					_outBarycentric->x = 1.0f - barycentric.y - barycentric.z;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Ray is parallel
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;
				if(interval >= 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				double c = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				// At least one real root.
				if(c <= 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				double b = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					_ray.direction.xyz(),
					b);

				// Ray is outside sphere and pointing away from it.
				if(b > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// The discriminant determines if there were solutions or not.
				double discriminant = b * b - c;
				_outResult = (discriminant < 0.0) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHERED sphere = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineD(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return TestPointToSphereD(
					closest_point1,
					sphere,
					_outResult);
			}

			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult)
			{
				double interval1 = 0.0;
				double interval2 = 0.0;
				double interval3 = 0.0;
				double interval4 = 0.0;
				double interval5 = 0.0;
				double interval6 = 0.0;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYD ray =
				{
					{
						{
							_ray.position,
							_ray.direction.xyz()
						}
					}
				};
				ray.position.w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorD(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				return TestRayToAABBD(
					ray,
					mm,
					_outResult);
			}

			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult)
			{
				// Half plane test if triangle1 lies completely on one side to triangle2 plane
				GW::MATH::GVECTORD difference_b2a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.b.xyz(),
					_triangle2.a.xyz(),
					difference_b2a2);

				GW::MATH::GVECTORD difference_c2a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.c.xyz(),
					_triangle2.a.xyz(),
					difference_c2a2);

				GW::MATH::GVECTORD plane2 = {};
				GW::MATH::GVector::CrossVector3D(
					difference_c2a2,
					difference_b2a2,
					plane2);

				GW::MATH::GVECTORD difference_a1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.a.xyz(),
					_triangle2.a.xyz(),
					difference_a1a2);

				GW::MATH::GVECTORD det1 = {};
				GW::MATH::GVector::DotD(
					difference_a1a2,
					plane2,
					det1.x);

				GW::MATH::GVECTORD difference_b1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.b.xyz(),
					_triangle2.a.xyz(),
					difference_b1a2);

				GW::MATH::GVector::DotD(
					difference_b1a2,
					plane2,
					det1.y);

				GW::MATH::GVECTORD difference_c1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.c.xyz(),
					_triangle2.a.xyz(),
					difference_c1a2);

				GW::MATH::GVector::DotD(
					difference_c1a2,
					plane2,
					det1.z);

				if(((det1.x * det1.y) > 0.0) && ((det1.x * det1.z) > 0.0))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Half plane test if triangle2 lies completely on one side to triangle1 plane
				GW::MATH::GVECTORD difference_b1a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.b.xyz(),
					_triangle1.a.xyz(),
					difference_b1a1);

				GW::MATH::GVECTORD difference_c1a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.c.xyz(),
					_triangle1.a.xyz(),
					difference_c1a1);

				GW::MATH::GVECTORD plane1 = {};
				GW::MATH::GVector::CrossVector3D(
					difference_c1a1,
					difference_b1a1,
					plane1);

				GW::MATH::GVECTORD difference_a2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.a.xyz(),
					_triangle1.a.xyz(),
					difference_a2a1);

				GW::MATH::GVECTORD det2 = {};
				GW::MATH::GVector::DotD(
					difference_a2a1,
					plane1,
					det2.x);

				GW::MATH::GVECTORD difference_b2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.b.xyz(),
					_triangle1.a.xyz(),
					difference_b2a1);

				GW::MATH::GVector::DotD(
					difference_b2a1,
					plane1,
					det2.y);

				GW::MATH::GVECTORD difference_c2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.c.xyz(),
					_triangle1.a.xyz(),
					difference_c2a1);

				GW::MATH::GVector::DotD(
					difference_c2a1,
					plane1,
					det2.z);

				if(((det2.x * det2.y) > 0.0) && ((det2.x * det2.z) > 0.0))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Bring both triangles into canonical form
				MATH::GTRIANGLED triangle1 = {};
				MATH::GTRIANGLED triangle2 = {};

				if(det1.x > 0.0)
				{
					if(det1.y > 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else if(det1.z > 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
				}
				else if(det1.x < 0.0)
				{
					if(det1.y < 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else if(det1.z < 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
				}
				else
				{
					if(det1.y < 0.0)
					{
						if(det1.z >= 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else if(det1.y > 0.0)
					{
						if(det1.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else
					{
						if(det1.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
						else if(det1.z < 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const double* a, const double* b, const double* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(c2, b2, b1) <= 0.0)
									{
										if(Orient2D(a1, a2, b1) > 0.0)
										{
											return (Orient2D(a1, b2, b1) <= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0)
											{
												return (Orient2D(b1, c1, a2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0)
										{
											if(Orient2D(c2, b2, c1) <= 0.0)
											{
												return (Orient2D(b1, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(b1, c1, c2) >= 0.0)
										{
											return (Orient2D(a1, a2, c1) >= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0)
											{
												return (Orient2D(c2, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(a1, a2, b1) >= 0.0)
									{
										return (Orient2D(a1, b1, c2) >= 0.0) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0)
										{
											return (Orient2D(c1, a1, a2) >= 0.0) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(a1, a2, c1) >= 0.0)
										{
											if(Orient2D(a1, c1, c2) >= 0.0) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0)
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORD normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLED tri2_1 = {};
							GW::MATH::GTRIANGLED tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				if(det2.x > 0.0)
				{
					if(det2.y > 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z > 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else if(det2.x < 0.0)
				{
					if(det2.y < 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z < 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else
				{
					if(det2.y < 0.0)
					{
						if(det2.z >= 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
					}
					else if(det2.y > 0.0)
					{
						if(det2.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
					}
					else
					{
						if(det2.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else if(det2.z < 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c

									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const double* a, const double* b, const double* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(c2, b2, b1) <= 0.0)
									{
										if(Orient2D(a1, a2, b1) > 0.0)
										{
											return (Orient2D(a1, b2, b1) <= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0)
											{
												return (Orient2D(b1, c1, a2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0)
										{
											if(Orient2D(c2, b2, c1) <= 0.0)
											{
												return (Orient2D(b1, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(b1, c1, c2) >= 0.0)
										{
											return (Orient2D(a1, a2, c1) >= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0)
											{
												return (Orient2D(c2, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(a1, a2, b1) >= 0.0)
									{
										return (Orient2D(a1, b1, c2) >= 0.0) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0)
										{
											return (Orient2D(c1, a1, a2) >= 0.0) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(a1, a2, c1) >= 0.0)
										{
											if(Orient2D(a1, c1, c2) >= 0.0) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0)
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORD normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLED tri2_1 = {};
							GW::MATH::GTRIANGLED tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				// Edges confirmed to form a line where the triangle planes meet. Check if triangles are within an interval.
				GW::MATH::GVECTORD difference_a2b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle2.a,
					triangle1.b,
					difference_a2b1);

				GW::MATH::GVECTORD difference_a1b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle1.a,
					triangle1.b,
					difference_a1b1);

				GW::MATH::GVector::CrossVector3D(
					difference_a1b1,
					difference_a2b1,
					plane1);

				GW::MATH::GVECTORD difference_b2b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle2.b,
					triangle1.b,
					difference_b2b1);

				double dot1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_b2b1,
					plane1,
					dot1);

				if(dot1 > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					triangle2.a,
					triangle1.a,
					difference_a2a1);

				GW::MATH::GVector::SubtractVectorD(
					triangle1.c,
					triangle1.a,
					difference_c1a1);

				GW::MATH::GVector::CrossVector3D(
					difference_c1a1,
					difference_a2a1,
					plane1);

				GW::MATH::GVector::SubtractVectorD(
					triangle2.c,
					triangle1.a,
					difference_c2a1);

				GW::MATH::GVector::DotD(
					difference_c2a1,
					plane1,
					dot1);

				if(dot1 > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				GCollisionCheck plane_test;

				TestPointToPlaneD(
					_triangle.a,
					_plane,
					plane_test);
				_outResult = plane_test;

				if (static_cast<int>(_outResult) > 0)
				{
					return GReturn::SUCCESS;
				}

				TestPointToPlaneD(
					_triangle.b,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPlaneD(
					_triangle.c,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToTriangleD(
					_triangle,
					_sphere.data,
					closest_point);

				return TestPointToSphereD(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToTriangleD(
					_triangle,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointToTriangleD(
					_triangle,
					_capsule.data[1],
					closest_point2);

				return TestLineToCapsuleD(
					{{{closest_point1, closest_point2}}},
					_capsule,
					_outResult);
			}

			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD right = {{{1,0,0,0}}};
				GW::MATH::GVECTORD up = {{{0,1,0,0}}};
				GW::MATH::GVECTORD forward = {{{0,0,1,0}}};

				GW::MATH::GVECTORD v0 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.a.xyz(),
					_aabb.center.xyz(),
					v0);

				GW::MATH::GVECTORD v1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.b.xyz(),
					_aabb.center.xyz(),
					v1);

				GW::MATH::GVECTORD v2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.c.xyz(),
					_aabb.center.xyz(),
					v2);

				GW::MATH::GVECTORD f0 = {};
				GW::MATH::GVector::SubtractVectorD(
					v1,
					v0,
					f0);

				GW::MATH::GVECTORD f1 = {};
				GW::MATH::GVector::SubtractVectorD(
					v2,
					v1,
					f1);

				GW::MATH::GVECTORD f2 = {};
				GW::MATH::GVector::SubtractVectorD(
					v0,
					v2,
					f2);

				GW::MATH::GVECTORD axis[9] = {};

				GW::MATH::GVector::CrossVector3D(
					right,
					f0,
					axis[0]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f0,
					axis[1]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f0,
					axis[2]);

				GW::MATH::GVector::CrossVector3D(
					right,
					f1,
					axis[3]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f1,
					axis[4]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f1,
					axis[5]);

				GW::MATH::GVector::CrossVector3D(
					right,
					f2,
					axis[6]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f2,
					axis[7]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f2,
					axis[8]);

				double p0 = 0.0;
				double p1 = 0.0;
				double p2 = 0.0;
				double r = 0.0;
				GW::MATH::GVECTORD dots = {};

				for(int i = 0; i < 9; i++)
				{
					GW::MATH::GVector::DotD(
						v0,
						axis[i],
						p0);
					GW::MATH::GVector::DotD(
						v1,
						axis[i],
						p1);
					GW::MATH::GVector::DotD(
						v2,
						axis[i],
						p2);

					GW::MATH::GVector::DotD(
						right,
						axis[i],
						dots.x);
					GW::MATH::GVector::DotD(
						up,
						axis[i],
						dots.y);
					GW::MATH::GVector::DotD(
						forward,
						axis[i],
						dots.z);

					r =
						_aabb.extent.x * G_ABS(dots.x) +
						_aabb.extent.y * G_ABS(dots.y) +
						_aabb.extent.z * G_ABS(dots.z);

					if(G_LARGER(-G_LARGER(p0, -G_LARGER(p1, p2)),
								G_SMALLER(p0, G_SMALLER(p1, p2))) > r)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test the 3 axis corresponding to the face normals of the AABB
				if(G_LARGER(v0.x, G_LARGER(v1.x, v2.x)) < -_aabb.extent.x ||
				   G_SMALLER(v0.x, G_SMALLER(v1.x, v2.x)) > _aabb.extent.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.y, G_LARGER(v1.y, v2.y)) < -_aabb.extent.y ||
				   G_SMALLER(v0.y, G_SMALLER(v1.y, v2.y)) > _aabb.extent.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.z, G_LARGER(v1.z, v2.z)) < -_aabb.extent.z ||
				   G_SMALLER(v0.z, G_SMALLER(v1.z, v2.z)) > _aabb.extent.z)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test separating axis to triangle face normal
				GW::MATH::GPLANED plane;

				ComputePlaneD(
					_triangle.a,
					_triangle.b,
					_triangle.c,
					plane);

				return TestPlaneToAABBD(
					plane,
					_aabb,
					_outResult);
			}

			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a,
							_triangle.b,
							_triangle.c
						}
					}
				};
				triangle.a.w = 1.0f;
				triangle.b.w = 1.0f;
				triangle.c.w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.a,
					triangle.a);
				GW::MATH::GVector::AddVectorD(
					triangle.a,
					_obb.center,
					triangle.a);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.b,
					triangle.b);
				GW::MATH::GVector::AddVectorD(
					triangle.b,
					_obb.center,
					triangle.b);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.c,
					triangle.c);
				GW::MATH::GVector::AddVectorD(
					triangle.c,
					_obb.center,
					triangle.c);

				return TestTriangleToAABBD(
					triangle,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					_plane1.data.xyz(),
					_plane2.data.xyz(),
					cross);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					cross,
					cross,
					dot);

				_outResult = (dot < 1.192092896e-07) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				double distance = 0.0;
				GW::MATH::GVector::DotD(
					_sphere.data.xyz(),
					_plane.data.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= _sphere.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				double distance_start = 0.0;
				GW::MATH::GVector::DotD(
					_capsule.data[0].xyz(),
					_plane.data.xyz(),
					distance_start);
				distance_start -= _plane.distance;

				double distance_end = 0.0;
				GW::MATH::GVector::DotD(
					_capsule.data[1].xyz(),
					_plane.data.xyz(),
					distance_end);
				distance_end -= _plane.distance;

				if(distance_start * distance_end < 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(distance_start) <= _capsule.radius || G_ABS(distance_end) <= _capsule.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = (distance_start > 0.0) ?
					GCollisionCheck::ABOVE :
					GCollisionCheck::BELOW;
				return GReturn::SUCCESS;

			}

			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD plane_normal = _plane.data.xyz();

				double interval =
					_aabb.extent.x * G_ABS(_plane.x) +
					_aabb.extent.y * G_ABS(_plane.y) +
					_aabb.extent.z * G_ABS(_plane.z);

				double distance = 0.0;
				GW::MATH::GVector::DotD(
					plane_normal,
					_aabb.center.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD plane_normal = _plane.data.xyz();

				double xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				double yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				double zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;

				double xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				double xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				double yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;

				double wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				double wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				double wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORD obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				double interval = 0.0;
				double s = 0.0;

				for(int i = 0; i < 3; i++)
				{
					GW::MATH::GVector::DotD(
						plane_normal,
						obb_rotation[i],
						s);

					interval += _obb.extent.data[i] * G_ABS(s);
				}

				GW::MATH::GVector::DotD(
					plane_normal,
					_obb.center.xyz(),
					s);

				s -= _plane.distance;

				if(G_ABS(s) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (s > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_sphere1.data.xyz(),
					_sphere2.data.xyz(),
					difference_ba);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_distance);

				double sq_radii = _sphere1.radius + _sphere2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				// Compute squared distance between the sphere center and capsule's start and end.
				double sq_distance = 0.0;
				SqDistancePointToLineD(
					_sphere.data,
					{{{_capsule.data[0], _capsule.data[1]}}},
					sq_distance);

				double sq_radii = _sphere.radius + _capsule.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					_aabb,
					mm);

				double sq_distance = 0.0;
				SqDistancePointToAABBD(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToOBBD(
					_obb,
					_sphere.data.xyz(),
					closest_point);

				GW::MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					closest_point,
					_sphere.data.xyz(),
					difference);

				double sq_radius = _sphere.radius * _sphere.radius;

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance);

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD closest1 = {};
				MATH::GVECTORD closest2 = {};

				ClosestPointsToLineFromLineD(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					closest1,
					closest2);

				MATH::GVECTORD difference_ab = {};
				GW::MATH::GVector::SubtractVectorD(
					closest1,
					closest2,
					difference_ab);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ab,
					difference_ab,
					sq_distance);

				double sq_radii = _capsule1.radius + _capsule2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				// Expand AABB extents by capsule's radius.
				GW::MATH::GVECTORD center = _aabb.center.xyz();
				GW::MATH::GVECTORD extent = _aabb.extent.xyz();
				extent.x += _capsule.radius;
				extent.y += _capsule.radius;
				extent.z += _capsule.radius;

				GW::MATH::GVECTORD line_midpoint = {};
				GW::MATH::GVector::AddVectorD(
					_capsule.data[0].xyz(),
					_capsule.data[1].xyz(),
					line_midpoint);

				GW::MATH::GVector::ScaleD(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORD line_mid_length = {};
				GW::MATH::GVector::SubtractVectorD(
					_capsule.data[1].xyz(),
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORD o = {};
				GW::MATH::GVector::SubtractVectorD(
					line_midpoint,
					center,
					o);

				GW::MATH::GVECTORD axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(o.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 1.192092896e-07;
				axis.y += 1.192092896e-07;
				axis.z += 1.192092896e-07;

				if(G_ABS(o.y * line_mid_length.z - o.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.z * line_mid_length.x - o.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.x * line_mid_length.z - o.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GCAPSULED capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);
				GW::MATH::GVector::AddVectorD(
					capsule.data[0],
					_obb.center,
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);
				GW::MATH::GVector::AddVectorD(
					capsule.data[1],
					_obb.center,
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				return TestCapsuleToAABBD(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GOBBD obb =
				{
					{
						{
							_aabb.center,
							_aabb.extent,
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				return TestOBBToOBBD(
					obb,
					_obb,
					_outResult);
			}

			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult)
			{
				// Convert quaternions into 3 axes for both OBB1 and OBB2.
				double xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
				double yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
				double zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

				double xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
				double xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
				double yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

				double wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
				double wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
				double wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

				MATH::GVECTORD obb1_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
				yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
				zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

				xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
				xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
				yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

				wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
				wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
				wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

				MATH::GVECTORD obb2_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				double projected_radii = 0.0;
				double projected_radii_1 = 0.0;
				double projected_radii_2 = 0.0;
				double test_axis = 0.0;

				double rotation[3][3] = {};
				double abs_rotation[3][3] = {};

				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						GW::MATH::GVector::DotD(
							obb1_rotation[i],
							obb2_rotation[j],
							rotation[i][j]);
					}
				}

				// Get translation and then bring it into a's coordinate frame.
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_obb2.center,
					_obb1.center,
					difference_ba);

				MATH::GVECTORD translation_vec = {};
				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[0],
					translation_vec.x);

				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[1],
					translation_vec.y);

				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[2],
					translation_vec.z);

				// Get common values while maintaining numerical precision.
				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						abs_rotation[i][j] =
							G_ABS(rotation[i][j]) + 1.192092896e-07;
					}
				}

				// Test axes for OBB1 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 = _obb1.extent.data[i];

					projected_radii_2 =
						_obb2.extent.data[0] * abs_rotation[i][0] +
						_obb2.extent.data[1] * abs_rotation[i][1] +
						_obb2.extent.data[2] * abs_rotation[i][2];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(translation_vec.data[i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test axes for OBB2 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 =
						_obb1.extent.data[0] * abs_rotation[0][i] +
						_obb1.extent.data[1] * abs_rotation[1][i] +
						_obb1.extent.data[2] * abs_rotation[2][i];

					projected_radii_2 = _obb2.extent.data[i];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(
						translation_vec.data[0] * rotation[0][i] +
						translation_vec.data[1] * rotation[1][i] +
						translation_vec.data[2] * rotation[2][i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test OBB1 x & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[1][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][0] -
					translation_vec.data[1] * rotation[2][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[1][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][1] -
					translation_vec.data[1] * rotation[2][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[1][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][1] +
					_obb2.extent.data[1] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][2] -
					translation_vec.data[1] * rotation[2][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][0] -
					translation_vec.data[2] * rotation[0][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][1] -
					translation_vec.data[2] * rotation[0][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][1] +
					_obb2.extent.data[1] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][2] -
					translation_vec.data[2] * rotation[0][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][0] +
					_obb1.extent.data[1] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][0] -
					translation_vec.data[0] * rotation[1][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][1] +
					_obb1.extent.data[1] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][1] -
					translation_vec.data[0] * rotation[1][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][2] +
					_obb1.extent.data[1] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][1] +
					_obb2.extent.data[1] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][2] -
					translation_vec.data[0] * rotation[1][2]);

				_outResult = test_axis > projected_radii ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD norm = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORD difference_line = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					line.end,
					difference_line);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					triangle.a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0 || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0 || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double over_denom = 1.0f / dot;
				barycentric.y *= over_denom;
				barycentric.z *= over_denom;
				barycentric.x = 1.0f - barycentric.y - barycentric.z;
				_outInterval = interval * over_denom;

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					difference_ba,
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0 && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					_outDirection = difference_ba;
					GW::MATH::GVector::NormalizeD(
						_outDirection,
						_outDirection);

					GW::MATH::GVector::ScaleD(
						difference_ba,
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_line.start.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					num -= _plane.distance;

					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					_sphere.data.xyz(),
					difference_ba);

				GW::MATH::GVECTORD dir = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					dir);

				double sq_length = 0.0f;
				GW::MATH::GVector::DotD(
					dir,
					dir,
					sq_length);

				if(GW::MATH::GVector::NormalizeD(dir, dir) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				double b = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					dir,
					b);

				double c = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outDirection = dir;
				_outInterval = -b - sqrt(discriminant);

				if(_outInterval <= 0.0f)
				{
					// Line is contained in sphere.
					// Clamp to line start.
					_outInterval = 0.0f;
					_outContactPoint = line.start;
				}
				else if(_outInterval * _outInterval >= sq_length)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}
				else
				{
					GW::MATH::GVector::ScaleD(
						_outDirection,
						_outInterval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_outContactPoint,
						line.start,
						_outContactPoint);
				}

				_outResult = GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointsToLineFromLineD(
					_line,
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					closest_point2);

				MATH::GSPHERED sphere = {};
				sphere.data = closest_point2;
				sphere.radius = _capsule.radius;

				return IntersectLineToSphereD(
					_line,
					sphere,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval);
			}

			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

								// TODO div by 0
				double interval1 = (_aabb.min.x - _line.start.x) / _outDirection.x;
				double interval2 = (_aabb.max.x - _line.start.x) / _outDirection.x;

				double interval3 = (_aabb.min.y - _line.start.y) / _outDirection.y;
				double interval4 = (_aabb.max.y - _line.start.y) / _outDirection.y;

				double interval5 = (_aabb.min.z - _line.start.z) / _outDirection.z;
				double interval6 = (_aabb.max.z - _line.start.z) / _outDirection.z;

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0 || interval_min > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_line.start.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line = {};
				line.start = _line.start;
				line.start.w = 1.0f;
				line.end = _line.end;
				line.end.w = 1.0f;

				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorD(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorD(
					line.end,
					_obb.center,
					line.end);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				if(IntersectLineToAABBD(
					line,
					mm,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval)
			{
				MATH::GRAYD ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD q = {};
				GW::MATH::GVector::CrossVector3D(
					ray.direction,
					difference_ca,
					q);

				double det = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double denom = 1.0f / det;

				GW::MATH::GVECTORD s = {};
				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD r = {};
				GW::MATH::GVector::CrossVector3D(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotD(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				barycentric.x = 1.0f - barycentric.y - barycentric.z;

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				GW::MATH::GVECTORD v = {};
				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					ray.position,
					v);
				GW::MATH::GVector::DotD(
					v,
					v,
					_outInterval);

				_outInterval = sqrt(_outInterval);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				double denom = 0.0f;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0f;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					GW::MATH::GVector::ScaleD(
						_ray.direction.xyz(),
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_ray.position.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				double b = 0.0;
				MATH::GVECTORD direction_n = _ray.direction.xyz();
				GW::MATH::GVector::DotD(
					difference_ba,
					direction_n,
					b);

				double c = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c = c - _sphere.radius * _sphere.radius;

				if(c > 0.0 && b > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double discriminant = b * b - c;

				if(discriminant < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = -b - sqrt(discriminant);

				// If t is negative, ray started inside sphere so clamp t to zero
				if(_outInterval < 0.0)
				{
					_outInterval = 0.0;
				}

				GW::MATH::GVector::ScaleD(
					direction_n,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHERED sphere = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineD(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectRayToSphereD(
					_ray,
					sphere,
					_outResult,
					_outContactPoint,
					_outInterval);
			}

			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				double interval1 = 0.0;
				double interval2 = 0.0;
				double interval3 = 0.0;
				double interval4 = 0.0;
				double interval5 = 0.0;
				double interval6 = 0.0;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleD(
					_ray.direction.xyz(),
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYD ray = {};
				ray.position = _ray.position;
				ray.position.w = 1.0f;
				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorD(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				IntersectRayToAABBD(
					ray,
					mm,
					_outResult,
					_outContactPoint,
					_outInterval);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				TestSphereToSphereD(
					_sphere1,
					_sphere2,
					_outResult);

				if (static_cast<int>(_outResult) < 1)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					_sphere2.data.xyz(),
					_sphere1.data.xyz(),
					_outDirection);

				GW::MATH::GVector::NormalizeD(
					_outDirection,
					_outDirection);

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_sphere1.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorD(
					_sphere1.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				GW::MATH::GVector::ScaleD(
					_outDirection,
					-_sphere2.radius,
					_outContactClosest2);

				GW::MATH::GVector::AddVectorD(
					_sphere2.data.xyz(),
					_outContactClosest2,
					_outContactClosest2);

				GW::MATH::GVECTORD difference = {};

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_outContactClosest2,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GSPHERED sphere = {};

				ClosestPointToLineD(
					{{{_capsule.data[0], _capsule.data[1]}}},
					_sphere.data,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectSphereToSphereD(
					_sphere,
					sphere,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					_aabb,
					mm);

				double sq_distance = 0.0;
				SqDistancePointToAABBD(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				if(_outResult < GCollisionCheck::COLLISION)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					_aabb.center.xyz(),
					_sphere.data.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_sphere.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorD(
					_sphere.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				for(int i = 0; i < 3; i++)
				{
					_outContactClosest2.data[i] = _sphere.data.data[i];

					_outContactClosest2.data[i] = G_LARGER(
						_outContactClosest2.data[i],
						mm.min.data[i]);

					_outContactClosest2.data[i] = G_SMALLER(
						_outContactClosest2.data[i],
						mm.max.data[i]);
				}

				// Point is inside AABB so clamp to closest face
				if(G_ABS(_sphere.x - _outContactClosest2.x) < 1.192092896e-07 ||
				   G_ABS(_sphere.y - _outContactClosest2.y) < 1.192092896e-07 ||
				   G_ABS(_sphere.z - _outContactClosest2.z) < 1.192092896e-07)
				{
					GW::MATH::GVECTORD translation = {};
					double low = static_cast<double>(0xffffffff);
					double val = 0.0;

					val = mm.max.x - _sphere.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0, 0.0}}};
						low = G_ABS(val);
					}

					val = _sphere.x - mm.min.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0, 0.0}}};
						low = G_ABS(val);
					}

					val = mm.max.y - _sphere.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, val, 0.0}}};
						low = G_ABS(val);
					}

					val = _sphere.y - mm.min.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, val, 0.0}}};
						low = G_ABS(val);
					}

					val = mm.max.z - _sphere.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, 0.0, val}}};
						low = G_ABS(val);
					}

					val = _sphere.z - mm.min.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, 0.0, val}}};
						low = G_ABS(val);
					}

					GW::MATH::GVector::AddVectorD(
						_outContactClosest2,
						translation,
						_outContactClosest2);
				}

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_outContactClosest1,
					_outDirection);

				GW::MATH::GVector::DotD(
					_outDirection,
					_outDirection,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GSPHERED sphere = {};
				sphere.data = _sphere.data;
				sphere.radius = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					sphere.data,
					sphere.data);
				GW::MATH::GVector::AddVectorD(
					sphere.data,
					_obb.center,
					sphere.data);
				sphere.radius = _sphere.radius;

				IntersectSphereToAABBD(
					sphere,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GSPHERED sphere1 = {};
				MATH::GSPHERED sphere2 = {};

				ClosestPointsToLineFromLineD(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					sphere1.data,
					sphere2.data);

				sphere1.radius = _capsule1.radius;
				sphere2.radius = _capsule2.radius;

				return IntersectSphereToSphereD(
					sphere1,
					sphere2,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				// Extend AABB by capsule radius
				MATH::GAABBMMD aabbMM =
				{
					{
						{
							{{{_aabb.min.x - _capsule.radius, _aabb.min.y - _capsule.radius, _aabb.min.z - _capsule.radius , 0.0}}},
							{{{_aabb.max.x + _capsule.radius, _aabb.max.y + _capsule.radius, _aabb.max.z + _capsule.radius}}}
						}
					}
				};

				MATH::GRAYD ray = {};
				ray.position = _capsule.data[0].xyz();

				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					_capsule.data[0].xyz(),
					ray.direction);

				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				IntersectRayToAABBD(
					ray,
					aabbMM,
					_outResult,
					_outContactClosest1,
					_outDistance);

				if(static_cast<int>(_outResult) <= 0 || _outDistance > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Flags to determine the region
				int u = 0;
				int v = 0;

				if(_outContactClosest1.x < _aabb.min.x)
				{
					u |= 1;
				}
				if(_outContactClosest1.x > _aabb.max.x)
				{
					v |= 1;
				}

				if(_outContactClosest1.y < _aabb.min.y)
				{
					u |= 2;
				}
				if(_outContactClosest1.y > _aabb.max.y)
				{
					v |= 2;
				}

				if(_outContactClosest1.z < _aabb.min.z)
				{
					u |= 4;
				}
				if(_outContactClosest1.z > _aabb.max.z)
				{
					v |= 4;
				}

				int m = u + v;

				auto Corner = [](const MATH::GAABBMMD box, const int n)->GW::MATH::GVECTORD
				{
					if(n & 1)
					{
						return GW::MATH::GVECTORD{{{box.max.x, box.max.y, box.max.z}}};
					}
					else
					{
						return GW::MATH::GVECTORD{{{box.min.x, box.min.y, box.min.z}}};
					}
				};

				GW::MATH::GCAPSULED capsule;
				capsule.data[0] = Corner(aabbMM, v);

				// Vertex Region
				if(m == 7)
				{
					double tmin = static_cast<double>(0xffffffff);

					capsule.data[1] = Corner(aabbMM, v ^ 1);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 2);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if(static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 4);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					if(tmin == static_cast<double>(0xffffffff))
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}

					_outDistance = tmin;

					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if((m & (m - 1)) == 0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				capsule.data[1] = capsule.data[0];
				capsule.data[0] = Corner(aabbMM, u ^ 7);

				return IntersectLineToCapsuleD(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					capsule,
					_outResult,
					_outContactClosest1,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				MATH::GCAPSULED capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				IntersectCapsuleToAABBD(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				MATH::GAABBMMD aabb = {};
				aabb.min.x = G_LARGER(_aabb1.center.x - _aabb1.extent.x, _aabb2.center.x - _aabb2.extent.x);
				aabb.max.x = G_SMALLER(_aabb1.center.x + _aabb1.extent.x, _aabb2.center.x + _aabb2.extent.x);
				aabb.min.y = G_LARGER(_aabb1.center.y - _aabb1.extent.y, _aabb2.center.y - _aabb2.extent.y);
				aabb.max.y = G_SMALLER(_aabb1.center.y + _aabb1.extent.y, _aabb2.center.y + _aabb2.extent.y);
				aabb.min.z = G_LARGER(_aabb1.center.z - _aabb1.extent.z, _aabb2.center.z - _aabb2.extent.z);
				aabb.max.z = G_SMALLER(_aabb1.center.z + _aabb1.extent.z, _aabb2.center.z + _aabb2.extent.z);

				GW::MATH::GVECTORD difference = {};

				GW::MATH::GVector::SubtractVectorD(
					aabb.max,
					aabb.min,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				GW::MATH::GVector::SubtractVectorD(
					_aabb2.center,
					_aabb1.center,
					_outDirection);

				GW::MATH::GVector::NormalizeD(
					_outDirection,
					_outDirection);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			/*static GReturn IntersectAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return IntersectOBBToOBBD(
					{_aabb.center, _aabb.extent},
					_obb,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}*/

			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance)
			{
				GW::MATH::GVECTORD p = _point.xyz();

				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					difference_ba);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					line.start,
					difference_pa);

				MATH::GVECTORD difference_pb = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					line.end,
					difference_pb);

				double interval1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_ba,
					interval1);

				if(interval1 <= 0.0)
				{
					GW::MATH::GVector::DotD(
						difference_pa,
						difference_pa,
						_outDistance);

					return GReturn::SUCCESS;
				}

				double interval2 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					interval2);

				if(interval1 >= interval2)
				{
					GW::MATH::GVector::DotD(
						difference_pb,
						difference_pb,
						_outDistance);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_pa,
					difference_pa,
					_outDistance);

				if(G_ABS(interval2) >= 1.192092896e-07)
				{
					_outDistance -= interval1 * interval1 / interval2;
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};

				ClosestPointToRayD(
					_ray,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToTriangleD(
					_triangle,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance)
			{
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_point.xyz(),
					_outDistance);
				_outDistance -= _plane.distance;
				_outDistance *= _outDistance;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToSphereD(
					_sphere,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToCapsuleD(
					_capsule,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance)
			{

				_outDistance = 0.0;

				for(int i = 0; i < 3; i++)
				{
					double v = _point.data[i];

					if(v < _aabb.min.data[i])
					{
						_outDistance += (_aabb.min.data[i] - v) * (_aabb.min.data[i] - v);
					}

					if(v > _aabb.max.data[i])
					{
						_outDistance += (v - _aabb.max.data[i]) * (v - _aabb.max.data[i]);
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance)
			{
				MATH::GVECTORD p = {};
				ClosestPointToOBBD(
					_obb,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point,
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_b,
					_a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_c,
					_a,
					difference_ca);

				MATH::GVECTORD triangle_n = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ba,
					difference_ca,
					triangle_n);

				double x = G_ABS(triangle_n.x);
				double y = G_ABS(triangle_n.y);
				double z = G_ABS(triangle_n.z);

				// Degenerate triangle
				if(x + y + z < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				double nominator_u = 0.0;
				double nominator_v = 0.0;
				double w = 0.0;

				// Project to yz plane
				if(x >= y && x >= z)
				{
					// Area of pbc in yz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.y - _b.y,_b.y - _c.y}}},
						GW::MATH::GVECTORD{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in yz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.y - _c.y,_c.y - _a.y}}},
						GW::MATH::GVECTORD{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0 / triangle_n.x;
				}
				// Project to the xz plane
				else if(y >= x && y >= z)
				{
					// Area of pbc in xz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORD{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in xz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORD{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0 / (-triangle_n.y);
				}
				// Project to the xy plane
				else
				{
					// Area of pbc in xy plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORD{{{_p.y - _b.y,_b.y - _c.y}}},
						nominator_u);

					// Area of pca in xy plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORD{{{_p.y - _c.y,_c.y - _a.y}}},
						nominator_v);

					w = 1.0 / triangle_n.z;
				}

				double u = nominator_u * w;
				double v = nominator_v * w;

				_outBarycentric =
				{
					{
						{
							u,
							v,
							1.0 - u - v
						}
					}
				};

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH
	{
		class GCollision final
			: public I::GProxy<I::GCollisionInterface, I::GCollisionImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GCollision)
			GATEWARE_TYPEDEF(GCollisionCheck)
			GATEWARE_STATIC_FUNCTION(ConvertAABBCEToAABBMMF)
			GATEWARE_STATIC_FUNCTION(ConvertAABBMMToAABBCEF)
			GATEWARE_STATIC_FUNCTION(ComputePlaneF)
			GATEWARE_STATIC_FUNCTION(IsTriangleF)
			GATEWARE_STATIC_FUNCTION(TestPointToConvexPolygonF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToLineF)
			GATEWARE_STATIC_FUNCTION(ClosestPointsToLineFromLineF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToRayF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToTriangleF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToPlaneF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToSphereF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToAABBF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToOBBF)
			GATEWARE_STATIC_FUNCTION(ComputeSphereFromPointsF)
			GATEWARE_STATIC_FUNCTION(ComputeAABBFromPointsF)
			GATEWARE_STATIC_FUNCTION(TestPointToLineF)
			GATEWARE_STATIC_FUNCTION(TestPointToRayF)
			GATEWARE_STATIC_FUNCTION(TestPointToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestPointToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestPointToSphereF)
			GATEWARE_STATIC_FUNCTION(TestPointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestPointToAABBF)
			GATEWARE_STATIC_FUNCTION(TestPointToOBBF)
			GATEWARE_STATIC_FUNCTION(TestLineToLineF)
			GATEWARE_STATIC_FUNCTION(TestLineToRayF)
			GATEWARE_STATIC_FUNCTION(TestLineToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestLineToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestLineToSphereF)
			GATEWARE_STATIC_FUNCTION(TestLineToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestLineToAABBF)
			GATEWARE_STATIC_FUNCTION(TestLineToOBBF)
			GATEWARE_STATIC_FUNCTION(TestRayToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestRayToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestRayToSphereF)
			GATEWARE_STATIC_FUNCTION(TestRayToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestRayToAABBF)
			GATEWARE_STATIC_FUNCTION(TestRayToOBBF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToSphereF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToAABBF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToOBBF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToSphereF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToAABBF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToOBBF)
			GATEWARE_STATIC_FUNCTION(TestSphereToSphereF)
			GATEWARE_STATIC_FUNCTION(TestSphereToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestSphereToAABBF)
			GATEWARE_STATIC_FUNCTION(TestSphereToOBBF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToAABBF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToOBBF)
			GATEWARE_STATIC_FUNCTION(TestAABBToAABBF)
			GATEWARE_STATIC_FUNCTION(TestAABBToOBBF)
			GATEWARE_STATIC_FUNCTION(TestOBBToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToTriangleF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToPlaneF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToTriangleF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToPlaneF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectAABBToAABBF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLineF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRayF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToTriangleF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPlaneF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToSphereF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToAABBF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToOBBF)
			GATEWARE_STATIC_FUNCTION(BarycentricF)

			// Double
			GATEWARE_STATIC_FUNCTION(ConvertAABBCEToAABBMMD)
			GATEWARE_STATIC_FUNCTION(ConvertAABBMMToAABBCED)
			GATEWARE_STATIC_FUNCTION(ComputePlaneD)
			GATEWARE_STATIC_FUNCTION(IsTriangleD)
			GATEWARE_STATIC_FUNCTION(TestPointToConvexPolygonD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToLineD)
			GATEWARE_STATIC_FUNCTION(ClosestPointsToLineFromLineD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToRayD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToTriangleD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToPlaneD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToSphereD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToAABBD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToOBBD)
			GATEWARE_STATIC_FUNCTION(ComputeSphereFromPointsD)
			GATEWARE_STATIC_FUNCTION(ComputeAABBFromPointsD)
			GATEWARE_STATIC_FUNCTION(TestPointToLineD)
			GATEWARE_STATIC_FUNCTION(TestPointToRayD)
			GATEWARE_STATIC_FUNCTION(TestPointToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestPointToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestPointToSphereD)
			GATEWARE_STATIC_FUNCTION(TestPointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestPointToAABBD)
			GATEWARE_STATIC_FUNCTION(TestPointToOBBD)
			GATEWARE_STATIC_FUNCTION(TestLineToLineD)
			GATEWARE_STATIC_FUNCTION(TestLineToRayD)
			GATEWARE_STATIC_FUNCTION(TestLineToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestLineToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestLineToSphereD)
			GATEWARE_STATIC_FUNCTION(TestLineToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestLineToAABBD)
			GATEWARE_STATIC_FUNCTION(TestLineToOBBD)
			GATEWARE_STATIC_FUNCTION(TestRayToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestRayToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestRayToSphereD)
			GATEWARE_STATIC_FUNCTION(TestRayToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestRayToAABBD)
			GATEWARE_STATIC_FUNCTION(TestRayToOBBD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToSphereD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToAABBD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToOBBD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToSphereD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToAABBD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToOBBD)
			GATEWARE_STATIC_FUNCTION(TestSphereToSphereD)
			GATEWARE_STATIC_FUNCTION(TestSphereToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestSphereToAABBD)
			GATEWARE_STATIC_FUNCTION(TestSphereToOBBD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToAABBD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToOBBD)
			GATEWARE_STATIC_FUNCTION(TestAABBToAABBD)
			GATEWARE_STATIC_FUNCTION(TestAABBToOBBD)
			GATEWARE_STATIC_FUNCTION(TestOBBToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToTriangleD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToPlaneD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToTriangleD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToPlaneD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectAABBToAABBD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLineD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRayD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToTriangleD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPlaneD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToSphereD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToAABBD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToOBBD)
			GATEWARE_STATIC_FUNCTION(BarycentricD)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}

#endif // GCOLLISION_H

/*---------------------------------
|	End of GCollision.h
----------------------------------*/


/*---------------------------------
|	Begin of GQuaternion.h
----------------------------------*/
#ifndef GQUATERNION_H
#define GQUATERNION_H





namespace GW
{
	namespace I
	{
		class GQuaternionInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleF( MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByVectorAngleF( MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByMatrixF( MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConjugateF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeF( MATH::GQUATERNIONF _quaternion, float& _outMagnitude ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityF( MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SlerpF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn AddQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleD( MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByVectorAngleD( MATH::GVECTORD _vector, double _radian, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByMatrixD( MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outValue ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConjugateD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeD( MATH::GQUATERNIOND _quaternion, double& _outMagnitude ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityD( MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SlerpD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GQuaternion.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GQUATERNION) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GQUATERNION) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GQuaternionImplementation : public virtual GQuaternionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			// Floats
			static GReturn AddQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MultiplyQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleF(MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByVectorAngleF(MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByMatrixF(MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ConjugateF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn InverseF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeF(MATH::GQUATERNIONF _quaternion, float& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn IdentityF(MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SlerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) 
			{
				return GReturn::FAILURE; 
			}
			// Doubles
			static GReturn AddQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MultiplyQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleD(MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByVectorAngleD(MATH::GVECTORD _vector, double _radain, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByMatrixD(MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ConjugateD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn InverseD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeD(MATH::GQUATERNIOND _quaternion, double& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn IdentityD(MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, float _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SlerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF)
			{
				return GReturn::FAILURE; 
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GQuaternionImplementation : public virtual GQuaternionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}
			static GReturn AddQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x + _quaternion2.x;
				_outQuaternion.y = _quaternion1.y + _quaternion2.y;
				_outQuaternion.z = _quaternion1.z + _quaternion2.z;
				_outQuaternion.w = _quaternion1.w + _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn SubtractQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x - _quaternion2.x;
				_outQuaternion.y = _quaternion1.y - _quaternion2.y;
				_outQuaternion.z = _quaternion1.z - _quaternion2.z;
				_outQuaternion.w = _quaternion1.w - _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn MultiplyQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF _q1 = _quaternion1;
				MATH::GQUATERNIONF _q2 = _quaternion2;

				_outQuaternion.x = _q1.w * _q2.x + _q1.x * _q2.w + _q1.y * _q2.z - _q1.z * _q2.y;
				_outQuaternion.y = _q1.w * _q2.y - _q1.x * _q2.z + _q1.y * _q2.w + _q1.z * _q2.x;
				_outQuaternion.z = _q1.w * _q2.z + _q1.x * _q2.y - _q1.y * _q2.x + _q1.z * _q2.w;
				_outQuaternion.w = _q1.w * _q2.w - _q1.x * _q2.x - _q1.y * _q2.y - _q1.z * _q2.z;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleF(MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion.x * _scalar;
				_outQuaternion.y = _quaternion.y * _scalar;
				_outQuaternion.z = _quaternion.z * _scalar;
				_outQuaternion.w = _quaternion.w * _scalar;
				return GReturn::SUCCESS;
			}
			static GReturn SetByVectorAngleF(MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion)
			{
				float s = sinf(_radian / 2.0f);
				_outQuaternion.x = s * _vector.x;
				_outQuaternion.y = s * _vector.y;
				_outQuaternion.z = s * _vector.z;
				_outQuaternion.w = cosf(_radian / 2.0f);
				return GReturn::SUCCESS;
			}
			static GReturn SetByMatrixF(MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion)
			{
				float det;
				float sx = sqrtf(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				float sy = sqrtf(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				float sz = sqrtf(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				if (G_COMPARISON_STANDARD_F(sx, 0.0f) || G_COMPARISON_STANDARD_F(sy, 0.0f) || G_COMPARISON_STANDARD_F(sz, 0.0f))
				{
					//scale too close to zero, can not decompose rotation
					return GReturn::FAILURE;
				}

				float a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				float a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				float a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				float a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				float a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				float a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				float b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				float b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				float b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				float b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				float b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				float b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				if (det < 0)
				{
					sz = -sz;
				}
				MATH::GMATRIXF Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				float trace = _matrix.data[0] + _matrix.data[5] + _matrix.data[10] + 1;

				if (trace > G_EPSILON_F)
				{
					float s = 0.5f / sqrtf(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25f / s;
				}
				else
				{
					if (Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25f / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if (Rotation.row2.y > Rotation.row3.z)
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25f / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25f / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}
				return GReturn::SUCCESS;
			}
			static GReturn DotF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue)
			{
				_outValue = _quaternion1.w * _quaternion2.w + _quaternion1.x * _quaternion2.x + _quaternion1.y * _quaternion2.y + _quaternion1.z * _quaternion2.z;
				return GReturn::SUCCESS;
			}
			static GReturn CrossF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = (_quaternion1.y * _quaternion2.z) - (_quaternion1.z * _quaternion2.y);
				_outVector.y = (_quaternion1.z * _quaternion2.x) - (_quaternion1.x * _quaternion2.z);
				_outVector.z = (_quaternion1.x * _quaternion2.y) - (_quaternion1.y * _quaternion2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn ConjugateF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = -_quaternion.x;
				_outQuaternion.y = -_quaternion.y;
				_outQuaternion.z = -_quaternion.z;
				_outQuaternion.w = _quaternion.w;
				return GReturn::SUCCESS;
			}
			static GReturn InverseF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF temp;
				float magnitude;
				ConjugateF(_quaternion, temp);
				if (MagnitudeF(_quaternion, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}
				_outQuaternion.x = temp.x / (magnitude * magnitude);
				_outQuaternion.y = temp.y / (magnitude * magnitude);
				_outQuaternion.z = temp.z / (magnitude * magnitude);
				_outQuaternion.w = temp.w / (magnitude * magnitude);
				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeF(MATH::GQUATERNIONF _quaternion, float& _outMagnitude)
			{
				_outMagnitude = sqrtf(_quaternion.x * _quaternion.x + _quaternion.y * _quaternion.y + _quaternion.z * _quaternion.z + _quaternion.w * _quaternion.w);
				if (G_COMPARISON_STANDARD_F(_outMagnitude, G_EPSILON_F))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}
			static GReturn NormalizeF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				float magnitude;
				MagnitudeF(_quaternion, magnitude);
				if (G_COMPARISON_STANDARD_F(magnitude, 1.0f))
				{
					_outQuaternion = _quaternion;
					return GReturn::SUCCESS;
				}
				if (G_COMPARISON_STANDARD_F(magnitude, G_EPSILON_F))
				{
					return GReturn::FAILURE;
				}
				magnitude = 1 / magnitude;
				_outQuaternion.x = _quaternion.x * magnitude;
				_outQuaternion.y = _quaternion.y * magnitude;
				_outQuaternion.z = _quaternion.z * magnitude;
				_outQuaternion.w = _quaternion.w * magnitude;
				return GReturn::SUCCESS;
			}
			static GReturn IdentityF(MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion = MATH::GIdentityQuaternionF;
				return GReturn::SUCCESS;
			}
			static GReturn LerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = G_LERP(_quaternion1.x, _quaternion2.x, _ratio);
				_outQuaternion.y = G_LERP(_quaternion1.y, _quaternion2.y, _ratio);
				_outQuaternion.z = G_LERP(_quaternion1.z, _quaternion2.z, _ratio);
				_outQuaternion.w = G_LERP(_quaternion1.w, _quaternion2.w, _ratio);
				return GReturn::SUCCESS;
			}
			static GReturn SlerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF q1;
				MATH::GQUATERNIONF q2;
				if (NormalizeF(_quaternion1, q1) != GReturn::SUCCESS || NormalizeF(_quaternion2, q2) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}
				float dot;
				DotF(q1, q2, dot);
				float theta = acosf(dot);

				ScaleF(q1, sinf(theta * (1 - _ratio)) / sinf(theta), q1);
				ScaleF(q2, sinf(theta * _ratio) / sinf(theta), q2);

				AddQuaternionF(q1, q2, _outQuaternion);

				return GReturn::SUCCESS;
			}
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) 
			{
				_outQuaternionD.x = static_cast<double>(_quaternionF.x);
				_outQuaternionD.y = static_cast<double>(_quaternionF.y);
				_outQuaternionD.z = static_cast<double>(_quaternionF.z);
				_outQuaternionD.w = static_cast<double>(_quaternionF.w);

				return GReturn::SUCCESS; 
			}






			static GReturn AddQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x + _quaternion2.x;
				_outQuaternion.y = _quaternion1.y + _quaternion2.y;
				_outQuaternion.z = _quaternion1.z + _quaternion2.z;
				_outQuaternion.w = _quaternion1.w + _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn SubtractQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x - _quaternion2.x;
				_outQuaternion.y = _quaternion1.y - _quaternion2.y;
				_outQuaternion.z = _quaternion1.z - _quaternion2.z;
				_outQuaternion.w = _quaternion1.w - _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn MultiplyQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				MATH::GQUATERNIOND _q1 = _quaternion1;
				MATH::GQUATERNIOND _q2 = _quaternion2;
				_outQuaternion.x = _q1.w * _q2.x + _q1.x * _q2.w + _q1.y * _q2.z - _q1.z * _q2.y;
				_outQuaternion.y = _q1.w * _q2.y - _q1.x * _q2.z + _q1.y * _q2.w + _q1.z * _q2.x;
				_outQuaternion.z = _q1.w * _q2.z + _q1.x * _q2.y - _q1.y * _q2.x + _q1.z * _q2.w;
				_outQuaternion.w = _q1.w * _q2.w - _q1.x * _q2.x - _q1.y * _q2.y - _q1.z * _q2.z;


				return GReturn::SUCCESS;
			}
			static GReturn ScaleD(MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion.x * _scalar;
				_outQuaternion.y = _quaternion.y * _scalar;
				_outQuaternion.z = _quaternion.z * _scalar;
				_outQuaternion.w = _quaternion.w * _scalar;
				return GReturn::SUCCESS;
			}
			static GReturn SetByVectorAngleD(MATH::GVECTORD _vector, double _radian, MATH::GQUATERNIOND& _outQuaternion)
			{
				double s = sin(_radian / 2.0);
				_outQuaternion.x = s * _vector.x;
				_outQuaternion.y = s * _vector.y;
				_outQuaternion.z = s * _vector.z;
				_outQuaternion.w = cos(_radian / 2.0);
				return GReturn::SUCCESS;
			}
			static GReturn SetByMatrixD(MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion)
			{
				double det;
				double sx = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				double sy = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				double sz = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				if (G_COMPARISON_STANDARD_D(sx, 0) || G_COMPARISON_STANDARD_D(sy, 0) || G_COMPARISON_STANDARD_D(sz, 0))
				{
					//scale too close to zero, can not decompose rotation
					return GReturn::FAILURE;
				}
				double a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				double a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				double a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				double a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				double a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				double a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				double b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				double b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				double b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				double b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				double b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				double b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				if (det < 0)
				{
					sz = -sz;
				}
				MATH::GMATRIXD Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				double trace = _matrix.data[0] + _matrix.data[5] + _matrix.data[10] + 1;

				if (trace > G_EPSILON_D)
				{
					double s = 0.5 / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25 / s;
				}
				else
				{
					if (Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25 / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if (Rotation.row2.y > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25 / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25 / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}
				return GReturn::SUCCESS;
			}
			static GReturn DotD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outValue)
			{
				_outValue = _quaternion1.w * _quaternion2.w + _quaternion1.x * _quaternion2.x + _quaternion1.y * _quaternion2.y + _quaternion1.z * _quaternion2.z;
				return GReturn::SUCCESS;
			}
			static GReturn CrossD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = (_quaternion1.y * _quaternion2.z) - (_quaternion1.z * _quaternion2.y);
				_outVector.y = (_quaternion1.z * _quaternion2.x) - (_quaternion1.x * _quaternion2.z);
				_outVector.z = (_quaternion1.x * _quaternion2.y) - (_quaternion1.y * _quaternion2.x);
				_outVector.w = 0.0;

				return GReturn::SUCCESS;
			}
			static GReturn ConjugateD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = -_quaternion.x;
				_outQuaternion.y = -_quaternion.y;
				_outQuaternion.z = -_quaternion.z;
				_outQuaternion.w = _quaternion.w;

				return GReturn::SUCCESS;
			}
			static GReturn InverseD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				MATH::GQUATERNIOND temp;
				double magnitude;
				ConjugateD(_quaternion, temp);
				if (MagnitudeD(_quaternion, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				};

				_outQuaternion.x = temp.x / (magnitude * magnitude);
				_outQuaternion.y = temp.y / (magnitude * magnitude);
				_outQuaternion.z = temp.z / (magnitude * magnitude);
				_outQuaternion.w = temp.w / (magnitude * magnitude);
				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeD(MATH::GQUATERNIOND _quaternion, double& _outMagnitude)
			{
				_outMagnitude = sqrt(_quaternion.x * _quaternion.x + _quaternion.y * _quaternion.y + _quaternion.z * _quaternion.z + _quaternion.w * _quaternion.w);
				if (G_COMPARISON_STANDARD_D(_outMagnitude, 0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				double magnitude;
				MagnitudeD(_quaternion, magnitude);
				if (G_COMPARISON_STANDARD_D(magnitude, 1))
				{
					_outQuaternion = _quaternion;
					return GReturn::SUCCESS;
				}
				if (G_COMPARISON_STANDARD_D(magnitude, G_EPSILON_D))
				{
					return GReturn::FAILURE;
				}
				magnitude = 1 / magnitude;
				_outQuaternion.x = _quaternion.x * magnitude;
				_outQuaternion.y = _quaternion.y * magnitude;
				_outQuaternion.z = _quaternion.z * magnitude;
				_outQuaternion.w = _quaternion.w * magnitude;
				return GReturn::SUCCESS;
			}
			static GReturn IdentityD(MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion = MATH::GIdentityQuaternionD;
				return GReturn::SUCCESS;
			}
			static GReturn LerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				if (_ratio > 1)
					_ratio = 1;
				if (_ratio < 0)
					_ratio = 0;

				if (G_COMPARISON_STANDARD_D(_ratio, 0))
				{
					_outQuaternion = _quaternion1;
					return GReturn::SUCCESS;
				}
				else if (G_COMPARISON_STANDARD_D(_ratio, 1))
				{
					_outQuaternion = _quaternion2;
					return GReturn::SUCCESS;
				}

				_outQuaternion.x = G_LERP(_quaternion1.x, _quaternion2.x, _ratio);
				_outQuaternion.y = G_LERP(_quaternion1.y, _quaternion2.y, _ratio);
				_outQuaternion.z = G_LERP(_quaternion1.z, _quaternion2.z, _ratio);
				_outQuaternion.w = G_LERP(_quaternion1.w, _quaternion2.w, _ratio);
				return GReturn::SUCCESS;
			}
			static GReturn SlerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				if (_ratio > 1)
					_ratio = 1;
				if (_ratio < 0)
					_ratio = 0;

				MATH::GQUATERNIOND q1;
				MATH::GQUATERNIOND q2;
				if (NormalizeD(_quaternion1, q1) != GReturn::SUCCESS || NormalizeD(_quaternion2, q2) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}

				if (G_COMPARISON_STANDARD_D(_ratio, 0))
				{
					_outQuaternion = _quaternion1;
					return GReturn::SUCCESS;
				}
				else if (G_COMPARISON_STANDARD_D(_ratio, 1))
				{
					_outQuaternion = _quaternion2;
					return GReturn::SUCCESS;
				}


				double dot;
				DotD(q1, q2, dot);
				double theta = acos(dot);

				ScaleD(q1, sin(theta * (1 - _ratio)) / sin(theta), q1);
				ScaleD(q2, sin(theta * _ratio) / sin(theta), q2);

				AddQuaternionD(q1, q2, _outQuaternion);

				return GReturn::SUCCESS;
			}
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF) {
				_outQuaternionF.x = static_cast<float>(_quaternionD.x);
				_outQuaternionF.y = static_cast<float>(_quaternionD.y);
				_outQuaternionF.z = static_cast<float>(_quaternionD.z);
				_outQuaternionF.w = static_cast<float>(_quaternionD.w);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH
	{
		class GQuaternion final
			: public I::GProxy<I::GQuaternionInterface, I::GQuaternionImplementation >
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS( GQuaternion )
			GATEWARE_STATIC_FUNCTION(AddQuaternionF)
			GATEWARE_STATIC_FUNCTION(SubtractQuaternionF)
			GATEWARE_STATIC_FUNCTION(MultiplyQuaternionF)
			GATEWARE_STATIC_FUNCTION(ScaleF)
			GATEWARE_STATIC_FUNCTION(SetByVectorAngleF)
			GATEWARE_STATIC_FUNCTION(SetByMatrixF)
			GATEWARE_STATIC_FUNCTION(DotF)
			GATEWARE_STATIC_FUNCTION(CrossF)
			GATEWARE_STATIC_FUNCTION(ConjugateF)
			GATEWARE_STATIC_FUNCTION(InverseF)
			GATEWARE_STATIC_FUNCTION(MagnitudeF)
			GATEWARE_STATIC_FUNCTION(NormalizeF)
			GATEWARE_STATIC_FUNCTION(IdentityF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(SlerpF)
			GATEWARE_STATIC_FUNCTION(Upgrade)


			// Double Quaternion Methods
			GATEWARE_STATIC_FUNCTION(AddQuaternionD)
			GATEWARE_STATIC_FUNCTION(SubtractQuaternionD)
			GATEWARE_STATIC_FUNCTION(MultiplyQuaternionD)
			GATEWARE_STATIC_FUNCTION(ScaleD)
			GATEWARE_STATIC_FUNCTION(SetByVectorAngleD)
			GATEWARE_STATIC_FUNCTION(SetByMatrixD)
			GATEWARE_STATIC_FUNCTION(DotD)
			GATEWARE_STATIC_FUNCTION(CrossD)
			GATEWARE_STATIC_FUNCTION(ConjugateD)
			GATEWARE_STATIC_FUNCTION(InverseD)
			GATEWARE_STATIC_FUNCTION(MagnitudeD)
			GATEWARE_STATIC_FUNCTION(NormalizeD)
			GATEWARE_STATIC_FUNCTION(IdentityD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(SlerpD)
			GATEWARE_STATIC_FUNCTION(Downgrade)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GQUATERNION_H

/*---------------------------------
|	End of GQuaternion.h
----------------------------------*/


/*---------------------------------
|	Begin of GMatrix2D.h
----------------------------------*/
#ifndef GMATRIX2D_H
#define GMATRIX2D_H





namespace GW
{
	namespace I
	{
		class GMatrix2DInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GMatrix2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GMATRIX2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GMATRIX2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GMatrix2DImplementation : public virtual GMatrix2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}
			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::FAILURE; }
			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::FAILURE; }
			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::FAILURE; }
			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::FAILURE; }
			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::FAILURE; }
			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::FAILURE; }
			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::FAILURE; }
			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::FAILURE; }
			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GMatrix2DImplementation : public virtual GMatrix2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[2];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[3];

				_outMatrix.data[2] = _matrix1.data[2] * _matrix2.data[0] + _matrix1.data[3] * _matrix2.data[2];
				_outMatrix.data[3] = _matrix1.data[2] * _matrix2.data[1] + _matrix1.data[3] * _matrix2.data[3];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[3] + _matrix1.data[2] * _matrix2.data[6];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[4] + _matrix1.data[2] * _matrix2.data[7];
				_outMatrix.data[2] = _matrix1.data[0] * _matrix2.data[2] + _matrix1.data[1] * _matrix2.data[5] + _matrix1.data[2] * _matrix2.data[8];

				_outMatrix.data[3] = _matrix1.data[3] * _matrix2.data[0] + _matrix1.data[4] * _matrix2.data[3] + _matrix1.data[5] * _matrix2.data[6];
				_outMatrix.data[4] = _matrix1.data[3] * _matrix2.data[1] + _matrix1.data[4] * _matrix2.data[4] + _matrix1.data[5] * _matrix2.data[7];
				_outMatrix.data[5] = _matrix1.data[3] * _matrix2.data[2] + _matrix1.data[4] * _matrix2.data[5] + _matrix1.data[5] * _matrix2.data[8];

				_outMatrix.data[6] = _matrix1.data[6] * _matrix2.data[0] + _matrix1.data[7] * _matrix2.data[3] + _matrix1.data[8] * _matrix2.data[6];
				_outMatrix.data[7] = _matrix1.data[6] * _matrix2.data[1] + _matrix1.data[7] * _matrix2.data[4] + _matrix1.data[8] * _matrix2.data[7];
				_outMatrix.data[8] = _matrix1.data[6] * _matrix2.data[2] + _matrix1.data[7] * _matrix2.data[5] + _matrix1.data[8] * _matrix2.data[8];

				return GW::GReturn::SUCCESS;
			}

			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[2];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[3] + _vector.data[2] * _matrix.data[6];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[4] + _vector.data[2] * _matrix.data[7];
				_outVector.z = _vector.data[0] * _matrix.data[2] + _vector.data[1] * _matrix.data[5] + _vector.data[2] * _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant)
			{
				_outDeterminant = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant)
			{
				float a = (_matrix.data[0] * _matrix.data[4] * _matrix.data[8]) + (_matrix.data[1] * _matrix.data[5] * _matrix.data[6]) + (_matrix.data[2] * _matrix.data[3] * _matrix.data[7]);
				float b = (_matrix.data[6] * _matrix.data[4] * _matrix.data[2]) + (_matrix.data[7] * _matrix.data[5] * _matrix.data[0]) + (_matrix.data[8] * _matrix.data[3] * _matrix.data[1]);

				_outDeterminant = a - b;

				return GReturn::SUCCESS;
			}

			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[2];
				_outMatrix.data[2] = _matrix.data[1];
				_outMatrix.data[3] = _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[3];
				_outMatrix.data[2] = _matrix.data[6];
				_outMatrix.data[3] = _matrix.data[1];
				_outMatrix.data[4] = _matrix.data[4];
				_outMatrix.data[5] = _matrix.data[7];
				_outMatrix.data[6] = _matrix.data[2];
				_outMatrix.data[7] = _matrix.data[5];
				_outMatrix.data[8] = _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				float determinant;

				Determinant2F(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_F(determinant, 0.0f))
				{
					return GReturn::FAILURE;
				}

				_outMatrix.data[0] = _matrix.data[3];
				_outMatrix.data[1] = -_matrix.data[1];
				_outMatrix.data[2] = -_matrix.data[2];
				_outMatrix.data[3] = _matrix.data[0];

				MultiplyNum2F(_outMatrix, 1.0f / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				float determinant;

				Determinant3F(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_F(determinant, 0.0f))
				{
					return GReturn::FAILURE;
				}

				// simultaneously calculate the matrix of minors, convert it to the matrix of cofactors, and then transpose it
				_outMatrix.data[0] = (_matrix.data[4] * _matrix.data[8] - _matrix.data[5] * _matrix.data[7]); // 0
				_outMatrix.data[1] = -(_matrix.data[1] * _matrix.data[8] - _matrix.data[2] * _matrix.data[7]); // 3
				_outMatrix.data[2] = (_matrix.data[1] * _matrix.data[5] - _matrix.data[2] * _matrix.data[4]); // 6

				_outMatrix.data[3] = -(_matrix.data[3] * _matrix.data[8] - _matrix.data[5] * _matrix.data[6]); // 1
				_outMatrix.data[4] = (_matrix.data[0] * _matrix.data[8] - _matrix.data[2] * _matrix.data[6]); // 4
				_outMatrix.data[5] = -(_matrix.data[0] * _matrix.data[5] - _matrix.data[2] * _matrix.data[3]); // 7

				_outMatrix.data[6] = (_matrix.data[3] * _matrix.data[7] - _matrix.data[4] * _matrix.data[6]); // 2
				_outMatrix.data[7] = -(_matrix.data[0] * _matrix.data[7] - _matrix.data[1] * _matrix.data[6]); // 5
				_outMatrix.data[8] = (_matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3]); // 8

				MultiplyNum3F(_outMatrix, 1.0f / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0f ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outRadians = G2D_PI_F / 2.0f - (_matrix.data[3] > 0.0f ? acos(-_matrix.data[3] / s) : -acos(_matrix.data[3] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0f ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outRadians = G2D_PI_F / 2.0f - (_matrix.data[4] > 0.0f ? acos(-_matrix.data[4] / s) : -acos(_matrix.data[4] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _matrix.row3.x;
				_outVector.y = _matrix.row3.y;

				return GReturn::SUCCESS;
			}

			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale)
			{
				float delta = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale)
			{
				float delta = _matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atanf((_matrix.data[0] * _matrix.data[1] + _matrix.data[2] * _matrix.data[3]) / r), 0.0f };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = _matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3];
					_outSkew = { 0.0f, atanf((_matrix.data[0] * _matrix.data[2] + _matrix.data[1] * _matrix.data[3]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atanf((_matrix.data[0] * _matrix.data[1] + _matrix.data[3] * _matrix.data[4]) / r), 0.0f };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = _matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4];
					_outSkew = { 0.0f, atanf((_matrix.data[0] * _matrix.data[3] + _matrix.data[1] * _matrix.data[4]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX2F rotationMatrix = MATH2D::GIdentityMatrix2F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[2] = -s;
				rotationMatrix.data[3] = c;

				Multiply2F(_matrix, rotationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX3F rotationMatrix = MATH2D::GIdentityMatrix3F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				// store translation
				MATH2D::GVECTOR3F translation = _matrix.row3;

				Multiply3F(_matrix, rotationMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX3F rotationMatrix = MATH2D::GIdentityMatrix3F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				Multiply3F(rotationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F translationMatrix = MATH2D::GIdentityMatrix3F;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3F(_matrix, translationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F translationMatrix = MATH2D::GIdentityMatrix3F;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3F(translationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix)
			{
				MATH2D::GMATRIX2F scaleMatrix = MATH2D::GIdentityMatrix2F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[3] = _vector.y;

				Multiply2F(_matrix, scaleMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F scaleMatrix = MATH2D::GIdentityMatrix3F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				// store translation
				MATH2D::GVECTOR3F translation = _matrix.row3;

				Multiply3F(_matrix, scaleMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F scaleMatrix = MATH2D::GIdentityMatrix3F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				Multiply3F(scaleMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				MATH2D::GMATRIX2F inverseMatrix2;
				Inverse2F(_matrix2, inverseMatrix2);

				Multiply2F(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F inverseMatrix2;
				Inverse3F(_matrix2, inverseMatrix2);

				Multiply3F(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				Multiply2F(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				Multiply3F(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = static_cast<double>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = static_cast<double>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}











			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[2];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[3];

				_outMatrix.data[2] = _matrix1.data[2] * _matrix2.data[0] + _matrix1.data[3] * _matrix2.data[2];
				_outMatrix.data[3] = _matrix1.data[2] * _matrix2.data[1] + _matrix1.data[3] * _matrix2.data[3];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[3] + _matrix1.data[2] * _matrix2.data[6];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[4] + _matrix1.data[2] * _matrix2.data[7];
				_outMatrix.data[2] = _matrix1.data[0] * _matrix2.data[2] + _matrix1.data[1] * _matrix2.data[5] + _matrix1.data[2] * _matrix2.data[8];

				_outMatrix.data[3] = _matrix1.data[3] * _matrix2.data[0] + _matrix1.data[4] * _matrix2.data[3] + _matrix1.data[5] * _matrix2.data[6];
				_outMatrix.data[4] = _matrix1.data[3] * _matrix2.data[1] + _matrix1.data[4] * _matrix2.data[4] + _matrix1.data[5] * _matrix2.data[7];
				_outMatrix.data[5] = _matrix1.data[3] * _matrix2.data[2] + _matrix1.data[4] * _matrix2.data[5] + _matrix1.data[5] * _matrix2.data[8];

				_outMatrix.data[6] = _matrix1.data[6] * _matrix2.data[0] + _matrix1.data[7] * _matrix2.data[3] + _matrix1.data[8] * _matrix2.data[6];
				_outMatrix.data[7] = _matrix1.data[6] * _matrix2.data[1] + _matrix1.data[7] * _matrix2.data[4] + _matrix1.data[8] * _matrix2.data[7];
				_outMatrix.data[8] = _matrix1.data[6] * _matrix2.data[2] + _matrix1.data[7] * _matrix2.data[5] + _matrix1.data[8] * _matrix2.data[8];

				return GW::GReturn::SUCCESS;
			}

			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[2];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[3] + _vector.data[2] * _matrix.data[6];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[4] + _vector.data[2] * _matrix.data[7];
				_outVector.z = _vector.data[0] * _matrix.data[2] + _vector.data[1] * _matrix.data[5] + _vector.data[2] * _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant)
			{
				_outDeterminant = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant)
			{
				double a = (_matrix.data[0] * _matrix.data[4] * _matrix.data[8]) + (_matrix.data[1] * _matrix.data[5] * _matrix.data[6]) + (_matrix.data[2] * _matrix.data[3] * _matrix.data[7]);
				double b = (_matrix.data[6] * _matrix.data[4] * _matrix.data[2]) + (_matrix.data[7] * _matrix.data[5] * _matrix.data[0]) + (_matrix.data[8] * _matrix.data[3] * _matrix.data[1]);

				_outDeterminant = a - b;

				return GReturn::SUCCESS;
			}

			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[2];
				_outMatrix.data[2] = _matrix.data[1];
				_outMatrix.data[3] = _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[3];
				_outMatrix.data[2] = _matrix.data[6];
				_outMatrix.data[3] = _matrix.data[1];
				_outMatrix.data[4] = _matrix.data[4];
				_outMatrix.data[5] = _matrix.data[7];
				_outMatrix.data[6] = _matrix.data[2];
				_outMatrix.data[7] = _matrix.data[5];
				_outMatrix.data[8] = _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				double determinant;

				Determinant2D(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_D(determinant, 0.0))
				{
					return GReturn::FAILURE;
				}

				_outMatrix.data[0] = _matrix.data[3];
				_outMatrix.data[1] = -_matrix.data[1];
				_outMatrix.data[2] = -_matrix.data[2];
				_outMatrix.data[3] = _matrix.data[0];

				MultiplyNum2D(_outMatrix, 1.0 / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				double determinant;

				Determinant3D(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_D(determinant, 0.0))
				{
					return GReturn::FAILURE;
				}

				// simultaneously calculate the matrix of minors, convert it to the matrix of cofactors, and then transpose it
				_outMatrix.data[0] = (_matrix.data[4] * _matrix.data[8] - _matrix.data[5] * _matrix.data[7]); // 0
				_outMatrix.data[1] = -(_matrix.data[1] * _matrix.data[8] - _matrix.data[2] * _matrix.data[7]); // 3
				_outMatrix.data[2] = (_matrix.data[1] * _matrix.data[5] - _matrix.data[2] * _matrix.data[4]); // 6

				_outMatrix.data[3] = -(_matrix.data[3] * _matrix.data[8] - _matrix.data[5] * _matrix.data[6]); // 1
				_outMatrix.data[4] = (_matrix.data[0] * _matrix.data[8] - _matrix.data[2] * _matrix.data[6]); // 4
				_outMatrix.data[5] = -(_matrix.data[0] * _matrix.data[5] - _matrix.data[2] * _matrix.data[3]); // 7

				_outMatrix.data[6] = (_matrix.data[3] * _matrix.data[7] - _matrix.data[4] * _matrix.data[6]); // 2
				_outMatrix.data[7] = -(_matrix.data[0] * _matrix.data[7] - _matrix.data[1] * _matrix.data[6]); // 5
				_outMatrix.data[8] = (_matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3]); // 8

				MultiplyNum3D(_outMatrix, 1.0 / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0 ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outRadians = G2D_PI / 2.0 - (_matrix.data[3] > 0.0 ? acos(-_matrix.data[3] / s) : -acos(_matrix.data[3] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0 ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outRadians = G2D_PI / 2.0 - (_matrix.data[4] > 0.0 ? acos(-_matrix.data[4] / s) : -acos(_matrix.data[4] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _matrix.row3.x;
				_outVector.y = _matrix.row3.y;

				return GReturn::SUCCESS;
			}

			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale)
			{
				double delta = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale)
			{
				double delta = _matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atan((_matrix.data[0] * _matrix.data[1] + _matrix.data[2] * _matrix.data[3]) / r), 0.0 };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = _matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3];
					_outSkew = { 0.0, atan((_matrix.data[0] * _matrix.data[2] + _matrix.data[1] * _matrix.data[3]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atan((_matrix.data[0] * _matrix.data[1] + _matrix.data[3] * _matrix.data[4]) / r), 0.0 };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = _matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4];
					_outSkew = { 0.0, atan((_matrix.data[0] * _matrix.data[3] + _matrix.data[1] * _matrix.data[4]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX2D rotationMatrix = MATH2D::GIdentityMatrix2D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[2] = -s;
				rotationMatrix.data[3] = c;

				Multiply2D(_matrix, rotationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX3D rotationMatrix = MATH2D::GIdentityMatrix3D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				// store translation
				MATH2D::GVECTOR3D translation = _matrix.row3;

				Multiply3D(_matrix, rotationMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX3D rotationMatrix = MATH2D::GIdentityMatrix3D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				Multiply3D(rotationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D translationMatrix = MATH2D::GIdentityMatrix3D;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3D(_matrix, translationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D translationMatrix = MATH2D::GIdentityMatrix3D;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3D(translationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix)
			{
				MATH2D::GMATRIX2D scaleMatrix = MATH2D::GIdentityMatrix2D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[3] = _vector.y;

				Multiply2D(_matrix, scaleMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D scaleMatrix = MATH2D::GIdentityMatrix3D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				// store translation
				MATH2D::GVECTOR3D translation = _matrix.row3;

				Multiply3D(_matrix, scaleMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D scaleMatrix = MATH2D::GIdentityMatrix3D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				Multiply3D(scaleMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				MATH2D::GMATRIX2D inverseMatrix2;
				Inverse2D(_matrix2, inverseMatrix2);

				Multiply2D(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D inverseMatrix2;
				Inverse3D(_matrix2, inverseMatrix2);

				Multiply3D(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				Multiply2D(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				Multiply3D(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = static_cast<float>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = static_cast<float>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH2D
	{
		class GMatrix2D final : public I::GProxy<I::GMatrix2DInterface, I::GMatrix2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMatrix2D)
			// floats
			GATEWARE_STATIC_FUNCTION(Add2F)
			GATEWARE_STATIC_FUNCTION(Add3F)
			GATEWARE_STATIC_FUNCTION(Subtract2F)
			GATEWARE_STATIC_FUNCTION(Subtract3F)
			GATEWARE_STATIC_FUNCTION(Multiply2F)
			GATEWARE_STATIC_FUNCTION(Multiply3F)
			GATEWARE_STATIC_FUNCTION(MatrixXVector2F)
			GATEWARE_STATIC_FUNCTION(MatrixXVector3F)
			GATEWARE_STATIC_FUNCTION(MultiplyNum2F)
			GATEWARE_STATIC_FUNCTION(MultiplyNum3F)
			GATEWARE_STATIC_FUNCTION(Determinant2F)
			GATEWARE_STATIC_FUNCTION(Determinant3F)
			GATEWARE_STATIC_FUNCTION(Transpose2F)
			GATEWARE_STATIC_FUNCTION(Transpose3F)
			GATEWARE_STATIC_FUNCTION(Inverse2F)
			GATEWARE_STATIC_FUNCTION(Inverse3F)
			GATEWARE_STATIC_FUNCTION(GetRotation2F)
			GATEWARE_STATIC_FUNCTION(GetRotation3F)
			GATEWARE_STATIC_FUNCTION(GetTranslation3F)
			GATEWARE_STATIC_FUNCTION(GetScale2F)
			GATEWARE_STATIC_FUNCTION(GetScale3F)
			GATEWARE_STATIC_FUNCTION(GetSkew2F)
			GATEWARE_STATIC_FUNCTION(GetSkew3F)
			GATEWARE_STATIC_FUNCTION(Rotate2F)
			GATEWARE_STATIC_FUNCTION(RotateGlobal3F)
			GATEWARE_STATIC_FUNCTION(RotateLocal3F)
			GATEWARE_STATIC_FUNCTION(TranslateGlobal3F)
			GATEWARE_STATIC_FUNCTION(TranslateLocal3F)
			GATEWARE_STATIC_FUNCTION(Scale2F)
			GATEWARE_STATIC_FUNCTION(ScaleGlobal3F)
			GATEWARE_STATIC_FUNCTION(ScaleLocal3F)
			GATEWARE_STATIC_FUNCTION(Lerp2F)
			GATEWARE_STATIC_FUNCTION(Lerp3F)
			GATEWARE_STATIC_FUNCTION(MakeRelative2F)
			GATEWARE_STATIC_FUNCTION(MakeRelative3F)
			GATEWARE_STATIC_FUNCTION(MakeSeparate2F)
			GATEWARE_STATIC_FUNCTION(MakeSeparate3F)
			GATEWARE_STATIC_FUNCTION(Upgrade2)
			GATEWARE_STATIC_FUNCTION(Upgrade3)


			// doubles
			GATEWARE_STATIC_FUNCTION(Add2D)
			GATEWARE_STATIC_FUNCTION(Add3D)
			GATEWARE_STATIC_FUNCTION(Subtract2D)
			GATEWARE_STATIC_FUNCTION(Subtract3D)
			GATEWARE_STATIC_FUNCTION(Multiply2D)
			GATEWARE_STATIC_FUNCTION(Multiply3D)
			GATEWARE_STATIC_FUNCTION(MatrixXVector2D)
			GATEWARE_STATIC_FUNCTION(MatrixXVector3D)
			GATEWARE_STATIC_FUNCTION(MultiplyNum2D)
			GATEWARE_STATIC_FUNCTION(MultiplyNum3D)
			GATEWARE_STATIC_FUNCTION(Determinant2D)
			GATEWARE_STATIC_FUNCTION(Determinant3D)
			GATEWARE_STATIC_FUNCTION(Transpose2D)
			GATEWARE_STATIC_FUNCTION(Transpose3D)
			GATEWARE_STATIC_FUNCTION(Inverse2D)
			GATEWARE_STATIC_FUNCTION(Inverse3D)
			GATEWARE_STATIC_FUNCTION(GetRotation2D)
			GATEWARE_STATIC_FUNCTION(GetRotation3D)
			GATEWARE_STATIC_FUNCTION(GetTranslation3D)
			GATEWARE_STATIC_FUNCTION(GetScale2D)
			GATEWARE_STATIC_FUNCTION(GetScale3D)
			GATEWARE_STATIC_FUNCTION(GetSkew2D)
			GATEWARE_STATIC_FUNCTION(GetSkew3D)
			GATEWARE_STATIC_FUNCTION(Rotate2D)
			GATEWARE_STATIC_FUNCTION(RotateGlobal3D)
			GATEWARE_STATIC_FUNCTION(RotateLocal3D)
			GATEWARE_STATIC_FUNCTION(TranslateGlobal3D)
			GATEWARE_STATIC_FUNCTION(TranslateLocal3D)
			GATEWARE_STATIC_FUNCTION(Scale2D)
			GATEWARE_STATIC_FUNCTION(ScaleGlobal3D)
			GATEWARE_STATIC_FUNCTION(ScaleLocal3D)
			GATEWARE_STATIC_FUNCTION(Lerp2D)
			GATEWARE_STATIC_FUNCTION(Lerp3D)
			GATEWARE_STATIC_FUNCTION(MakeRelative2D)
			GATEWARE_STATIC_FUNCTION(MakeRelative3D)
			GATEWARE_STATIC_FUNCTION(MakeSeparate2D)
			GATEWARE_STATIC_FUNCTION(MakeSeparate3D)
			GATEWARE_STATIC_FUNCTION(Downgrade2)
			GATEWARE_STATIC_FUNCTION(Downgrade3)


			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // #endif GMATRIX_H

/*---------------------------------
|	End of GMatrix2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GVector2D.h
----------------------------------*/
#ifndef GVECTOR2D_H
#define GVECTOR2D_H





namespace GW
{
	namespace I
	{
		class GVector2DInterface : public virtual GInterfaceInterface
		{
		public:
			// floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _vector1, MATH2D::GLINE2F _vector2, float& _outRadians){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			// doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _vector1, MATH2D::GLINE2D _vector2, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implemention for GVector2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GVECTOR2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GVECTOR2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GVector2DImplementation : public virtual GVector2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
			// Floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			// Doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GVector2DImplementation : public virtual GVector2DInterface, private GInterfaceImplementation
		{
		public:

			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;

				return GReturn::SUCCESS;
			}

			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;

				return GReturn::SUCCESS;
			}

			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y);

				return GReturn::SUCCESS;
			}

			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z);

				return GReturn::SUCCESS;
			}

			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}

			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector1.y * _vector2.z) - (_vector1.z * _vector2.y);
				_outVector.y = (_vector1.z * _vector2.x) - (_vector1.x * _vector2.z);
				_outVector.z = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}

			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y);

				return GReturn::SUCCESS;
			}

			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x) + (_vector.z * _matrix.row3.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y) + (_vector.z * _matrix.row3.y);
				_outVector.z = (_vector.x * _matrix.row1.z) + (_vector.y * _matrix.row2.z) + (_vector.z * _matrix.row3.z);

				return GReturn::SUCCESS;
			}

			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				VectorXMatrix2F(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector)
			{
				VectorXMatrix3F(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y));
				if (G2D_COMPARISON_STANDARD_F(_outMagnitude, 0.0f))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z));
				if (G2D_COMPARISON_STANDARD_F(_outMagnitude, 0.0f))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector)
			{
				float magnitude;
				if (-Magnitude2F(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector)
			{
				float magnitude;
				if (-Magnitude3F(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue)
			{
				_outValue = G2D_LERP(_value1, _value2, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G2D_LERP(_vector1.z, _vector2.z, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue)
			{
				_outValue = (_value1 * _barycentric.alpha) + (_value2 * _barycentric.beta) + (_value3 * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);
				_outVector.z = (_vector1.z * _barycentric.alpha) + (_vector2.z * _barycentric.beta) + (_vector3.z * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector)
			{
				MATH2D::GVECTOR2F p0 = _vector1;
				MATH2D::GVECTOR2F p1 = _vector2;
				MATH2D::GVECTOR2F p2 = _vector3;
				MATH2D::GVECTOR2F p3 = _vector4;

				float t0 = 0.0f;
				float t1 = pow(sqrt(pow((p1.x - p0.x), 2.0f) + pow((p1.y - p0.y), 2.0f)), 0.5f) + t0;
				float t2 = pow(sqrt(pow((p2.x - p1.x), 2.0f) + pow((p2.y - p1.y), 2.0f)), 0.5f) + t1;
				float t3 = pow(sqrt(pow((p3.x - p2.x), 2.0f) + pow((p3.y - p2.y), 2.0f)), 0.5f) + t2;

				MATH2D::GVECTOR2F A1;
				MATH2D::GVECTOR2F A2;
				MATH2D::GVECTOR2F A3;
				MATH2D::GVECTOR2F B1;
				MATH2D::GVECTOR2F B2;

				float t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 2; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}

				return GReturn::SUCCESS;
			}

			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _line.start.y - _line.end.y;
				_outVector.y = _line.end.x - _line.start.x;

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians)
			{
				float dot;
				Dot2F(_vector1, _vector2, dot);

				float magnitude1;
				float magnitude2;
				if (-(Magnitude2F(_vector1, magnitude1)) || -(Magnitude2F(_vector2, magnitude2)))
					return GReturn::FAILURE;

				_outRadians = acos(G2D_ABS(dot) / (magnitude1 * magnitude2));

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, float& _outRadians)
			{
				// get vectors parallel to the lines. represented as single points because we assume the vector starts at the origin
				GW::MATH2D::GVECTOR2F u;
				GW::MATH2D::GVECTOR2F v;

				u.x = _line1.end.x - _line1.start.x;
				u.y = _line1.end.y - _line1.start.y;

				v.x = _line2.end.x - _line2.start.x;
				v.y = _line2.end.y - _line2.start.y;

				// now that we have the 2 vectors parallel to the 2 lines, we can perform the actual calculation
				if (-AngleBetweenVectorsF(u, v, _outRadians))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = static_cast<double>(_vector.x);
				_outVector.y = static_cast<double>(_vector.y);

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = static_cast<double>(_vector.x);
				_outVector.y = static_cast<double>(_vector.y);
				_outVector.z = static_cast<double>(_vector.z);

				return GReturn::SUCCESS;
			}



			// Doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;

				return GReturn::SUCCESS;
			};

			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;

				return GReturn::SUCCESS;
			};

			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;

				return GReturn::SUCCESS;
			};

			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y);

				return GReturn::SUCCESS;
			};

			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z);

				return GReturn::SUCCESS;
			};

			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			};

			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector1.y * _vector2.z) - (_vector1.z * _vector2.y);
				_outVector.y = (_vector1.z * _vector2.x) - (_vector1.x * _vector2.z);
				_outVector.z = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			};

			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y);

				return GReturn::SUCCESS;
			};

			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x) + (_vector.z * _matrix.row3.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y) + (_vector.z * _matrix.row3.y);
				_outVector.z = (_vector.x * _matrix.row1.z) + (_vector.y * _matrix.row2.z) + (_vector.z * _matrix.row3.z);

				return GReturn::SUCCESS;
			};

			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				VectorXMatrix2D(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector)
			{
				VectorXMatrix3D(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			};

			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y));
				if (G2D_COMPARISON_STANDARD_D(_outMagnitude, 0.0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z));
				if (G2D_COMPARISON_STANDARD_D(_outMagnitude, 0.0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector)
			{
				double magnitude;
				if (-Magnitude2D(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector)
			{
				double magnitude;
				if (-Magnitude3D(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue)
			{
				_outValue = G2D_LERP(_value1, _value2, _ratio);

				return GReturn::SUCCESS;
			};

			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G2D_LERP(_vector1.z, _vector2.z, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue)
			{
				_outValue = (_value1 * _barycentric.alpha) + (_value2 * _barycentric.beta) + (_value3 * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);
				_outVector.z = (_vector1.z * _barycentric.alpha) + (_vector2.z * _barycentric.beta) + (_vector3.z * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector)
			{
				MATH2D::GVECTOR2D p0 = _vector1;
				MATH2D::GVECTOR2D p1 = _vector2;
				MATH2D::GVECTOR2D p2 = _vector3;
				MATH2D::GVECTOR2D p3 = _vector4;

				double t0 = 0.0;
				double t1 = pow(sqrt(pow((p1.x - p0.x), 2) + pow((p1.y - p0.y), 2)), 0.5) + t0;
				double t2 = pow(sqrt(pow((p2.x - p1.x), 2) + pow((p2.y - p1.y), 2)), 0.5) + t1;
				double t3 = pow(sqrt(pow((p3.x - p2.x), 2) + pow((p3.y - p2.y), 2)), 0.5) + t2;

				MATH2D::GVECTOR2D A1;
				MATH2D::GVECTOR2D A2;
				MATH2D::GVECTOR2D A3;
				MATH2D::GVECTOR2D B1;
				MATH2D::GVECTOR2D B2;

				double t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 2; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}

				return GReturn::SUCCESS;
			}

			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _line.start.y - _line.end.y;
				_outVector.y = _line.end.x - _line.start.x;

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians)
			{
				double dot;
				Dot2D(_vector1, _vector2, dot);

				double magnitude1;
				double magnitude2;
				if (-(Magnitude2D(_vector1, magnitude1)) || -(Magnitude2D(_vector2, magnitude2)))
					return GReturn::FAILURE;

				_outRadians = acos(G2D_ABS(dot) / (magnitude1 * magnitude2));

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, double& _outRadians)
			{
				// get vectors parallel to the lines. represented as single points because we assume the vector starts at the origin
				GW::MATH2D::GVECTOR2D u;
				GW::MATH2D::GVECTOR2D v;

				u.x = _line1.end.x - _line1.start.x;
				u.y = _line1.end.y - _line1.start.y;

				v.x = _line2.end.x - _line2.start.x;
				v.y = _line2.end.y - _line2.start.y;

				// now that we have the 2 vectors parallel to the 2 lines, we can perform the actual calculation
				if (-AngleBetweenVectorsD(u, v, _outRadians))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = static_cast<float>(_vector.x);
				_outVector.y = static_cast<float>(_vector.y);

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = static_cast<float>(_vector.x);
				_outVector.y = static_cast<float>(_vector.y);
				_outVector.z = static_cast<float>(_vector.z);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH2D
	{
		class GVector2D final : public I::GProxy<I::GVector2DInterface, I::GVector2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVector2D)
			// Floats
			GATEWARE_STATIC_FUNCTION(Add2F)
			GATEWARE_STATIC_FUNCTION(Add3F)
			GATEWARE_STATIC_FUNCTION(Subtract2F)
			GATEWARE_STATIC_FUNCTION(Subtract3F)
			GATEWARE_STATIC_FUNCTION(Scale2F)
			GATEWARE_STATIC_FUNCTION(Scale3F)
			GATEWARE_STATIC_FUNCTION(Dot2F)
			GATEWARE_STATIC_FUNCTION(Dot3F)
			GATEWARE_STATIC_FUNCTION(Cross2F)
			GATEWARE_STATIC_FUNCTION(Cross3F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix2F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix3F)
			GATEWARE_STATIC_FUNCTION(Transform2F)
			GATEWARE_STATIC_FUNCTION(Transform3F)
			GATEWARE_STATIC_FUNCTION(Magnitude2F)
			GATEWARE_STATIC_FUNCTION(Magnitude3F)
			GATEWARE_STATIC_FUNCTION(Normalize2F)
			GATEWARE_STATIC_FUNCTION(Normalize3F)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(Lerp2F)
			GATEWARE_STATIC_FUNCTION(Lerp3F)
			GATEWARE_STATIC_FUNCTION(BerpF)
			GATEWARE_STATIC_FUNCTION(Berp2F)
			GATEWARE_STATIC_FUNCTION(Berp3F)
			GATEWARE_STATIC_FUNCTION(Spline2F)
			GATEWARE_STATIC_FUNCTION(GradientF)
			GATEWARE_STATIC_FUNCTION(AngleBetweenVectorsF)
			GATEWARE_STATIC_FUNCTION(AngleBetweenLinesF)
			GATEWARE_STATIC_FUNCTION(Upgrade2)
			GATEWARE_STATIC_FUNCTION(Upgrade3)




			// Doubles
			GATEWARE_STATIC_FUNCTION(Add2D)
			GATEWARE_STATIC_FUNCTION(Add3D)
			GATEWARE_STATIC_FUNCTION(Subtract2D)
			GATEWARE_STATIC_FUNCTION(Subtract3D)
			GATEWARE_STATIC_FUNCTION(Scale2D)
			GATEWARE_STATIC_FUNCTION(Scale3D)
			GATEWARE_STATIC_FUNCTION(Dot2D)
			GATEWARE_STATIC_FUNCTION(Dot3D)
			GATEWARE_STATIC_FUNCTION(Cross2D)
			GATEWARE_STATIC_FUNCTION(Cross3D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix2D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix3D)
			GATEWARE_STATIC_FUNCTION(Transform2D)
			GATEWARE_STATIC_FUNCTION(Transform3D)
			GATEWARE_STATIC_FUNCTION(Magnitude2D)
			GATEWARE_STATIC_FUNCTION(Magnitude3D)
			GATEWARE_STATIC_FUNCTION(Normalize2D)
			GATEWARE_STATIC_FUNCTION(Normalize3D)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(Lerp2D)
			GATEWARE_STATIC_FUNCTION(Lerp3D)
			GATEWARE_STATIC_FUNCTION(BerpD)
			GATEWARE_STATIC_FUNCTION(Berp2D)
			GATEWARE_STATIC_FUNCTION(Berp3D)
			GATEWARE_STATIC_FUNCTION(Spline2D)
			GATEWARE_STATIC_FUNCTION(GradientD)
			GATEWARE_STATIC_FUNCTION(AngleBetweenVectorsD)
			GATEWARE_STATIC_FUNCTION(AngleBetweenLinesD)
			GATEWARE_STATIC_FUNCTION(Downgrade2)
			GATEWARE_STATIC_FUNCTION(Downgrade3)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVECTOR2D_H

/*---------------------------------
|	End of GVector2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GBlitter.h
----------------------------------*/
#if GATEWARE_FEATURE_FLAG_IN_DEVELOPMENT

#ifndef GBLITTER_H
#define GBLITTER_H





namespace GW
{
	namespace I
	{
		class GBlitterInterface : public virtual GInterfaceInterface
		{
		public:
			enum DrawOptions
			{
				USE_TRANSFORMATIONS		= 0x001,
				USE_TRANSPARENCY		= 0x002,
				USE_BILINEAR_INTERP		= 0x004,
				USE_SOURCE_LAYERS		= 0x008,
				USE_SOURCE_STENCIL		= 0x010,
			};
			struct TileDefinition
			{
				unsigned short			source_id;
				unsigned short			x;
				unsigned short			y;
				unsigned short			w;
				unsigned short			h;
				unsigned char			pad[6];
			};
			struct DrawInstruction
			{
				unsigned int			tile_id;
				unsigned short			flags;
				unsigned char			layer;
				unsigned char			stencil;
				float					m[3][3];
			};

			virtual GReturn LoadSource(const char *_filepath, unsigned short &_outIndex) = 0;
			virtual GReturn ImportSource(const unsigned int* _pixels, const unsigned char* _layers,
				const unsigned char* _stencil, unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned short& _outIndex) = 0;
			virtual GReturn DefineTiles(const TileDefinition *_tileDefinitions,
				const unsigned short _numTiles, unsigned int *_outIndices) = 0;
			virtual GReturn DiscardSources(const unsigned short* _indices, unsigned short _numIndices) = 0;
			virtual GReturn DiscardTiles(const unsigned int* _indices, unsigned int _numIndices) = 0;
			virtual GReturn Draw(const DrawInstruction *_drawInstructions, const unsigned short _numDraws) = 0;
			virtual GReturn TransferResultToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned int *_outPixelBuffer) = 0;
			virtual GReturn TransferLayersToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned char *_outLayerBuffer) = 0;
			virtual GReturn TransferStencilToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned char *_outStencilBuffer) = 0;
			virtual GReturn Clear(unsigned int _clearColor, short _clearLayer, short _clearStencil) = 0;
		};
	};
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GBlitter.h 
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only) 
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed 
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace 
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members) 
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval) 

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible 
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file 
// When adding implementations please try to condense redundant file includes where possible. 
// This will reduce size/redundancy when the library is tool compressed into single header form. 
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GBLITTER) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GBLITTER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW {
	namespace I {

		class GBlitterImplementation : public virtual GBlitterInterface
		{
		public:
			GReturn Create(unsigned short _width, unsigned short _height) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn LoadSource(const char* _filepath, unsigned short& _outIndex) override { return GReturn::FAILURE; }
			GReturn ImportSource(const unsigned int* _pixels, const unsigned char* _layers,
				const unsigned char* _stencil, unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned short& _outIndex)
			{
				return GReturn::FAILURE;
			}
			GReturn DefineTiles(const TileDefinition* _tileDefinitions, const unsigned short _numTiles,
				unsigned int* _outIndices) override
			{
				return GReturn::FAILURE;
			}
			GReturn DiscardSources(const unsigned short* _indices, unsigned short _numIndices)
			{
				return GReturn::FAILURE;
			}
			GReturn DiscardTiles(const unsigned int* _indices, unsigned int _numIndices)
			{
				return GReturn::FAILURE;
			}
			GReturn Draw(const DrawInstruction* _drawInstructions, const unsigned short _numDraws) override { return GReturn::FAILURE; }
			GReturn TransferResultToBuffer(unsigned short _width, unsigned short _height, unsigned short _offset,
				unsigned short _stride, unsigned int* _outPixelBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn TransferLayersToBuffer(unsigned short _width, unsigned short _height, unsigned short _offset,
				unsigned short _stride, unsigned char* _outLayerBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn TransferStencilToBuffer(unsigned short _width, unsigned short _height, unsigned short _offset,
				unsigned short _stride, unsigned char* _outStencilBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn Clear(unsigned int _clearColor, short _clearLayer, short _clearStencil) override { return GReturn::FAILURE; }
		};

	} // end I namespace
} // end GW namespace
 
#else defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    

#include <vector>

#ifdef _WIN32
#ifdef _DEBUG
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
#endif

namespace GW {
	namespace I {

		class GBlitterImplementation : public virtual GBlitterInterface
		{

#pragma region DEFINES

			// maximum dimensions of a source
#define MAX_SOURCE_WIDTH 2048
#define MAX_SOURCE_HEIGHT 2048
#define MAX_SOURCE_SIZE (MAX_SOURCE_WIDTH * MAX_SOURCE_HEIGHT)

			// maximum number of sources
#define MAX_SOURCES (UINT16_MAX + 1)

			// dimensions of input blocks
#define INPUT_BLOCK_WIDTH 8 // TODO: set to final value (256) before merging to development
#define INPUT_BLOCK_HEIGHT INPUT_BLOCK_WIDTH
#define INPUT_BLOCK_SIZE (INPUT_BLOCK_WIDTH * INPUT_BLOCK_HEIGHT)

			// dimensions of output blocks
#define OUTPUT_BLOCK_WIDTH (INPUT_BLOCK_WIDTH >> 1)
#define OUTPUT_BLOCK_HEIGHT OUTPUT_BLOCK_WIDTH
#define OUTPUT_BLOCK_SIZE (OUTPUT_BLOCK_WIDTH * OUTPUT_BLOCK_HEIGHT)

			// maximum number of draw instructions allowed per draw call
#define MAX_DRAWS_PER_FRAME 1024

			typedef unsigned int pixel;
			typedef unsigned int color;
			typedef unsigned char colorChannel;
			typedef unsigned char layer;
			typedef unsigned char stencil;

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			struct TgaHeader
			{
				unsigned char	idLength;		//<! Byte length of ID field >
				unsigned char	colorMapType;	//<!  >
				unsigned char	imageType;		//<!  >
				unsigned char	colorMap[5];	//<!  >
				unsigned char	imageSpec[10];	//<!  >
			};

			struct DataBlock
			{
				unsigned short	x;			//<! Top-left x coordinate, in pixels >
				unsigned short	y;			//<! Top-left y coordinate, in pixels >
				unsigned short	rows;		//<! Number of rows of data within block in pixels (data height) >
				unsigned short	rowWidth;	//<! Width of rows of data within block, in pixels (data width) >
				void*			data;		//<! Index in an external data array (starting location of data within block) >
			};
			class SourceBuffer
			{
			public:
				unsigned short	image_w_pixels = 0;	//<! Width of data, in pixels >
				unsigned short	image_h_pixels = 0;	//<! Height of data, in pixels >
				unsigned int	image_s_pixels = 0;	//<! Total image_s_pixels of data, in pixels >
				pixel*			pixel_data = nullptr;	//<! Array of pixel data (arranged linearly) >
				layer*			layer_data = nullptr;	//<! Array of layer data (arranged linearly) >
				stencil*		stencil_data = nullptr;	//<! Array of stencil data (arranged linearly) >

				SourceBuffer(unsigned short _w, unsigned short _h)
				{
					// store image dimensions
					image_w_pixels = _w;
					image_h_pixels = _h;
					image_s_pixels = image_w_pixels * image_h_pixels;

					// create arrays to store data
					pixel_data = new pixel[image_s_pixels];
					layer_data = new layer[image_s_pixels];
					stencil_data = new stencil[image_s_pixels];

					// clear arrays
					ClearData();
				}
				~SourceBuffer()
				{
					if (pixel_data)
					{
						delete[] pixel_data;
						pixel_data = nullptr;
					}
					if (layer_data)
					{
						delete[] layer_data;
						layer_data = nullptr;
					}
					if (stencil_data)
					{
						delete[] stencil_data;
						stencil_data = nullptr;
					}
				}

				GReturn SetData(pixel* _pixels, layer* _layers, stencil* _stencil, unsigned int _numPixels)
				{
					if (_pixels)
						memcpy(pixel_data, _pixels, static_cast<size_t>(_numPixels) << 2);
					if (_layers)
						memcpy(layer_data, _layers, _numPixels);
					if (_stencil)
						memcpy(stencil_data, _stencil, _numPixels);
					return GReturn::SUCCESS;
				}
				GReturn ClearData()
				{
					memset(pixel_data, 0x00, static_cast<size_t>(image_s_pixels) << 2);
					memset(layer_data, 0x00, image_s_pixels);
					memset(stencil_data, 0x00, image_s_pixels);
					return GReturn::SUCCESS;
				}
			};
			class Source
			{
			public:
				const unsigned short	block_w_pixels = INPUT_BLOCK_WIDTH;		//<! Width of a data block, in pixels. >
				const unsigned short	block_h_pixels = INPUT_BLOCK_HEIGHT;	//<! Height of a data block, in pixels. >
				const unsigned short	block_s_pixels = INPUT_BLOCK_SIZE;		//<! Total size of a data block, in pixels. >
				unsigned short			image_w_pixels = 0;						//<! Width of data, in pixels >
				unsigned short			image_h_pixels = 0;						//<! Height of data, in pixels >
				unsigned int			image_s_pixels = 0;						//<! Total size of data, in pixels >
				unsigned short			data_w_blocks = 0;						//<! Width of data, in blocks >
				unsigned short			data_h_blocks = 0;						//<! Height of data, in blocks >
				unsigned short			data_s_blocks = 0;						//<! Total size of data, in blocks >
				unsigned short			data_w_pixels = 0;						//<! Width of data, in pixels >
				unsigned short			data_h_pixels = 0;						//<! Height of data, in pixels >
				unsigned int			data_s_pixels = 0;						//<! Total size of data, in pixels >
				pixel*					pixel_data = nullptr;					//<! Array of pixel data (arranged in block-order) >
				DataBlock*				pixel_blocks = nullptr;					//<! Arrray of pixel blocks (arranged linearly) >
				layer*					layer_data = nullptr;					//<! Array of layer data (arranged in block-order) >
				DataBlock*				layer_blocks = nullptr;					//<! Arrray of layer blocks (arranged linearly) >
				stencil*				stencil_data = nullptr;					//<! Array of stencil data (arranged in block-order) >
				DataBlock*				stencil_blocks = nullptr;				//<! Arrray of stencil blocks (arranged linearly) >

				Source(unsigned short _w, unsigned short _h)
				{
					// store image dimensions
					image_w_pixels = _w;
					image_h_pixels = _h;
					image_s_pixels = image_w_pixels * image_h_pixels;

					// calculate dimensions in blocks needed to store data
					data_w_blocks = image_w_pixels / block_w_pixels + ((image_w_pixels % block_w_pixels) ? 1 : 0);
					data_h_blocks = image_h_pixels / block_h_pixels + ((image_h_pixels % block_h_pixels) ? 1 : 0);
					data_s_blocks = data_w_blocks * data_h_blocks;

					// calculate dimensions in pixels
					image_w_pixels = data_w_blocks * block_w_pixels;
					image_h_pixels = data_h_blocks * block_h_pixels;
					image_s_pixels = image_w_pixels * image_h_pixels;

					// create arrays to store data
					pixel_data = new pixel[data_s_pixels];
					layer_data = new layer[data_s_pixels];
					stencil_data = new stencil[data_s_pixels];

					// clear arrays
					ClearData();

					// create data block arrays to access data with
					pixel_blocks = new DataBlock[data_s_blocks];
					layer_blocks = new DataBlock[data_s_blocks];
					stencil_blocks = new DataBlock[data_s_blocks];

					// initialize data block arrays
					unsigned short block_x, block_y;
					for (unsigned short b = 0; b < data_s_blocks; ++b)
					{
						DataBlock& pixelBlock = pixel_blocks[b];
						DataBlock& layerBlock = layer_blocks[b];
						DataBlock& stencilBlock = stencil_blocks[b];

						// convert block index into block grid x/y coordinate
						block_y = b / data_w_blocks;
						block_x = b - block_y; //block_x = b % data_w_blocks;

						// store block origins
						unsigned short x = block_x * block_w_pixels;
						unsigned short y = block_y * block_h_pixels;
						pixelBlock.x = x;
						pixelBlock.y = y;
						layerBlock.x = x;
						layerBlock.y = y;
						stencilBlock.x = x;
						stencilBlock.y = y;

						// store block dimensions
						// if next block's vertical origin would fall outside the image, height is the height of the partial section, else height is block's height
						unsigned short rows = (((block_x + 1) * block_w_pixels) > image_w_pixels)
							? image_w_pixels - ((image_w_pixels / block_w_pixels) * block_w_pixels)
							: block_w_pixels;
						// if next block's horizontal origin would fall outside the image, width is the width of the partial section, else width is block's width
						unsigned short rowWidth = (((block_y + 1) * block_h_pixels) > image_h_pixels)
							? image_h_pixels - ((image_h_pixels / block_h_pixels) * block_h_pixels)
							: block_h_pixels;
						pixelBlock.rows = rows;
						pixelBlock.rowWidth = rowWidth;
						layerBlock.rows = rows;
						layerBlock.rowWidth = rowWidth;
						stencilBlock.rows = rows;
						stencilBlock.rowWidth = rowWidth;

						// store block data locations
						unsigned int index = b * block_s_pixels;
						pixelBlock.data = &pixel_data[index];
						layerBlock.data = &layer_data[index];
						stencilBlock.data = &stencil_data[index];
					}
				}
				~Source()
				{
					if (pixel_data)
					{
						delete[] pixel_data;
						pixel_data = nullptr;
					}
					if (pixel_blocks)
					{
						delete[] pixel_blocks;
						pixel_blocks = nullptr;
					}
					if (layer_data)
					{
						delete[] layer_data;
						layer_data = nullptr;
					}
					if (layer_blocks)
					{
						delete[] layer_blocks;
						layer_blocks = nullptr;
					}
					if (stencil_data)
					{
						delete[] stencil_data;
						stencil_data = nullptr;
					}
					if (stencil_blocks)
					{
						delete[] stencil_blocks;
						stencil_blocks = nullptr;
					}
				}

				GReturn SetData(pixel* _pixels, layer* _layers, stencil* _stencil, unsigned int _numPixels)
				{
					for (unsigned int b = 0; b < data_s_blocks; ++b) // iterate through blocks
					{
						DataBlock& pixelBlock = pixel_blocks[b];
						DataBlock& layerBlock = layer_blocks[b];
						DataBlock& stencilBlock = stencil_blocks[b];

						unsigned int p; // index of pixel within block
						unsigned int by; // y index of block relative to data origin
						unsigned int py; // y index of pixel relative to block origin
						unsigned int index; // index in source pixel array to copy from

						by = b / data_w_blocks;
						for (unsigned int row = 0; row < pixelBlock.rows; ++row) // if layer and stencil blocks have different sizes than pixel blocks, something went wrong
						{
							// calculate values
							p = row / block_w_pixels;
							py = p * block_w_pixels; // not necessarily equal to row due to integer math
							index =
								(by * image_w_pixels * block_h_pixels) // vertical offset of block from origin
								+ ((b - (by * data_w_blocks)) * block_w_pixels) // horizontal offset of block from origin
								+ (py * image_w_pixels) // vertical offset of pixel from block origin
								+ (p - (py * block_w_pixels)); // horizontal offset of pixel from block origin
							// copy data to blocks
							if (_pixels)
								memcpy(&((unsigned int*)pixelBlock.data)[p], &_pixels[index], static_cast<size_t>(pixelBlock.rowWidth) << 2);
							if (_layers)
								memcpy(&((unsigned int*)layerBlock.data)[p], &_layers[index], layerBlock.rowWidth);
							if (_stencil)
								memcpy(&((unsigned int*)stencilBlock.data)[p], &_stencil[index], stencilBlock.rowWidth);
						}
					}
					return GReturn::SUCCESS;
				}
				GReturn ClearData()
				{
					memset(pixel_data, 0x00, static_cast<size_t>(data_s_pixels) << 2);
					memset(layer_data, 0x00, data_s_pixels);
					memset(stencil_data, 0x00, data_s_pixels);
					return GReturn::SUCCESS;
				}
			};
			class Result : public Source
			{
			public:
				const unsigned short	block_w_pixels = OUTPUT_BLOCK_WIDTH;
				const unsigned short	block_h_pixels = OUTPUT_BLOCK_HEIGHT;
				const unsigned short	block_s_pixels = OUTPUT_BLOCK_SIZE;

			//	Result(unsigned short _w, unsigned short _h) : Source(_w, _h) {}
			};
			class Tile
			{
			public:
				unsigned int	source_id;	//<! Index of source that tile is defined in >
				unsigned short	x;			//<! Top-left x, in pixels >
				unsigned short	y;			//<! Top-left y, in pixels >
				unsigned short	w;			//<! Width, in pixels >
				unsigned short	h;			//<! Height, in pixels >
			};
			struct InOutInstruction
			{
				unsigned short	source_id;		//<! Index of source that instruction refers to >
				unsigned short	input_block_id;	//<! Index of data block in source >
				unsigned short	x;				//<! Top-left x of data region within source, in pixels >
				unsigned short	y;				//<! Top-left y of data region within source, in pixels >
				unsigned short	w;				//<! Width of data region within source, in pixels >
				unsigned short	h;				//<! Height of data region within source, in pixels >
				unsigned short	flags;			//<! Bitflags indicating options to apply during drawing >
				unsigned char	layer;			//<! Layer to draw to, if not using source layer values >
				unsigned char	stencil;		//<! Stencil value to apply, if not using source stencil values >
				float			m[3][3];		//<! Transform matrix >
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware variables are named as:		gVariableName

			Result*								m_result = nullptr;
			std::vector<Source>					m_sources;
			std::vector<Tile>					m_tiles;
			std::vector<DrawInstruction>		m_drawInstructions;
			std::vector<InOutInstruction>		m_inputInstructions;
			std::vector<InOutInstruction>		m_outputInstructions;

#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS



#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GBlitterImplementation()
			{
				if (m_result)
					delete m_result;
			}

			GReturn Create(unsigned short _width, unsigned short _height)
			{
				return GReturn::FAILURE;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS

			GReturn LoadSource(const char *_filepath, unsigned short &_outIndex) override
			{
				return GReturn::FAILURE;
			}
			GReturn ImportSource(const unsigned int* _pixels, const unsigned char* _layers,
				const unsigned char* _stencil, unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned short& _outIndex)
			{
				return GReturn::FAILURE;
			}
			GReturn DefineTiles(const TileDefinition *_tileDefinitions,
				const unsigned short _numTiles, unsigned int *_outIndices) override
			{
				return GReturn::FAILURE;
			}
			GReturn DiscardSources(const unsigned short* _indices, unsigned short _numIndices)
			{
				return GReturn::FAILURE;
			}
			GReturn DiscardTiles(const unsigned int* _indices, unsigned int _numIndices)
			{
				return GReturn::FAILURE;
			}
			GReturn Draw(const DrawInstruction *_drawInstructions,
				const unsigned short _numDraws) override
			{
				return GReturn::FAILURE;
			}
			GReturn TransferResultToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned int *_outPixelBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn TransferLayersToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned char *_outLayerBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn TransferStencilToBuffer(unsigned short _width, unsigned short _height,
				unsigned short _offset, unsigned short _stride, unsigned char *_outStencilBuffer) override
			{
				return GReturn::FAILURE;
			}
			GReturn Clear(unsigned int _clearColor, short _clearLayer, short _clearStencil) override
			{
				return GReturn::FAILURE;
			}

#pragma region UNDEFINES

		private:
#undef MAX_SOURCE_WIDTH
#undef MAX_SOURCE_HEIGHT
#undef MAX_SOURCE_SIZE

#undef MAX_SOURCES

#undef INPUT_BLOCK_WIDTH
#undef INPUT_BLOCK_HEIGHT
#undef INPUT_BLOCK_SIZE

#undef OUTPUT_BLOCK_WIDTH
#undef OUTPUT_BLOCK_HEIGHT
#undef OUTPUT_BLOCK_SIZE

#undef MAX_DRAWS_PER_FRAME

#pragma endregion UNDEFINES

		};
	}
}

#ifdef _WIN32
#ifdef _DEBUG
#undef new
#endif // _DEBUG
#endif // _WIN32

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GBlitter final : public I::GProxy<I::GBlitterInterface, I::GBlitterImplementation, unsigned short, unsigned short>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GBlitter)
			GATEWARE_TYPEDEF(DrawOptions)
			GATEWARE_TYPEDEF(TileDefinition)
			GATEWARE_TYPEDEF(DrawInstruction)
			GATEWARE_FUNCTION(LoadSource)
			GATEWARE_FUNCTION(ImportSource)
			GATEWARE_FUNCTION(DefineTiles)
			GATEWARE_FUNCTION(DiscardSources)
			GATEWARE_FUNCTION(DiscardTiles)
			GATEWARE_FUNCTION(Draw)
			GATEWARE_FUNCTION(TransferResultToBuffer)
			GATEWARE_FUNCTION(TransferLayersToBuffer)
			GATEWARE_FUNCTION(TransferStencilToBuffer)
			GATEWARE_FUNCTION(Clear)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
};

#endif // GBLITTER_H
#endif // GATEWARE_FEATURE_FLAG_IN_DEVELOPMENT

/*---------------------------------
|	End of GBlitter.h
----------------------------------*/


/*---------------------------------
|	Begin of GDirectX11Surface.h
----------------------------------*/
#ifndef GDIRECTX11SURFACE_H
#define GDIRECTX11SURFACE_H






namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceInterface : public virtual GEventReceiverInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetDevice(void** _outDevice) const = 0;
			virtual GReturn GetImmediateContext(void** _outContext) const = 0;
			virtual GReturn GetSwapchain(void** _outSwapchain) const = 0;
			virtual GReturn GetRenderTargetView(void** _outRenderTarget) const = 0;
			virtual GReturn GetDepthStencilView(void** _outDepthStencilView) const = 0;
		};
	}
}

// Implementaion for GDirectX11Surface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GDIRECTX11SURFACE) || defined(__APPLE__) || defined(__linux__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GDIRECTX11SURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceImplementation : public virtual GDirectX11SurfaceInterface
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) {
				return GReturn::FEATURE_UNSUPPORTED; 
			}
			GReturn GetAspectRatio(float& _outRatio) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetDevice(void** _outDevice) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetImmediateContext(void** _outContext) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetSwapchain(void** _outSwapchain) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetRenderTargetView(void** _outRenderTarget) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetDepthStencilView(void** _outDepthStencilView) const override {
				return GReturn::FAILURE; 
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(_WIN32)
    #include <wrl/client.h>
#include <d3d11.h>
#include <d2d1.h>
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d2d1.lib")

namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceImplementation : public virtual GDirectX11SurfaceInterface,
			private virtual GEventReceiverImplementation,
			private virtual GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventReceiver receiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH = {nullptr, nullptr};
			Microsoft::WRL::ComPtr<ID3D11Device> pDevice = nullptr;
			Microsoft::WRL::ComPtr<ID3D11DeviceContext> pImmediateContext = nullptr;
			Microsoft::WRL::ComPtr<IDXGISwapChain> pSwapChain = nullptr;
			Microsoft::WRL::ComPtr<ID3D11RenderTargetView> pBackBufferView = nullptr;
			Microsoft::WRL::ComPtr<ID3D11DepthStencilView> pDepthStencilView = nullptr;
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0.0f;
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::DIRECT2D_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);

				D3D_FEATURE_LEVEL featureLevels[] =
				{
					D3D_FEATURE_LEVEL_11_1,
					D3D_FEATURE_LEVEL_11_0,
					D3D_FEATURE_LEVEL_10_1,
					D3D_FEATURE_LEVEL_10_0,
					D3D_FEATURE_LEVEL_9_3,
					D3D_FEATURE_LEVEL_9_2,
					D3D_FEATURE_LEVEL_9_1
				};

				D3D11_CREATE_DEVICE_FLAG deviceFlag = D3D11_CREATE_DEVICE_FLAG(0);

#ifdef _DEBUG
				deviceFlag = D3D11_CREATE_DEVICE_FLAG(deviceFlag | D3D11_CREATE_DEVICE_DEBUG);
#endif

				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					deviceFlag = D3D11_CREATE_DEVICE_FLAG(deviceFlag | D3D11_CREATE_DEVICE_BGRA_SUPPORT); // | D3D11_CREATE_DEVICE_VIDEO_SUPPORT);
				}

				DXGI_SWAP_CHAIN_DESC swapChainStruct;
				swapChainStruct.BufferCount = 1;

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_R10G10B10A2_UNORM;
				else if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
				else
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

				swapChainStruct.BufferDesc.Width = width;
				swapChainStruct.BufferDesc.Height = height;
				ZeroMemory(&swapChainStruct.BufferDesc.RefreshRate, sizeof(swapChainStruct.BufferDesc.RefreshRate));
				ZeroMemory(&swapChainStruct.BufferDesc.Scaling, sizeof(swapChainStruct.BufferDesc.Scaling));
				ZeroMemory(&swapChainStruct.BufferDesc.ScanlineOrdering, sizeof(swapChainStruct.BufferDesc.ScanlineOrdering));
				swapChainStruct.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainStruct.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
				swapChainStruct.OutputWindow = static_cast<HWND>(UWH.window);
				swapChainStruct.Windowed = TRUE;
				swapChainStruct.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
				swapChainStruct.SampleDesc.Count = 1;
				swapChainStruct.SampleDesc.Quality = 0;

				HRESULT hr = D3D11CreateDeviceAndSwapChain(
					nullptr,
					D3D_DRIVER_TYPE_HARDWARE,
					nullptr,
					deviceFlag,
					featureLevels,
					ARRAYSIZE(featureLevels),
					D3D11_SDK_VERSION,
					&swapChainStruct,
					&pSwapChain,
					&pDevice,
					nullptr,
					&pImmediateContext
				);
				if (hr != S_OK)
					return GReturn::HARDWARE_UNAVAILABLE;

				ID3D11Resource* buffer;
				pSwapChain->GetBuffer(0, __uuidof(buffer), reinterpret_cast<void**>(&buffer));

				if (buffer)
					pDevice->CreateRenderTargetView(buffer, nullptr, &pBackBufferView);

				buffer->Release();

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					/////////////////////////////////
					// Create Depth Buffer Texture //
					/////////////////////////////////

					D3D11_TEXTURE2D_DESC depthTextureDesc = { 0 };
					depthTextureDesc.Width = width;
					depthTextureDesc.Height = height;
					depthTextureDesc.ArraySize = 1;
					depthTextureDesc.MipLevels = 1;
					depthTextureDesc.SampleDesc.Count = 1;

					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						depthTextureDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						depthTextureDesc.Format = DXGI_FORMAT_D32_FLOAT;

					depthTextureDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

					ID3D11Texture2D* depthBuffer;
					pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &depthBuffer);

					///////////////////////////////
					// Create Depth Stencil View //
					///////////////////////////////

					D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
					ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));

					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						depthStencilViewDesc.Format = DXGI_FORMAT_D32_FLOAT;

					depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;

					if (depthBuffer)
						hr = pDevice->CreateDepthStencilView(depthBuffer, &depthStencilViewDesc, &pDepthStencilView);

					depthBuffer->Release();
				}

				/////////////////////////
				// Initialize Viewport //
				/////////////////////////

				D3D11_VIEWPORT viewport;
				viewport.Width = static_cast<float>(width);
				viewport.Height = static_cast<float>(height);
				viewport.MinDepth = 0.0f;
				viewport.MaxDepth = 1.0f;

				unsigned int nTopLeftX = 0;
				unsigned int nTopLeftY = 0;
				gwindow.GetClientTopLeft(nTopLeftX, nTopLeftY);

				viewport.TopLeftX = static_cast<float>(nTopLeftX);
				viewport.TopLeftY = static_cast<float>(nTopLeftY);

				pImmediateContext->RSSetViewports(1, &viewport);
				// Call back event handler for DX11
				receiver.Create(gwindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					receiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
					case GW::SYSTEM::GWindow::Events::DESTROY: {} break;

					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					case GW::SYSTEM::GWindow::Events::RESIZE:
					{
						gwindow.GetClientWidth(width);
						gwindow.GetClientHeight(height);

						aspectRatio = static_cast<float>(width) / static_cast<float>(height);

						if (pSwapChain)
						{
							pBackBufferView.Reset();

							HRESULT hr = pSwapChain->ResizeBuffers(0, width, height, DXGI_FORMAT_UNKNOWN, 0);
							if (hr != S_OK)
								return;

							ID3D11Texture2D* newRTVBuffer;
							hr = pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&newRTVBuffer));

							if (hr != S_OK)
								return;

							hr = pDevice->CreateRenderTargetView(newRTVBuffer, nullptr, &pBackBufferView);
							newRTVBuffer->Release();

							if (hr != S_OK)
								return;

							D3D11_TEXTURE2D_DESC depthTextureDesc = { 0 };
							depthTextureDesc.Width = width;
							depthTextureDesc.Height = height;
							depthTextureDesc.ArraySize = 1;
							depthTextureDesc.MipLevels = 1;
							depthTextureDesc.SampleDesc.Count = 1;
							depthTextureDesc.Format = DXGI_FORMAT_D32_FLOAT;
							depthTextureDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

							if (pDepthStencilView)
							{
								pDepthStencilView.Reset();
								ID3D11Texture2D* depthBuffer;
								pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &depthBuffer);

								D3D11_DEPTH_STENCIL_VIEW_DESC newDSVdesc;
								ZeroMemory(&newDSVdesc, sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC));
								newDSVdesc.Format = DXGI_FORMAT_D32_FLOAT;
								newDSVdesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS;

								if (depthBuffer)
									pDevice->CreateDepthStencilView(depthBuffer, &newDSVdesc, &pDepthStencilView);

								depthBuffer->Release();
							}

							D3D11_VIEWPORT viewport;
							viewport.TopLeftX = 0;
							viewport.TopLeftY = 0;
							viewport.Width = static_cast<float>(width);
							viewport.Height = static_cast<float>(height);
							viewport.MinDepth = 0.0f;
							viewport.MaxDepth = 1.0f;

							pImmediateContext->RSSetViewports(1, &viewport);
						}
					}
					break;

					case GW::SYSTEM::GWindow::Events::MOVE:
					{
						gwindow.GetClientWidth(width);
						gwindow.GetClientHeight(height);

						D3D11_VIEWPORT viewport;
						viewport.TopLeftX = 0;
						viewport.TopLeftY = 0;
						viewport.Width = static_cast<float>(width);
						viewport.Height = static_cast<float>(height);
						viewport.MinDepth = 0.0f;
						viewport.MaxDepth = 1.0f;

						pImmediateContext->RSSetViewports(1, &viewport);
					}
					break;
					}
				});
				return GReturn::SUCCESS;
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** _outDevice) const override
			{
				if (!pDevice)
					return GReturn::FAILURE;

				*_outDevice = pDevice.Get();
				pDevice->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetImmediateContext(void** _outContext) const override
			{
				if (!pImmediateContext)
					return GReturn::FAILURE;

				*_outContext = pImmediateContext.Get();
				pImmediateContext->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain(void** _outSwapchain) const override
			{
				if (!pSwapChain)
					return GReturn::FAILURE;

				*_outSwapchain = pSwapChain.Get();
				pSwapChain->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetRenderTargetView(void** _outRenderTarget) const override
			{
				if (!pBackBufferView)
					return GReturn::FAILURE;

				*_outRenderTarget = pBackBufferView.Get();
				pBackBufferView->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetDepthStencilView(void** _outDepthStencilView) const override
			{
				if (!pDepthStencilView)
					return GReturn::FAILURE;

				*_outDepthStencilView = pDepthStencilView.Get();
				pDepthStencilView->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn Append(const GEvent& _inEvent) override { return receiver.Append(_inEvent); }
			GReturn Waiting(unsigned int& _outCount) const override { return receiver.Waiting(_outCount); }
			GReturn Pop(GEvent& _outEvent) override { return receiver.Pop(_outEvent); }
			GReturn Peek(GEvent& _outEvent) const override { return receiver.Peek(_outEvent); }
			GReturn Missed(unsigned int& _outCount) const override { return receiver.Missed(_outCount); }
			GReturn Clear() override { return receiver.Clear(); }
			GReturn Invoke() const override { return receiver.Invoke(); }
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) { return receiver.Find(_check, _remove); }
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) { return receiver.Find(_check, _remove, _outData); }
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GDirectX11Surface final
			: public I::GProxy<I::GDirectX11SurfaceInterface, I::GDirectX11SurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback {
				init_callback() {
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GW::CORE::GEventReceiver>;
				}
			}init;
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDirectX11Surface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetImmediateContext)
			GATEWARE_CONST_FUNCTION(GetSwapchain)
			GATEWARE_CONST_FUNCTION(GetRenderTargetView)
			GATEWARE_CONST_FUNCTION(GetDepthStencilView)

			// reimplemented functions
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDIRECTX11SURFACE_H

/*---------------------------------
|	End of GDirectX11Surface.h
----------------------------------*/


/*---------------------------------
|	Begin of GOpenGLSurface.h
----------------------------------*/
#ifndef GOPENGLSURFACE_H
#define GOPENGLSURFACE_H






namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceInterface : public virtual GEventReceiverInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetContext(void** _outContext) const = 0;
			virtual GReturn UniversalSwapBuffers() = 0;
			virtual GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) = 0;
			virtual GReturn EnableSwapControl(bool _setSwapControl) = 0;
		};
	}
}

// Implementaion for GOpenGLSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GOPENGLSURFACE) || defined(__APPLE__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) {
				return GReturn::FEATURE_UNSUPPORTED; 
			}
			GReturn GetAspectRatio(float& _outRatio) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetContext(void** _outContext) const override {
				return GReturn::FAILURE; 
			}
			GReturn UniversalSwapBuffers() override {
				return GReturn::FAILURE; 
			}
			GReturn QueryExtensionFunction(	const char* _extension, const char* _funcName, 
											void** _outFuncAddress) override {
				return GReturn::FAILURE; 
			}
			GReturn EnableSwapControl(bool _setSwapControl) override {
				return GReturn::FAILURE; 
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE; 
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE; 
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE; 
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE; 
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE; 
			}
			GReturn Clear() override {
				return GReturn::FAILURE; 
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE; 
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE; 
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE; 
			}
		};
	}
}


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <GL/gl.h>
#include <GL/glx.h>
#include <unistd.h>
#ifndef __glxext_h_
#define __glxext_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#ifndef GLX_GLXEXT_VERSION
    #define GLX_GLXEXT_VERSION 20170926
#endif

/* Generated C header for:
 * API: glx
 * Versions considered: .*
 * Versions emitted: 1\.[3-9]
 * Default extensions included: glx
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef GLX_VERSION_1_3
#define GLX_VERSION_1_3 1
typedef XID GLXContextID;
typedef struct __GLXFBConfigRec *GLXFBConfig;
typedef XID GLXWindow;
typedef XID GLXPbuffer;
#define GLX_WINDOW_BIT                    0x00000001
#define GLX_PIXMAP_BIT                    0x00000002
#define GLX_PBUFFER_BIT                   0x00000004
#define GLX_RGBA_BIT                      0x00000001
#define GLX_COLOR_INDEX_BIT               0x00000002
#define GLX_PBUFFER_CLOBBER_MASK          0x08000000
#define GLX_FRONT_LEFT_BUFFER_BIT         0x00000001
#define GLX_FRONT_RIGHT_BUFFER_BIT        0x00000002
#define GLX_BACK_LEFT_BUFFER_BIT          0x00000004
#define GLX_BACK_RIGHT_BUFFER_BIT         0x00000008
#define GLX_AUX_BUFFERS_BIT               0x00000010
#define GLX_DEPTH_BUFFER_BIT              0x00000020
#define GLX_STENCIL_BUFFER_BIT            0x00000040
#define GLX_ACCUM_BUFFER_BIT              0x00000080
#define GLX_CONFIG_CAVEAT                 0x20
#define GLX_X_VISUAL_TYPE                 0x22
#define GLX_TRANSPARENT_TYPE              0x23
#define GLX_TRANSPARENT_INDEX_VALUE       0x24
#define GLX_TRANSPARENT_RED_VALUE         0x25
#define GLX_TRANSPARENT_GREEN_VALUE       0x26
#define GLX_TRANSPARENT_BLUE_VALUE        0x27
#define GLX_TRANSPARENT_ALPHA_VALUE       0x28
#define GLX_DONT_CARE                     0xFFFFFFFF
#define GLX_NONE                          0x8000
#define GLX_SLOW_CONFIG                   0x8001
#define GLX_TRUE_COLOR                    0x8002
#define GLX_DIRECT_COLOR                  0x8003
#define GLX_PSEUDO_COLOR                  0x8004
#define GLX_STATIC_COLOR                  0x8005
#define GLX_GRAY_SCALE                    0x8006
#define GLX_STATIC_GRAY                   0x8007
#define GLX_TRANSPARENT_RGB               0x8008
#define GLX_TRANSPARENT_INDEX             0x8009
#define GLX_VISUAL_ID                     0x800B
#define GLX_SCREEN                        0x800C
#define GLX_NON_CONFORMANT_CONFIG         0x800D
#define GLX_DRAWABLE_TYPE                 0x8010
#define GLX_RENDER_TYPE                   0x8011
#define GLX_X_RENDERABLE                  0x8012
#define GLX_FBCONFIG_ID                   0x8013
#define GLX_RGBA_TYPE                     0x8014
#define GLX_COLOR_INDEX_TYPE              0x8015
#define GLX_MAX_PBUFFER_WIDTH             0x8016
#define GLX_MAX_PBUFFER_HEIGHT            0x8017
#define GLX_MAX_PBUFFER_PIXELS            0x8018
#define GLX_PRESERVED_CONTENTS            0x801B
#define GLX_LARGEST_PBUFFER               0x801C
#define GLX_WIDTH                         0x801D
#define GLX_HEIGHT                        0x801E
#define GLX_EVENT_MASK                    0x801F
#define GLX_DAMAGED                       0x8020
#define GLX_SAVED                         0x8021
#define GLX_WINDOW                        0x8022
#define GLX_PBUFFER                       0x8023
#define GLX_PBUFFER_HEIGHT                0x8040
#define GLX_PBUFFER_WIDTH                 0x8041
typedef GLXFBConfig *( *PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
typedef GLXFBConfig *( *PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
typedef int ( *PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
typedef GLXWindow ( *PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
typedef void ( *PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
typedef GLXPixmap ( *PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
typedef void ( *PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
typedef GLXPbuffer ( *PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
typedef void ( *PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
typedef void ( *PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
typedef GLXContext ( *PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
typedef Bool ( *PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
typedef int ( *PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
typedef void ( *PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
typedef void ( *PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXFBConfig *glXGetFBConfigs (Display *dpy, int screen, int *nelements);
GLXFBConfig *glXChooseFBConfig (Display *dpy, int screen, const int *attrib_list, int *nelements);
int glXGetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value);
XVisualInfo *glXGetVisualFromFBConfig (Display *dpy, GLXFBConfig config);
GLXWindow glXCreateWindow (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
void glXDestroyWindow (Display *dpy, GLXWindow win);
GLXPixmap glXCreatePixmap (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
void glXDestroyPixmap (Display *dpy, GLXPixmap pixmap);
GLXPbuffer glXCreatePbuffer (Display *dpy, GLXFBConfig config, const int *attrib_list);
void glXDestroyPbuffer (Display *dpy, GLXPbuffer pbuf);
void glXQueryDrawable (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
GLXContext glXCreateNewContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
Bool glXMakeContextCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
GLXDrawable glXGetCurrentReadDrawable (void);
int glXQueryContext (Display *dpy, GLXContext ctx, int attribute, int *value);
void glXSelectEvent (Display *dpy, GLXDrawable draw, unsigned long event_mask);
void glXGetSelectedEvent (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
#endif
#endif /* GLX_VERSION_1_3 */

#ifndef GLX_VERSION_1_4
#define GLX_VERSION_1_4 1
typedef void ( *__GLXextFuncPtr)(void);
#define GLX_SAMPLE_BUFFERS                100000
#define GLX_SAMPLES                       100001
typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
#ifdef GLX_GLXEXT_PROTOTYPES
__GLXextFuncPtr glXGetProcAddress (const GLubyte *procName);
#endif
#endif /* GLX_VERSION_1_4 */

#ifndef GLX_ARB_context_flush_control
#define GLX_ARB_context_flush_control 1
#define GLX_CONTEXT_RELEASE_BEHAVIOR_ARB  0x2097
#define GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0
#define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
#endif /* GLX_ARB_context_flush_control */

#ifndef GLX_ARB_create_context
#define GLX_ARB_create_context 1
#define GLX_CONTEXT_DEBUG_BIT_ARB         0x00000001
#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
#define GLX_CONTEXT_MAJOR_VERSION_ARB     0x2091
#define GLX_CONTEXT_MINOR_VERSION_ARB     0x2092
#define GLX_CONTEXT_FLAGS_ARB             0x2094
typedef GLXContext ( *PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXContext glXCreateContextAttribsARB (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
#endif
#endif /* GLX_ARB_create_context */

#ifndef GLX_ARB_create_context_no_error
#define GLX_ARB_create_context_no_error 1
#define GLX_CONTEXT_OPENGL_NO_ERROR_ARB   0x31B3
#endif /* GLX_ARB_create_context_no_error */

#ifndef GLX_ARB_create_context_profile
#define GLX_ARB_create_context_profile 1
#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define GLX_CONTEXT_PROFILE_MASK_ARB      0x9126
#endif /* GLX_ARB_create_context_profile */

#ifndef GLX_ARB_create_context_robustness
#define GLX_ARB_create_context_robustness 1
#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
#define GLX_LOSE_CONTEXT_ON_RESET_ARB     0x8252
#define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define GLX_NO_RESET_NOTIFICATION_ARB     0x8261
#endif /* GLX_ARB_create_context_robustness */

#ifndef GLX_ARB_fbconfig_float
#define GLX_ARB_fbconfig_float 1
#define GLX_RGBA_FLOAT_TYPE_ARB           0x20B9
#define GLX_RGBA_FLOAT_BIT_ARB            0x00000004
#endif /* GLX_ARB_fbconfig_float */

#ifndef GLX_ARB_framebuffer_sRGB
#define GLX_ARB_framebuffer_sRGB 1
#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20B2
#endif /* GLX_ARB_framebuffer_sRGB */

#ifndef GLX_ARB_get_proc_address
#define GLX_ARB_get_proc_address 1
typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSARBPROC) (const GLubyte *procName);
#ifdef GLX_GLXEXT_PROTOTYPES
__GLXextFuncPtr glXGetProcAddressARB (const GLubyte *procName);
#endif
#endif /* GLX_ARB_get_proc_address */

#ifndef GLX_ARB_multisample
#define GLX_ARB_multisample 1
#define GLX_SAMPLE_BUFFERS_ARB            100000
#define GLX_SAMPLES_ARB                   100001
#endif /* GLX_ARB_multisample */

#ifndef GLX_ARB_robustness_application_isolation
#define GLX_ARB_robustness_application_isolation 1
#define GLX_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
#endif /* GLX_ARB_robustness_application_isolation */

#ifndef GLX_ARB_robustness_share_group_isolation
#define GLX_ARB_robustness_share_group_isolation 1
#endif /* GLX_ARB_robustness_share_group_isolation */

#ifndef GLX_ARB_vertex_buffer_object
#define GLX_ARB_vertex_buffer_object 1
#define GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095
#endif /* GLX_ARB_vertex_buffer_object */

#ifndef GLX_3DFX_multisample
#define GLX_3DFX_multisample 1
#define GLX_SAMPLE_BUFFERS_3DFX           0x8050
#define GLX_SAMPLES_3DFX                  0x8051
#endif /* GLX_3DFX_multisample */

#ifndef GLX_AMD_gpu_association
#define GLX_AMD_gpu_association 1
#define GLX_GPU_VENDOR_AMD                0x1F00
#define GLX_GPU_RENDERER_STRING_AMD       0x1F01
#define GLX_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
#define GLX_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
#define GLX_GPU_RAM_AMD                   0x21A3
#define GLX_GPU_CLOCK_AMD                 0x21A4
#define GLX_GPU_NUM_PIPES_AMD             0x21A5
#define GLX_GPU_NUM_SIMD_AMD              0x21A6
#define GLX_GPU_NUM_RB_AMD                0x21A7
#define GLX_GPU_NUM_SPI_AMD               0x21A8
typedef unsigned int ( *PFNGLXGETGPUIDSAMDPROC) (unsigned int maxCount, unsigned int *ids);
typedef int ( *PFNGLXGETGPUINFOAMDPROC) (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
typedef unsigned int ( *PFNGLXGETCONTEXTGPUIDAMDPROC) (GLXContext ctx);
typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTAMDPROC) (unsigned int id, GLXContext share_list);
typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTATTRIBSAMDPROC) (unsigned int id, GLXContext share_context, const int *attribList);
typedef Bool ( *PFNGLXDELETEASSOCIATEDCONTEXTAMDPROC) (GLXContext ctx);
typedef Bool ( *PFNGLXMAKEASSOCIATEDCONTEXTCURRENTAMDPROC) (GLXContext ctx);
typedef GLXContext ( *PFNGLXGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
typedef void ( *PFNGLXBLITCONTEXTFRAMEBUFFERAMDPROC) (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int glXGetGPUIDsAMD (unsigned int maxCount, unsigned int *ids);
int glXGetGPUInfoAMD (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
unsigned int glXGetContextGPUIDAMD (GLXContext ctx);
GLXContext glXCreateAssociatedContextAMD (unsigned int id, GLXContext share_list);
GLXContext glXCreateAssociatedContextAttribsAMD (unsigned int id, GLXContext share_context, const int *attribList);
Bool glXDeleteAssociatedContextAMD (GLXContext ctx);
Bool glXMakeAssociatedContextCurrentAMD (GLXContext ctx);
GLXContext glXGetCurrentAssociatedContextAMD (void);
void glXBlitContextFramebufferAMD (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#endif
#endif /* GLX_AMD_gpu_association */

#ifndef GLX_EXT_buffer_age
#define GLX_EXT_buffer_age 1
#define GLX_BACK_BUFFER_AGE_EXT           0x20F4
#endif /* GLX_EXT_buffer_age */

#ifndef GLX_EXT_create_context_es2_profile
#define GLX_EXT_create_context_es2_profile 1
#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
#endif /* GLX_EXT_create_context_es2_profile */

#ifndef GLX_EXT_create_context_es_profile
#define GLX_EXT_create_context_es_profile 1
#define GLX_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
#endif /* GLX_EXT_create_context_es_profile */

#ifndef GLX_EXT_fbconfig_packed_float
#define GLX_EXT_fbconfig_packed_float 1
#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT  0x20B1
#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT   0x00000008
#endif /* GLX_EXT_fbconfig_packed_float */

#ifndef GLX_EXT_framebuffer_sRGB
#define GLX_EXT_framebuffer_sRGB 1
#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20B2
#endif /* GLX_EXT_framebuffer_sRGB */

#ifndef GLX_EXT_import_context
#define GLX_EXT_import_context 1
#define GLX_SHARE_CONTEXT_EXT             0x800A
#define GLX_VISUAL_ID_EXT                 0x800B
#define GLX_SCREEN_EXT                    0x800C
typedef Display *( *PFNGLXGETCURRENTDISPLAYEXTPROC) (void);
typedef int ( *PFNGLXQUERYCONTEXTINFOEXTPROC) (Display *dpy, GLXContext context, int attribute, int *value);
typedef GLXContextID ( *PFNGLXGETCONTEXTIDEXTPROC) (const GLXContext context);
typedef GLXContext ( *PFNGLXIMPORTCONTEXTEXTPROC) (Display *dpy, GLXContextID contextID);
typedef void ( *PFNGLXFREECONTEXTEXTPROC) (Display *dpy, GLXContext context);
#ifdef GLX_GLXEXT_PROTOTYPES
Display *glXGetCurrentDisplayEXT (void);
int glXQueryContextInfoEXT (Display *dpy, GLXContext context, int attribute, int *value);
GLXContextID glXGetContextIDEXT (const GLXContext context);
GLXContext glXImportContextEXT (Display *dpy, GLXContextID contextID);
void glXFreeContextEXT (Display *dpy, GLXContext context);
#endif
#endif /* GLX_EXT_import_context */

#ifndef GLX_EXT_libglvnd
#define GLX_EXT_libglvnd 1
#define GLX_VENDOR_NAMES_EXT              0x20F6
#endif /* GLX_EXT_libglvnd */

#ifndef GLX_EXT_stereo_tree
#define GLX_EXT_stereo_tree 1
typedef struct {
    int type;
    unsigned long serial;
    Bool send_event;
    Display *display;
    int extension;
    int evtype;
    GLXDrawable window;
    Bool stereo_tree;
} GLXStereoNotifyEventEXT;
#define GLX_STEREO_TREE_EXT               0x20F5
#define GLX_STEREO_NOTIFY_MASK_EXT        0x00000001
#define GLX_STEREO_NOTIFY_EXT             0x00000000
#endif /* GLX_EXT_stereo_tree */

#ifndef GLX_EXT_swap_control
#define GLX_EXT_swap_control 1
#define GLX_SWAP_INTERVAL_EXT             0x20F1
#define GLX_MAX_SWAP_INTERVAL_EXT         0x20F2
typedef void ( *PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXSwapIntervalEXT (Display *dpy, GLXDrawable drawable, int interval);
#endif
#endif /* GLX_EXT_swap_control */

#ifndef GLX_EXT_swap_control_tear
#define GLX_EXT_swap_control_tear 1
#define GLX_LATE_SWAPS_TEAR_EXT           0x20F3
#endif /* GLX_EXT_swap_control_tear */

#ifndef GLX_EXT_texture_from_pixmap
#define GLX_EXT_texture_from_pixmap 1
#define GLX_TEXTURE_1D_BIT_EXT            0x00000001
#define GLX_TEXTURE_2D_BIT_EXT            0x00000002
#define GLX_TEXTURE_RECTANGLE_BIT_EXT     0x00000004
#define GLX_BIND_TO_TEXTURE_RGB_EXT       0x20D0
#define GLX_BIND_TO_TEXTURE_RGBA_EXT      0x20D1
#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT    0x20D2
#define GLX_BIND_TO_TEXTURE_TARGETS_EXT   0x20D3
#define GLX_Y_INVERTED_EXT                0x20D4
#define GLX_TEXTURE_FORMAT_EXT            0x20D5
#define GLX_TEXTURE_TARGET_EXT            0x20D6
#define GLX_MIPMAP_TEXTURE_EXT            0x20D7
#define GLX_TEXTURE_FORMAT_NONE_EXT       0x20D8
#define GLX_TEXTURE_FORMAT_RGB_EXT        0x20D9
#define GLX_TEXTURE_FORMAT_RGBA_EXT       0x20DA
#define GLX_TEXTURE_1D_EXT                0x20DB
#define GLX_TEXTURE_2D_EXT                0x20DC
#define GLX_TEXTURE_RECTANGLE_EXT         0x20DD
#define GLX_FRONT_LEFT_EXT                0x20DE
#define GLX_FRONT_RIGHT_EXT               0x20DF
#define GLX_BACK_LEFT_EXT                 0x20E0
#define GLX_BACK_RIGHT_EXT                0x20E1
#define GLX_FRONT_EXT                     0x20DE
#define GLX_BACK_EXT                      0x20E0
#define GLX_AUX0_EXT                      0x20E2
#define GLX_AUX1_EXT                      0x20E3
#define GLX_AUX2_EXT                      0x20E4
#define GLX_AUX3_EXT                      0x20E5
#define GLX_AUX4_EXT                      0x20E6
#define GLX_AUX5_EXT                      0x20E7
#define GLX_AUX6_EXT                      0x20E8
#define GLX_AUX7_EXT                      0x20E9
#define GLX_AUX8_EXT                      0x20EA
#define GLX_AUX9_EXT                      0x20EB
typedef void ( *PFNGLXBINDTEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
typedef void ( *PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXBindTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
void glXReleaseTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer);
#endif
#endif /* GLX_EXT_texture_from_pixmap */

#ifndef GLX_EXT_visual_info
#define GLX_EXT_visual_info 1
#define GLX_X_VISUAL_TYPE_EXT             0x22
#define GLX_TRANSPARENT_TYPE_EXT          0x23
#define GLX_TRANSPARENT_INDEX_VALUE_EXT   0x24
#define GLX_TRANSPARENT_RED_VALUE_EXT     0x25
#define GLX_TRANSPARENT_GREEN_VALUE_EXT   0x26
#define GLX_TRANSPARENT_BLUE_VALUE_EXT    0x27
#define GLX_TRANSPARENT_ALPHA_VALUE_EXT   0x28
#define GLX_NONE_EXT                      0x8000
#define GLX_TRUE_COLOR_EXT                0x8002
#define GLX_DIRECT_COLOR_EXT              0x8003
#define GLX_PSEUDO_COLOR_EXT              0x8004
#define GLX_STATIC_COLOR_EXT              0x8005
#define GLX_GRAY_SCALE_EXT                0x8006
#define GLX_STATIC_GRAY_EXT               0x8007
#define GLX_TRANSPARENT_RGB_EXT           0x8008
#define GLX_TRANSPARENT_INDEX_EXT         0x8009
#endif /* GLX_EXT_visual_info */

#ifndef GLX_EXT_visual_rating
#define GLX_EXT_visual_rating 1
#define GLX_VISUAL_CAVEAT_EXT             0x20
#define GLX_SLOW_VISUAL_EXT               0x8001
#define GLX_NON_CONFORMANT_VISUAL_EXT     0x800D
#endif /* GLX_EXT_visual_rating */

#ifndef GLX_INTEL_swap_event
#define GLX_INTEL_swap_event 1
#define GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK 0x04000000
#define GLX_EXCHANGE_COMPLETE_INTEL       0x8180
#define GLX_COPY_COMPLETE_INTEL           0x8181
#define GLX_FLIP_COMPLETE_INTEL           0x8182
#endif /* GLX_INTEL_swap_event */

#ifndef GLX_MESA_agp_offset
#define GLX_MESA_agp_offset 1
typedef unsigned int ( *PFNGLXGETAGPOFFSETMESAPROC) (const void *pointer);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int glXGetAGPOffsetMESA (const void *pointer);
#endif
#endif /* GLX_MESA_agp_offset */

#ifndef GLX_MESA_copy_sub_buffer
#define GLX_MESA_copy_sub_buffer 1
typedef void ( *PFNGLXCOPYSUBBUFFERMESAPROC) (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopySubBufferMESA (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
#endif
#endif /* GLX_MESA_copy_sub_buffer */

#ifndef GLX_MESA_pixmap_colormap
#define GLX_MESA_pixmap_colormap 1
typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPMESAPROC) (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXPixmap glXCreateGLXPixmapMESA (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
#endif
#endif /* GLX_MESA_pixmap_colormap */

#ifndef GLX_MESA_query_renderer
#define GLX_MESA_query_renderer 1
#define GLX_RENDERER_VENDOR_ID_MESA       0x8183
#define GLX_RENDERER_DEVICE_ID_MESA       0x8184
#define GLX_RENDERER_VERSION_MESA         0x8185
#define GLX_RENDERER_ACCELERATED_MESA     0x8186
#define GLX_RENDERER_VIDEO_MEMORY_MESA    0x8187
#define GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA 0x8188
#define GLX_RENDERER_PREFERRED_PROFILE_MESA 0x8189
#define GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA 0x818A
#define GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA 0x818B
#define GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA 0x818C
#define GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA 0x818D
#define GLX_RENDERER_ID_MESA              0x818E
typedef Bool ( *PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC) (int attribute, unsigned int *value);
typedef const char *( *PFNGLXQUERYCURRENTRENDERERSTRINGMESAPROC) (int attribute);
typedef Bool ( *PFNGLXQUERYRENDERERINTEGERMESAPROC) (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
typedef const char *( *PFNGLXQUERYRENDERERSTRINGMESAPROC) (Display *dpy, int screen, int renderer, int attribute);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXQueryCurrentRendererIntegerMESA (int attribute, unsigned int *value);
const char *glXQueryCurrentRendererStringMESA (int attribute);
Bool glXQueryRendererIntegerMESA (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
const char *glXQueryRendererStringMESA (Display *dpy, int screen, int renderer, int attribute);
#endif
#endif /* GLX_MESA_query_renderer */

#ifndef GLX_MESA_release_buffers
#define GLX_MESA_release_buffers 1
typedef Bool ( *PFNGLXRELEASEBUFFERSMESAPROC) (Display *dpy, GLXDrawable drawable);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXReleaseBuffersMESA (Display *dpy, GLXDrawable drawable);
#endif
#endif /* GLX_MESA_release_buffers */

#ifndef GLX_MESA_set_3dfx_mode
#define GLX_MESA_set_3dfx_mode 1
#define GLX_3DFX_WINDOW_MODE_MESA         0x1
#define GLX_3DFX_FULLSCREEN_MODE_MESA     0x2
typedef Bool ( *PFNGLXSET3DFXMODEMESAPROC) (int mode);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXSet3DfxModeMESA (int mode);
#endif
#endif /* GLX_MESA_set_3dfx_mode */

#ifndef GLX_MESA_swap_control
#define GLX_MESA_swap_control 1
typedef int ( *PFNGLXGETSWAPINTERVALMESAPROC) (void);
typedef void ( *PFNGLXSWAPINTERVALMESAPROC) (unsigned int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetSwapIntervalMESA (void);
void glXSwapIntervalMESA (unsigned int interval);
#endif
#endif /* GLX_MESA_swap_control */

#ifndef GLX_NV_copy_buffer
#define GLX_NV_copy_buffer 1
typedef void ( *PFNGLXCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( *PFNGLXNAMEDCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
void glXNamedCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif
#endif /* GLX_NV_copy_buffer */

#ifndef GLX_NV_copy_image
#define GLX_NV_copy_image 1
typedef void ( *PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopyImageSubDataNV (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#endif
#endif /* GLX_NV_copy_image */

#ifndef GLX_NV_delay_before_swap
#define GLX_NV_delay_before_swap 1
typedef Bool ( *PFNGLXDELAYBEFORESWAPNVPROC) (Display *dpy, GLXDrawable drawable, GLfloat seconds);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXDelayBeforeSwapNV (Display *dpy, GLXDrawable drawable, GLfloat seconds);
#endif
#endif /* GLX_NV_delay_before_swap */

#ifndef GLX_NV_float_buffer
#define GLX_NV_float_buffer 1
#define GLX_FLOAT_COMPONENTS_NV           0x20B0
#endif /* GLX_NV_float_buffer */

#ifndef GLX_NV_multisample_coverage
#define GLX_NV_multisample_coverage 1
#define GLX_COVERAGE_SAMPLES_NV           100001
#define GLX_COLOR_SAMPLES_NV              0x20B3
#endif /* GLX_NV_multisample_coverage */

#ifndef GLX_NV_present_video
#define GLX_NV_present_video 1
#define GLX_NUM_VIDEO_SLOTS_NV            0x20F0
typedef unsigned int *( *PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
typedef int ( *PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int *glXEnumerateVideoDevicesNV (Display *dpy, int screen, int *nelements);
int glXBindVideoDeviceNV (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
#endif
#endif /* GLX_NV_present_video */

#ifndef GLX_NV_robustness_video_memory_purge
#define GLX_NV_robustness_video_memory_purge 1
#define GLX_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV 0x20F7
#endif /* GLX_NV_robustness_video_memory_purge */

#ifndef GLX_NV_swap_group
#define GLX_NV_swap_group 1
typedef Bool ( *PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
typedef Bool ( *PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
typedef Bool ( *PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
typedef Bool ( *PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
typedef Bool ( *PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
typedef Bool ( *PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXJoinSwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint group);
Bool glXBindSwapBarrierNV (Display *dpy, GLuint group, GLuint barrier);
Bool glXQuerySwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
Bool glXQueryMaxSwapGroupsNV (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
Bool glXQueryFrameCountNV (Display *dpy, int screen, GLuint *count);
Bool glXResetFrameCountNV (Display *dpy, int screen);
#endif
#endif /* GLX_NV_swap_group */

#ifndef GLX_NV_video_capture
#define GLX_NV_video_capture 1
typedef XID GLXVideoCaptureDeviceNV;
#define GLX_DEVICE_ID_NV                  0x20CD
#define GLX_UNIQUE_ID_NV                  0x20CE
#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
typedef int ( *PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
typedef GLXVideoCaptureDeviceNV *( *PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
typedef void ( *PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
typedef int ( *PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
typedef void ( *PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXBindVideoCaptureDeviceNV (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
GLXVideoCaptureDeviceNV *glXEnumerateVideoCaptureDevicesNV (Display *dpy, int screen, int *nelements);
void glXLockVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
int glXQueryVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
void glXReleaseVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
#endif
#endif /* GLX_NV_video_capture */

#ifndef GLX_NV_video_out
#define GLX_NV_video_out 1
typedef unsigned int GLXVideoDeviceNV;
#define GLX_VIDEO_OUT_COLOR_NV            0x20C3
#define GLX_VIDEO_OUT_ALPHA_NV            0x20C4
#define GLX_VIDEO_OUT_DEPTH_NV            0x20C5
#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
#define GLX_VIDEO_OUT_FRAME_NV            0x20C8
#define GLX_VIDEO_OUT_FIELD_1_NV          0x20C9
#define GLX_VIDEO_OUT_FIELD_2_NV          0x20CA
#define GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV 0x20CB
#define GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV 0x20CC
typedef int ( *PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
typedef int ( *PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
typedef int ( *PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
typedef int ( *PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
typedef int ( *PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
typedef int ( *PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetVideoDeviceNV (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
int glXReleaseVideoDeviceNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
int glXBindVideoImageNV (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
int glXReleaseVideoImageNV (Display *dpy, GLXPbuffer pbuf);
int glXSendPbufferToVideoNV (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
int glXGetVideoInfoNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#endif
#endif /* GLX_NV_video_out */

#ifndef GLX_OML_swap_method
#define GLX_OML_swap_method 1
#define GLX_SWAP_METHOD_OML               0x8060
#define GLX_SWAP_EXCHANGE_OML             0x8061
#define GLX_SWAP_COPY_OML                 0x8062
#define GLX_SWAP_UNDEFINED_OML            0x8063
#endif /* GLX_OML_swap_method */

#ifndef GLX_OML_sync_control
#define GLX_OML_sync_control 1
#ifndef GLEXT_64_TYPES_DEFINED
/* This code block is duplicated in glext.h, so must be protected */
#define GLEXT_64_TYPES_DEFINED
/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
/* (as used in the GLX_OML_sync_control extension). */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
#elif defined(__sun__) || defined(__digital__)
#include <inttypes.h>
#if defined(__STDC__)
#if defined(__arch64__) || defined(_LP64)
typedef long int int64_t;
typedef unsigned long int uint64_t;
#else
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#endif /* __arch64__ */
#endif /* __STDC__ */
#elif defined( __VMS ) || defined(__sgi)
#include <inttypes.h>
#elif defined(__SCO__) || defined(__USLC__)
#include <stdint.h>
#elif defined(__UNIXOS2__) || defined(__SOL64__)
typedef long int int32_t;
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#elif defined(_WIN32) && defined(__GNUC__)
#include <stdint.h>
#elif defined(_WIN32)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
/* Fallback if nothing above works */
#include <inttypes.h>
#endif
#endif
typedef Bool ( *PFNGLXGETSYNCVALUESOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
typedef Bool ( *PFNGLXGETMSCRATEOMLPROC) (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
typedef int64_t ( *PFNGLXSWAPBUFFERSMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
typedef Bool ( *PFNGLXWAITFORMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
typedef Bool ( *PFNGLXWAITFORSBCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXGetSyncValuesOML (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
Bool glXGetMscRateOML (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
int64_t glXSwapBuffersMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
Bool glXWaitForMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
Bool glXWaitForSbcOML (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
#endif
#endif /* GLX_OML_sync_control */

#ifndef GLX_SGIS_blended_overlay
#define GLX_SGIS_blended_overlay 1
#define GLX_BLENDED_RGBA_SGIS             0x8025
#endif /* GLX_SGIS_blended_overlay */

#ifndef GLX_SGIS_multisample
#define GLX_SGIS_multisample 1
#define GLX_SAMPLE_BUFFERS_SGIS           100000
#define GLX_SAMPLES_SGIS                  100001
#endif /* GLX_SGIS_multisample */

#ifndef GLX_SGIS_shared_multisample
#define GLX_SGIS_shared_multisample 1
#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
#endif /* GLX_SGIS_shared_multisample */

#ifndef GLX_SGIX_dmbuffer
#define GLX_SGIX_dmbuffer 1
typedef XID GLXPbufferSGIX;
#ifdef _DM_BUFFER_H_
#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX    0x8024
typedef Bool ( *PFNGLXASSOCIATEDMPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXAssociateDMPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
#endif
#endif /* _DM_BUFFER_H_ */
#endif /* GLX_SGIX_dmbuffer */

#ifndef GLX_SGIX_fbconfig
#define GLX_SGIX_fbconfig 1
typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
#define GLX_WINDOW_BIT_SGIX               0x00000001
#define GLX_PIXMAP_BIT_SGIX               0x00000002
#define GLX_RGBA_BIT_SGIX                 0x00000001
#define GLX_COLOR_INDEX_BIT_SGIX          0x00000002
#define GLX_DRAWABLE_TYPE_SGIX            0x8010
#define GLX_RENDER_TYPE_SGIX              0x8011
#define GLX_X_RENDERABLE_SGIX             0x8012
#define GLX_FBCONFIG_ID_SGIX              0x8013
#define GLX_RGBA_TYPE_SGIX                0x8014
#define GLX_COLOR_INDEX_TYPE_SGIX         0x8015
typedef int ( *PFNGLXGETFBCONFIGATTRIBSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
typedef GLXFBConfigSGIX *( *PFNGLXCHOOSEFBCONFIGSGIXPROC) (Display *dpy, int screen, int *attrib_list, int *nelements);
typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
typedef GLXContext ( *PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config);
typedef GLXFBConfigSGIX ( *PFNGLXGETFBCONFIGFROMVISUALSGIXPROC) (Display *dpy, XVisualInfo *vis);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetFBConfigAttribSGIX (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements);
GLXPixmap glXCreateGLXPixmapWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
GLXContext glXCreateContextWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
XVisualInfo *glXGetVisualFromFBConfigSGIX (Display *dpy, GLXFBConfigSGIX config);
GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX (Display *dpy, XVisualInfo *vis);
#endif
#endif /* GLX_SGIX_fbconfig */

#ifndef GLX_SGIX_hyperpipe
#define GLX_SGIX_hyperpipe 1
typedef struct {
    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int     networkId;
} GLXHyperpipeNetworkSGIX;
typedef struct {
    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int     channel;
    unsigned int participationType;
    int     timeSlice;
} GLXHyperpipeConfigSGIX;
typedef struct {
    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
    int destXOrigin, destYOrigin, destWidth, destHeight;
} GLXPipeRect;
typedef struct {
    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int XOrigin, YOrigin, maxHeight, maxWidth;
} GLXPipeRectLimits;
#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
#define GLX_BAD_HYPERPIPE_CONFIG_SGIX     91
#define GLX_BAD_HYPERPIPE_SGIX            92
#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX   0x00000001
#define GLX_HYPERPIPE_RENDER_PIPE_SGIX    0x00000002
#define GLX_PIPE_RECT_SGIX                0x00000001
#define GLX_PIPE_RECT_LIMITS_SGIX         0x00000002
#define GLX_HYPERPIPE_STEREO_SGIX         0x00000003
#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX  0x00000004
#define GLX_HYPERPIPE_ID_SGIX             0x8030
typedef GLXHyperpipeNetworkSGIX *( *PFNGLXQUERYHYPERPIPENETWORKSGIXPROC) (Display *dpy, int *npipes);
typedef int ( *PFNGLXHYPERPIPECONFIGSGIXPROC) (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
typedef GLXHyperpipeConfigSGIX *( *PFNGLXQUERYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId, int *npipes);
typedef int ( *PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId);
typedef int ( *PFNGLXBINDHYPERPIPESGIXPROC) (Display *dpy, int hpId);
typedef int ( *PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
typedef int ( *PFNGLXHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
typedef int ( *PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXHyperpipeNetworkSGIX *glXQueryHyperpipeNetworkSGIX (Display *dpy, int *npipes);
int glXHyperpipeConfigSGIX (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
GLXHyperpipeConfigSGIX *glXQueryHyperpipeConfigSGIX (Display *dpy, int hpId, int *npipes);
int glXDestroyHyperpipeConfigSGIX (Display *dpy, int hpId);
int glXBindHyperpipeSGIX (Display *dpy, int hpId);
int glXQueryHyperpipeBestAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
int glXHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
int glXQueryHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
#endif
#endif /* GLX_SGIX_hyperpipe */

#ifndef GLX_SGIX_pbuffer
#define GLX_SGIX_pbuffer 1
#define GLX_PBUFFER_BIT_SGIX              0x00000004
#define GLX_BUFFER_CLOBBER_MASK_SGIX      0x08000000
#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX    0x00000001
#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX   0x00000002
#define GLX_BACK_LEFT_BUFFER_BIT_SGIX     0x00000004
#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX    0x00000008
#define GLX_AUX_BUFFERS_BIT_SGIX          0x00000010
#define GLX_DEPTH_BUFFER_BIT_SGIX         0x00000020
#define GLX_STENCIL_BUFFER_BIT_SGIX       0x00000040
#define GLX_ACCUM_BUFFER_BIT_SGIX         0x00000080
#define GLX_SAMPLE_BUFFERS_BIT_SGIX       0x00000100
#define GLX_MAX_PBUFFER_WIDTH_SGIX        0x8016
#define GLX_MAX_PBUFFER_HEIGHT_SGIX       0x8017
#define GLX_MAX_PBUFFER_PIXELS_SGIX       0x8018
#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX    0x8019
#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX   0x801A
#define GLX_PRESERVED_CONTENTS_SGIX       0x801B
#define GLX_LARGEST_PBUFFER_SGIX          0x801C
#define GLX_WIDTH_SGIX                    0x801D
#define GLX_HEIGHT_SGIX                   0x801E
#define GLX_EVENT_MASK_SGIX               0x801F
#define GLX_DAMAGED_SGIX                  0x8020
#define GLX_SAVED_SGIX                    0x8021
#define GLX_WINDOW_SGIX                   0x8022
#define GLX_PBUFFER_SGIX                  0x8023
typedef GLXPbufferSGIX ( *PFNGLXCREATEGLXPBUFFERSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
typedef void ( *PFNGLXDESTROYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf);
typedef int ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
typedef void ( *PFNGLXSELECTEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long mask);
typedef void ( *PFNGLXGETSELECTEDEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long *mask);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXPbufferSGIX glXCreateGLXPbufferSGIX (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
void glXDestroyGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf);
int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
void glXSelectEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long mask);
void glXGetSelectedEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long *mask);
#endif
#endif /* GLX_SGIX_pbuffer */

#ifndef GLX_SGIX_swap_barrier
#define GLX_SGIX_swap_barrier 1
typedef void ( *PFNGLXBINDSWAPBARRIERSGIXPROC) (Display *dpy, GLXDrawable drawable, int barrier);
typedef Bool ( *PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC) (Display *dpy, int screen, int *max);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXBindSwapBarrierSGIX (Display *dpy, GLXDrawable drawable, int barrier);
Bool glXQueryMaxSwapBarriersSGIX (Display *dpy, int screen, int *max);
#endif
#endif /* GLX_SGIX_swap_barrier */

#ifndef GLX_SGIX_swap_group
#define GLX_SGIX_swap_group 1
typedef void ( *PFNGLXJOINSWAPGROUPSGIXPROC) (Display *dpy, GLXDrawable drawable, GLXDrawable member);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXJoinSwapGroupSGIX (Display *dpy, GLXDrawable drawable, GLXDrawable member);
#endif
#endif /* GLX_SGIX_swap_group */

#ifndef GLX_SGIX_video_resize
#define GLX_SGIX_video_resize 1
#define GLX_SYNC_FRAME_SGIX               0x00000000
#define GLX_SYNC_SWAP_SGIX                0x00000001
typedef int ( *PFNGLXBINDCHANNELTOWINDOWSGIXPROC) (Display *display, int screen, int channel, Window window);
typedef int ( *PFNGLXCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int x, int y, int w, int h);
typedef int ( *PFNGLXQUERYCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
typedef int ( *PFNGLXQUERYCHANNELDELTASSGIXPROC) (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
typedef int ( *PFNGLXCHANNELRECTSYNCSGIXPROC) (Display *display, int screen, int channel, GLenum synctype);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXBindChannelToWindowSGIX (Display *display, int screen, int channel, Window window);
int glXChannelRectSGIX (Display *display, int screen, int channel, int x, int y, int w, int h);
int glXQueryChannelRectSGIX (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
int glXQueryChannelDeltasSGIX (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
int glXChannelRectSyncSGIX (Display *display, int screen, int channel, GLenum synctype);
#endif
#endif /* GLX_SGIX_video_resize */

#ifndef GLX_SGIX_video_source
#define GLX_SGIX_video_source 1
typedef XID GLXVideoSourceSGIX;
#ifdef _VL_H
typedef GLXVideoSourceSGIX ( *PFNGLXCREATEGLXVIDEOSOURCESGIXPROC) (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
typedef void ( *PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC) (Display *dpy, GLXVideoSourceSGIX glxvideosource);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
void glXDestroyGLXVideoSourceSGIX (Display *dpy, GLXVideoSourceSGIX glxvideosource);
#endif
#endif /* _VL_H */
#endif /* GLX_SGIX_video_source */

#ifndef GLX_SGIX_visual_select_group
#define GLX_SGIX_visual_select_group 1
#define GLX_VISUAL_SELECT_GROUP_SGIX      0x8028
#endif /* GLX_SGIX_visual_select_group */

#ifndef GLX_SGI_cushion
#define GLX_SGI_cushion 1
typedef void ( *PFNGLXCUSHIONSGIPROC) (Display *dpy, Window window, float cushion);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCushionSGI (Display *dpy, Window window, float cushion);
#endif
#endif /* GLX_SGI_cushion */

#ifndef GLX_SGI_make_current_read
#define GLX_SGI_make_current_read 1
typedef Bool ( *PFNGLXMAKECURRENTREADSGIPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLESGIPROC) (void);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXMakeCurrentReadSGI (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
GLXDrawable glXGetCurrentReadDrawableSGI (void);
#endif
#endif /* GLX_SGI_make_current_read */

#ifndef GLX_SGI_swap_control
#define GLX_SGI_swap_control 1
typedef int ( *PFNGLXSWAPINTERVALSGIPROC) (int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXSwapIntervalSGI (int interval);
#endif
#endif /* GLX_SGI_swap_control */

#ifndef GLX_SGI_video_sync
#define GLX_SGI_video_sync 1
typedef int ( *PFNGLXGETVIDEOSYNCSGIPROC) (unsigned int *count);
typedef int ( *PFNGLXWAITVIDEOSYNCSGIPROC) (int divisor, int remainder, unsigned int *count);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetVideoSyncSGI (unsigned int *count);
int glXWaitVideoSyncSGI (int divisor, int remainder, unsigned int *count);
#endif
#endif /* GLX_SGI_video_sync */

#ifndef GLX_SUN_get_transparent_index
#define GLX_SUN_get_transparent_index 1
typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
#ifdef GLX_GLXEXT_PROTOTYPES
Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
#endif
#endif /* GLX_SUN_get_transparent_index */

#ifdef __cplusplus
}
#endif

#endif


#include <cstring>
#include <string>

class glXQueryVersion;
namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface,
			protected GEventReceiverImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventReceiver receiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH;
			unsigned int clientX;
			unsigned int clientY;
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0;

			GLint extensionCount = 0;
			const char* glExtensions;

#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091
#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092

			// GLX FUNCTION POINTERS //
			PFNGLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB;
			PFNGLXSWAPINTERVALEXTPROC glXSwapIntervalEXT;

			GLint attributes[5] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };
			GLXContext OGLXContext;
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;
					
				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::OPENGL_ES_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientTopLeft(clientX, clientY);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);

				static int frameBufferAttributes[] =
				{
					GLX_RENDER_TYPE, GLX_RGBA_BIT,
					GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
					GLX_DOUBLEBUFFER, true,
					GLX_RED_SIZE, 8,
					GLX_GREEN_SIZE, 8,
					GLX_BLUE_SIZE, 8,
					GLX_ALPHA_SIZE, 8,
					GLX_DEPTH_SIZE, 0,
					GLX_STENCIL_SIZE, 0,
					None
				};

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					frameBufferAttributes[7] = 10;
					frameBufferAttributes[9] = 10;
					frameBufferAttributes[11] = 10;
					frameBufferAttributes[13] = 2;
				}

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					frameBufferAttributes[15] = 24;

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					frameBufferAttributes[15] = 24;
					frameBufferAttributes[17] = 8;
				}

				// Select the default Frame buffer configuration //
				XLockDisplay(static_cast<Display*>(UWH.display));
				// use null attribs to scan for available formats and check against request
				int queryCount = 0;
				bool formatMatch = false;
				GLXFBConfig* queryConfig;
				if (queryConfig = glXGetFBConfigs(	static_cast<Display*>(UWH.display), 
													DefaultScreen(static_cast<Display*>(UWH.display)), &queryCount))
				{
					int numAttrib2Search = sizeof(frameBufferAttributes) / sizeof(int) / 2;
					// scan for matching frame attributes, fail if not found
					for (int i = 0; i < queryCount; ++i)
					{
						// search attrib pairs to see if all items match
						int attribMatch = 0;
						for (int j = 0; j < numAttrib2Search; ++j)
						{
							int attribVal; int errCode;	
							// if the attribute we are looking for is DC we don't care about it, mark it anyway
							if (frameBufferAttributes[j*2+1] != GLX_DONT_CARE)
							{
								errCode = glXGetFBConfigAttrib(	static_cast<Display*>(UWH.display), queryConfig[i], 
																frameBufferAttributes[j*2], &attribVal);
								if (errCode != GLX_NO_EXTENSION && errCode != GLX_BAD_ATTRIBUTE)
								{
									if (frameBufferAttributes[j*2] == GLX_DRAWABLE_TYPE ||
										frameBufferAttributes[j*2] == GLX_RENDER_TYPE)
									{
										if ((frameBufferAttributes[j*2+1] & attribVal) ==
											frameBufferAttributes[j*2+1])
											++attribMatch;
									} 
									else if(frameBufferAttributes[j*2+1] == attribVal)	
										++attribMatch;
								}
							}
							else // this is not something we intend to use so whatever it is, is fine
								++attribMatch;
						}
						//std::cout << "OGL FBCONFIG: " << attribMatch << " ATTRIBS MATCHED" << std::endl;
						if (attribMatch == numAttrib2Search)
						{
							formatMatch = true;
							queryCount = i; // save the first match
							break;
						}
					}
				}
				// fail if no matching format found
				if (!queryConfig || formatMatch == false)
					return GReturn::HARDWARE_UNAVAILABLE;
				/*
				int ver[2];// does not find ogl version
				if (glXQueryVersion(static_cast<Display*>(UWH.display),&ver[0],&ver[1]) == false) // is OpenGL available?
					return GReturn::HARDWARE_UNAVAILABLE;
				// I need to detect OpenGL 3.3 if we request HDR 1010102
				
				int frameBufferCount;
				GLXFBConfig* frameBufferConfig = glXChooseFBConfig(static_cast<Display*>(UWH.display), DefaultScreen(static_cast<Display*>(UWH.display)), frameBufferAttributes, &frameBufferCount);
				
				if (!frameBufferConfig)
					return GReturn::HARDWARE_UNAVAILABLE;
				*/
				XVisualInfo* visualInfo = glXGetVisualFromFBConfig(
					static_cast<Display*>(UWH.display), queryConfig[queryCount]);
				//Colormap colorMap = XCreateColormap(static_cast<Display*>(UWH.display), 
				//	RootWindow(static_cast<Display*>(UWH.display), visualInfo->screen), visualInfo->visual, AllocNone);

				XWindowAttributes curWinAttrib; // Current window attributes
				XGetWindowAttributes(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), &curWinAttrib);

				XSetWindowAttributes swa;
				swa.event_mask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | curWinAttrib.all_event_masks;

				unsigned long valueMask = CWEventMask;

				XChangeWindowAttributes(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), valueMask, &swa);
				GLXContext oldContext = glXCreateContext(static_cast<Display*>(UWH.display), visualInfo, 0, GL_TRUE);
				
				XFree(visualInfo);

				// Load GLX Extensions //
				glExtensions = glXQueryExtensionsString(static_cast<Display*>(UWH.display), DefaultScreen(static_cast<Display*>(UWH.display)));

				glXCreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glXGetProcAddressARB((const GLubyte*)"glXCreateContextAttribsARB");
				glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddressARB((const GLubyte*)"glXSwapIntervalEXT");

				if (!glXMakeCurrent(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), oldContext))
				{
					XUnlockDisplay(static_cast<Display*>(UWH.display));
					XFree(queryConfig);
					return GReturn::FAILURE;
				}
				
				// print openGL version
				std::string ver = reinterpret_cast<const char*>(glGetString(GL_VERSION));
				//std::cout << ver << std::endl;

				glXDestroyContext(static_cast<Display*>(UWH.display), oldContext);
				
				// Extract the version number only contiue if 3.0 or better
				float glVer = std::stof(ver) + 0.000001f; // remove round down
				if (glVer < 3.0f)
				{					
					XFree(queryConfig);
					return GReturn::HARDWARE_UNAVAILABLE;
				}

				// Create new context //
				int contextAttribs[] =
				{
					GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
					GLX_CONTEXT_MINOR_VERSION_ARB, 0,
					GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
					None
				};

				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
					contextAttribs[5] = GLX_CONTEXT_ES2_PROFILE_BIT_EXT;
					
				OGLXContext = glXCreateContextAttribsARB(static_cast<Display*>(UWH.display), 
					queryConfig[queryCount], NULL, true, contextAttribs);
				
				XFree(queryConfig);
					
				if (!glXMakeCurrent(static_cast<Display*>(UWH.display), 
					*static_cast<Window*>(UWH.window), OGLXContext))
				{
					XUnlockDisplay(static_cast<Display*>(UWH.display));
					return GReturn::FAILURE;
				}

				XUnlockDisplay(static_cast<Display*>(UWH.display));

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					glEnable(GL_DEPTH_TEST);

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
					glEnable(GL_STENCIL_TEST);

				// CHECK IF INIT FLAGS WERE MET //
				// 10 BIT COLOR //
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					GLint red, green, blue;
					glGetIntegerv(GL_RED_BITS, &red);
					glGetIntegerv(GL_GREEN_BITS, &green);
					glGetIntegerv(GL_BLUE_BITS, &blue);
					if (red != 0 && green != 10 && blue != 10)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH BUFFER SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					GLint depth;
					glGetIntegerv(GL_DEPTH_BITS, &depth);
					if (depth == 0 || !glIsEnabled(GL_DEPTH_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH STENCIL SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					GLint stencil;
					glGetIntegerv(GL_STENCIL_BITS, &stencil);
					if (stencil == 0 || !glIsEnabled(GL_STENCIL_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// ES CONTEXT SUPPORT //
				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					char* version = (char*)glGetString(GL_VERSION);

					if (strstr(version, "OpenGL ES") == NULL)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DIRECT2D SUPPORT //
				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				//XFree(frameBufferConfig);

				// Call back event handler for OpenGL
				return receiver.Create(gwindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					receiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
					case GW::SYSTEM::GWindow::Events::DESTROY:
					{
						gwindow.GetWindowHandle(UWH);
						glXMakeCurrent(static_cast<Display*>(UWH.display), None, NULL);
						glXDestroyContext(static_cast<Display*>(UWH.display), OGLXContext);
						OGLXContext = nullptr;
					}
					break;

					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					case GW::SYSTEM::GWindow::Events::RESIZE:
					{
						gwindow.GetClientTopLeft(clientX, clientY);
						gwindow.GetClientWidth(width);
						gwindow.GetClientHeight(height);
						aspectRatio = static_cast<float>(width) / static_cast<float>(height);
						glViewport(clientX, clientY, width, height);
					}
					break;

					case GW::SYSTEM::GWindow::Events::MOVE:
					{
						gwindow.GetClientTopLeft(clientX, clientY);
						gwindow.GetClientWidth(width);
						gwindow.GetClientHeight(height);
						aspectRatio = static_cast<float>(width) / static_cast<float>(height);
						glViewport(clientX, clientY, width, height);
					}
					break;
					}
				});
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetContext(void** _outContext) const override
			{
				if (!OGLXContext)
					return GReturn::FAILURE;

				*_outContext = OGLXContext;
				return GReturn::SUCCESS;
			}

			GReturn UniversalSwapBuffers() override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				if (-gwindow.GetWindowHandle(UWH))
					return GReturn::FAILURE;

				if (!static_cast<Display*>(UWH.display) || *static_cast<Window*>(UWH.window) == 0)
					return GReturn::FAILURE;

				glXSwapBuffers(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window));
				return GReturn::SUCCESS;
			}

			GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) override
			{
				if ((_funcName == nullptr && _outFuncAddress != nullptr) ||
					(_funcName != nullptr && _outFuncAddress == nullptr) ||
					_extension == nullptr && _funcName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				// User only passed in function name, without extension //
				if (_extension == nullptr && _funcName != nullptr && _outFuncAddress != nullptr)
				{
					*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_funcName);
					if (*_outFuncAddress == nullptr)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User only passed in extension name, without function //
				if (_funcName == nullptr && _outFuncAddress == nullptr)
				{
					if (strstr(glExtensions, _extension) != NULL)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User passed in extension name and function name //
				if (strstr(glExtensions, _extension) != NULL)
				{
					if (_funcName != NULL)
						*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_funcName);
					else
						*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_extension);
					return GReturn::SUCCESS;
				}
				return GReturn::FAILURE;
			}

			GReturn EnableSwapControl(bool _setSwapControl)
			{
				if (!glXSwapIntervalEXT)
					return GW::GReturn::FEATURE_UNSUPPORTED;

				if (!OGLXContext)
					return GW::GReturn::FAILURE;

				if (!gwindow)
					return GW::GReturn::FAILURE;

				gwindow.GetWindowHandle(UWH);
				XLockDisplay(static_cast<Display*>(UWH.display));
				if (_setSwapControl)
					glXSwapIntervalEXT(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window), 1);
				else
					glXSwapIntervalEXT(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window), 0);
				XUnlockDisplay(static_cast<Display*>(UWH.display));
				return GReturn::SUCCESS;
			}

			GReturn Append(const GEvent& _inEvent) override { return receiver.Append(_inEvent); }
			GReturn Waiting(unsigned int& _outCount) const override { return receiver.Waiting(_outCount); }
			GReturn Pop(GEvent& _outEvent) override { return receiver.Pop(_outEvent); }
			GReturn Peek(GEvent& _outEvent) const override { return receiver.Peek(_outEvent); }
			GReturn Missed(unsigned int& _outCount) const override { return receiver.Missed(_outCount); }
			GReturn Clear() override { return receiver.Clear(); }
			GReturn Invoke() const override { return receiver.Invoke(); }
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) { return receiver.Find(_check, _remove); }
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) { return receiver.Find(_check, _remove, _outData); }
		};
	}
}

#elif defined(_WIN32)
    #define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <gl/GL.h>
#ifndef __gl3_h_
#define __gl3_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#ifndef __gl3platform_h_
#define __gl3platform_h_

/*
** Copyright (c) 2017 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/* Platform-specific types and definitions for OpenGL ES 3.X  gl3.h
 *
 * Adopters may modify khrplatform.h and this file to suit their platform.
 * Please contribute modifications back to Khronos as pull requests on the
 * public github repository:
 *      https://github.com/KhronosGroup/OpenGL-Registry
 */

#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
*
* $Revision: 32517 $ on $Date: 2016-03-11 02:41:19 -0800 (Fri, 11 Mar 2016) $
*
* Adopters may modify this file to suit their platform. Adopters are
* encouraged to submit platform specific modifications to the Khronos
* group so that they can be included in future versions of this file.
* Please submit changes by sending them to the public Khronos Bugzilla
* (http://khronos.org/bugzilla) by filing a bug against product
* "Khronos (general)" component "Registry".
*
* A predefined template which fills in some of the bug fields can be
* reached using http://tinyurl.com/khrplatform-h-bugreport, but you
* must create a Bugzilla login first.
*
*
* See the Implementer's Guidelines for information about where this file
* should be located on your system and for more details of its use:
*    http://www.khronos.org/registry/implementers_guide.pdf
*
* This file should be included as
*        #include <KHR/khrplatform.h>
* by Khronos client API header files that use its types and defines.
*
* The types in khrplatform.h should only be used to define API-specific types.
*
* Types defined in khrplatform.h:
*    khronos_int8_t              signed   8  bit
*    khronos_uint8_t             unsigned 8  bit
*    khronos_int16_t             signed   16 bit
*    khronos_uint16_t            unsigned 16 bit
*    khronos_int32_t             signed   32 bit
*    khronos_uint32_t            unsigned 32 bit
*    khronos_int64_t             signed   64 bit
*    khronos_uint64_t            unsigned 64 bit
*    khronos_intptr_t            signed   same number of bits as a pointer
*    khronos_uintptr_t           unsigned same number of bits as a pointer
*    khronos_ssize_t             signed   size
*    khronos_usize_t             unsigned size
*    khronos_float_t             signed   32 bit floating point
*    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
*    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
*                                         nanoseconds
*    khronos_stime_nanoseconds_t signed time interval in nanoseconds
*    khronos_boolean_enum_t      enumerated boolean type. This should
*      only be used as a base type when a client API's boolean type is
*      an enum. Client APIs which use an integer or other type for
*      booleans cannot use this as the base type for their boolean.
*
* Tokens defined in khrplatform.h:
*
*    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
*
*    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
*    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
*
* Calling convention macros defined in this file:
*    KHRONOS_APICALL
*    KHRONOS_APIENTRY
*    KHRONOS_APIATTRIBUTES
*
* These may be used in function prototypes as:
*
*      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
*                                  int arg1,
*                                  int arg2) KHRONOS_APIATTRIBUTES;
*/

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APICALL
*-------------------------------------------------------------------------
* This precedes the return type of the function in the function prototype.
*/
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIENTRY
*-------------------------------------------------------------------------
* This follows the return type of the function  and precedes the function
* name in the function prototype.
*/
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
/* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIATTRIBUTES
*-------------------------------------------------------------------------
* This follows the closing parenthesis of the function prototype arguments.
*/
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
* basic type definitions
*-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
* Using <stdint.h>
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
* Using <inttypes.h>
*/
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
* Win32
*/
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
* Sun or Digital
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
* Hypothetical platform with no float or int64 support
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
* Generic fallback
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
* Types that are (so far) the same on all platforms
*/
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
* Types that differ between LLP64 and LP64 architectures - in LLP64,
* pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
* to be the only LLP64 architecture in current use.
*/
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
* Float type
*/
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
*
* These types can be used to represent a time interval in nanoseconds or
* an absolute Unadjusted System Time.  Unadjusted System Time is the number
* of nanoseconds since some arbitrary system event (e.g. since the last
* time the system booted).  The Unadjusted System Time is an unsigned
* 64 bit value that wraps back to 0 every 584 years.  Time intervals
* may be either signed or unsigned.
*/
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
* Dummy value used to pad enum types to 32 bits.
*/
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
* Enumerated boolean type
*
* Values other than zero should be considered to be true.  Therefore
* comparisons should not be made against KHRONOS_TRUE.
*/
typedef enum {
	KHRONOS_FALSE = 0,
	KHRONOS_TRUE = 1,
	KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */


#ifndef GL_APICALL
#define GL_APICALL  KHRONOS_APICALL
#endif

#ifndef GL_APIENTRY
#define GL_APIENTRY KHRONOS_APIENTRY
#endif

#endif /* __gl3platform_h_ */



#ifndef GL_APIENTRYP
#define GL_APIENTRYP GL_APIENTRY*
#endif

#ifndef GL_GLES_PROTOTYPES
#define GL_GLES_PROTOTYPES 1
#endif

/* Generated on date 20170926 */

/* Generated C header for:
 * API: gles2
 * Profile: common
 * Versions considered: 2\.[0-9]|3\.0
 * Versions emitted: .*
 * Default extensions included: None
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef GL_ES_VERSION_2_0
#define GL_ES_VERSION_2_0 1
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
*
* $Revision: 32517 $ on $Date: 2016-03-11 02:41:19 -0800 (Fri, 11 Mar 2016) $
*
* Adopters may modify this file to suit their platform. Adopters are
* encouraged to submit platform specific modifications to the Khronos
* group so that they can be included in future versions of this file.
* Please submit changes by sending them to the public Khronos Bugzilla
* (http://khronos.org/bugzilla) by filing a bug against product
* "Khronos (general)" component "Registry".
*
* A predefined template which fills in some of the bug fields can be
* reached using http://tinyurl.com/khrplatform-h-bugreport, but you
* must create a Bugzilla login first.
*
*
* See the Implementer's Guidelines for information about where this file
* should be located on your system and for more details of its use:
*    http://www.khronos.org/registry/implementers_guide.pdf
*
* This file should be included as
*        #include <KHR/khrplatform.h>
* by Khronos client API header files that use its types and defines.
*
* The types in khrplatform.h should only be used to define API-specific types.
*
* Types defined in khrplatform.h:
*    khronos_int8_t              signed   8  bit
*    khronos_uint8_t             unsigned 8  bit
*    khronos_int16_t             signed   16 bit
*    khronos_uint16_t            unsigned 16 bit
*    khronos_int32_t             signed   32 bit
*    khronos_uint32_t            unsigned 32 bit
*    khronos_int64_t             signed   64 bit
*    khronos_uint64_t            unsigned 64 bit
*    khronos_intptr_t            signed   same number of bits as a pointer
*    khronos_uintptr_t           unsigned same number of bits as a pointer
*    khronos_ssize_t             signed   size
*    khronos_usize_t             unsigned size
*    khronos_float_t             signed   32 bit floating point
*    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
*    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
*                                         nanoseconds
*    khronos_stime_nanoseconds_t signed time interval in nanoseconds
*    khronos_boolean_enum_t      enumerated boolean type. This should
*      only be used as a base type when a client API's boolean type is
*      an enum. Client APIs which use an integer or other type for
*      booleans cannot use this as the base type for their boolean.
*
* Tokens defined in khrplatform.h:
*
*    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
*
*    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
*    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
*
* Calling convention macros defined in this file:
*    KHRONOS_APICALL
*    KHRONOS_APIENTRY
*    KHRONOS_APIATTRIBUTES
*
* These may be used in function prototypes as:
*
*      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
*                                  int arg1,
*                                  int arg2) KHRONOS_APIATTRIBUTES;
*/

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APICALL
*-------------------------------------------------------------------------
* This precedes the return type of the function in the function prototype.
*/
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIENTRY
*-------------------------------------------------------------------------
* This follows the return type of the function  and precedes the function
* name in the function prototype.
*/
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
/* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIATTRIBUTES
*-------------------------------------------------------------------------
* This follows the closing parenthesis of the function prototype arguments.
*/
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
* basic type definitions
*-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
* Using <stdint.h>
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
* Using <inttypes.h>
*/
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
* Win32
*/
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
* Sun or Digital
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
* Hypothetical platform with no float or int64 support
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
* Generic fallback
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
* Types that are (so far) the same on all platforms
*/
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
* Types that differ between LLP64 and LP64 architectures - in LLP64,
* pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
* to be the only LLP64 architecture in current use.
*/
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
* Float type
*/
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
*
* These types can be used to represent a time interval in nanoseconds or
* an absolute Unadjusted System Time.  Unadjusted System Time is the number
* of nanoseconds since some arbitrary system event (e.g. since the last
* time the system booted).  The Unadjusted System Time is an unsigned
* 64 bit value that wraps back to 0 every 584 years.  Time intervals
* may be either signed or unsigned.
*/
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
* Dummy value used to pad enum types to 32 bits.
*/
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
* Enumerated boolean type
*
* Values other than zero should be considered to be true.  Therefore
* comparisons should not be made against KHRONOS_TRUE.
*/
typedef enum {
	KHRONOS_FALSE = 0,
	KHRONOS_TRUE = 1,
	KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

typedef khronos_int8_t GLbyte;
typedef khronos_float_t GLclampf;
typedef khronos_int32_t GLfixed;
typedef short GLshort;
typedef unsigned short GLushort;
typedef void GLvoid;
typedef struct __GLsync *GLsync;
typedef khronos_int64_t GLint64;
typedef khronos_uint64_t GLuint64;
typedef unsigned int GLenum;
typedef unsigned int GLuint;
typedef char GLchar;
typedef khronos_float_t GLfloat;
typedef khronos_ssize_t GLsizeiptr;
typedef khronos_intptr_t GLintptr;
typedef unsigned int GLbitfield;
typedef int GLint;
typedef unsigned char GLboolean;
typedef int GLsizei;
typedef khronos_uint8_t GLubyte;
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_FALSE                          0
#define GL_TRUE                           1
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
#define GL_FUNC_ADD                       0x8006
#define GL_BLEND_EQUATION                 0x8009
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_BLEND_EQUATION_ALPHA           0x883D
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_FUNC_REVERSE_SUBTRACT          0x800B
#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_BLEND_COLOR                    0x8005
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_ARRAY_BUFFER_BINDING           0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
#define GL_STREAM_DRAW                    0x88E0
#define GL_STATIC_DRAW                    0x88E4
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_BUFFER_SIZE                    0x8764
#define GL_BUFFER_USAGE                   0x8765
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_FRONT_AND_BACK                 0x0408
#define GL_TEXTURE_2D                     0x0DE1
#define GL_CULL_FACE                      0x0B44
#define GL_BLEND                          0x0BE2
#define GL_DITHER                         0x0BD0
#define GL_STENCIL_TEST                   0x0B90
#define GL_DEPTH_TEST                     0x0B71
#define GL_SCISSOR_TEST                   0x0C11
#define GL_POLYGON_OFFSET_FILL            0x8037
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_OUT_OF_MEMORY                  0x0505
#define GL_CW                             0x0900
#define GL_CCW                            0x0901
#define GL_LINE_WIDTH                     0x0B21
#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
#define GL_VIEWPORT                       0x0BA2
#define GL_SCISSOR_BOX                    0x0C10
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_TEXTURE_BINDING_2D             0x8069
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102
#define GL_GENERATE_MIPMAP_HINT           0x8192
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_FIXED                          0x140C
#define GL_DEPTH_COMPONENT                0x1902
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_MAX_VERTEX_UNIFORM_VECTORS     0x8DFB
#define GL_MAX_VARYING_VECTORS            0x8DFC
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS   0x8DFD
#define GL_SHADER_TYPE                    0x8B4F
#define GL_DELETE_STATUS                  0x8B80
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
#define GL_INVERT                         0x150A
#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
#define GL_TEXTURE                        0x1702
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_REPEAT                         0x2901
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_MIRRORED_REPEAT                0x8370
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_COMPILE_STATUS                 0x8B81
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_SHADER_COMPILER                0x8DFA
#define GL_SHADER_BINARY_FORMATS          0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
#define GL_LOW_FLOAT                      0x8DF0
#define GL_MEDIUM_FLOAT                   0x8DF1
#define GL_HIGH_FLOAT                     0x8DF2
#define GL_LOW_INT                        0x8DF3
#define GL_MEDIUM_INT                     0x8DF4
#define GL_HIGH_INT                       0x8DF5
#define GL_FRAMEBUFFER                    0x8D40
#define GL_RENDERBUFFER                   0x8D41
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGB565                         0x8D62
#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_STENCIL_INDEX8                 0x8D48
#define GL_RENDERBUFFER_WIDTH             0x8D42
#define GL_RENDERBUFFER_HEIGHT            0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
#define GL_RENDERBUFFER_RED_SIZE          0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_NONE                           0
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS 0x8CD9
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_FRAMEBUFFER_BINDING            0x8CA6
#define GL_RENDERBUFFER_BINDING           0x8CA7
#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
typedef void (GL_APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (GL_APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (GL_APIENTRYP PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (GL_APIENTRYP PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (GL_APIENTRYP PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (GL_APIENTRYP PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
typedef void (GL_APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (GL_APIENTRYP PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
typedef void (GL_APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GL_APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
typedef void (GL_APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
typedef GLenum (GL_APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLCLEARPROC) (GLbitfield mask);
typedef void (GL_APIENTRYP PFNGLCLEARCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GL_APIENTRYP PFNGLCLEARDEPTHFPROC) (GLfloat d);
typedef void (GL_APIENTRYP PFNGLCLEARSTENCILPROC) (GLint s);
typedef void (GL_APIENTRYP PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (GL_APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOPYTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GL_APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef GLuint (GL_APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (GL_APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
typedef void (GL_APIENTRYP PFNGLCULLFACEPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void (GL_APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint *framebuffers);
typedef void (GL_APIENTRYP PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void (GL_APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (GL_APIENTRYP PFNGLDELETETEXTURESPROC) (GLsizei n, const GLuint *textures);
typedef void (GL_APIENTRYP PFNGLDEPTHFUNCPROC) (GLenum func);
typedef void (GL_APIENTRYP PFNGLDEPTHMASKPROC) (GLboolean flag);
typedef void (GL_APIENTRYP PFNGLDEPTHRANGEFPROC) (GLfloat n, GLfloat f);
typedef void (GL_APIENTRYP PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (GL_APIENTRYP PFNGLDISABLEPROC) (GLenum cap);
typedef void (GL_APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (GL_APIENTRYP PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices);
typedef void (GL_APIENTRYP PFNGLENABLEPROC) (GLenum cap);
typedef void (GL_APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (GL_APIENTRYP PFNGLFINISHPROC) (void);
typedef void (GL_APIENTRYP PFNGLFLUSHPROC) (void);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GL_APIENTRYP PFNGLFRONTFACEPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef void (GL_APIENTRYP PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint *framebuffers);
typedef void (GL_APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
typedef void (GL_APIENTRYP PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
typedef void (GL_APIENTRYP PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
typedef GLint (GL_APIENTRYP PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETBOOLEANVPROC) (GLenum pname, GLboolean *data);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLenum (GL_APIENTRYP PFNGLGETERRORPROC) (void);
typedef void (GL_APIENTRYP PFNGLGETFLOATVPROC) (GLenum pname, GLfloat *data);
typedef void (GL_APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETINTEGERVPROC) (GLenum pname, GLint *data);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (GL_APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (GL_APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
typedef void (GL_APIENTRYP PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef const GLubyte *(GL_APIENTRYP PFNGLGETSTRINGPROC) (GLenum name);
typedef void (GL_APIENTRYP PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef GLint (GL_APIENTRYP PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void **pointer);
typedef void (GL_APIENTRYP PFNGLHINTPROC) (GLenum target, GLenum mode);
typedef GLboolean (GL_APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (GL_APIENTRYP PFNGLISENABLEDPROC) (GLenum cap);
typedef GLboolean (GL_APIENTRYP PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (GL_APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (GL_APIENTRYP PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef GLboolean (GL_APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
typedef GLboolean (GL_APIENTRYP PFNGLISTEXTUREPROC) (GLuint texture);
typedef void (GL_APIENTRYP PFNGLLINEWIDTHPROC) (GLfloat width);
typedef void (GL_APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat units);
typedef void (GL_APIENTRYP PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
typedef void (GL_APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLfloat value, GLboolean invert);
typedef void (GL_APIENTRYP PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
typedef void (GL_APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
typedef void (GL_APIENTRYP PFNGLSTENCILFUNCPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILMASKPROC) (GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILOPPROC) (GLenum fail, GLenum zfail, GLenum zpass);
typedef void (GL_APIENTRYP PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GL_APIENTRYP PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (GL_APIENTRYP PFNGLTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
typedef void (GL_APIENTRYP PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
#if GL_GLES_PROTOTYPES
GL_APICALL void GL_APIENTRY glActiveTexture (GLenum texture);
GL_APICALL void GL_APIENTRY glAttachShader (GLuint program, GLuint shader);
GL_APICALL void GL_APIENTRY glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
GL_APICALL void GL_APIENTRY glBindBuffer (GLenum target, GLuint buffer);
GL_APICALL void GL_APIENTRY glBindFramebuffer (GLenum target, GLuint framebuffer);
GL_APICALL void GL_APIENTRY glBindRenderbuffer (GLenum target, GLuint renderbuffer);
GL_APICALL void GL_APIENTRY glBindTexture (GLenum target, GLuint texture);
GL_APICALL void GL_APIENTRY glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GL_APICALL void GL_APIENTRY glBlendEquation (GLenum mode);
GL_APICALL void GL_APIENTRY glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
GL_APICALL void GL_APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
GL_APICALL void GL_APIENTRY glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
GL_APICALL void GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
GL_APICALL void GL_APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
GL_APICALL GLenum GL_APIENTRY glCheckFramebufferStatus (GLenum target);
GL_APICALL void GL_APIENTRY glClear (GLbitfield mask);
GL_APICALL void GL_APIENTRY glClearColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GL_APICALL void GL_APIENTRY glClearDepthf (GLfloat d);
GL_APICALL void GL_APIENTRY glClearStencil (GLint s);
GL_APICALL void GL_APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
GL_APICALL void GL_APIENTRY glCompileShader (GLuint shader);
GL_APICALL void GL_APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GL_APICALL void GL_APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL GLuint GL_APIENTRY glCreateProgram (void);
GL_APICALL GLuint GL_APIENTRY glCreateShader (GLenum type);
GL_APICALL void GL_APIENTRY glCullFace (GLenum mode);
GL_APICALL void GL_APIENTRY glDeleteBuffers (GLsizei n, const GLuint *buffers);
GL_APICALL void GL_APIENTRY glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers);
GL_APICALL void GL_APIENTRY glDeleteProgram (GLuint program);
GL_APICALL void GL_APIENTRY glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers);
GL_APICALL void GL_APIENTRY glDeleteShader (GLuint shader);
GL_APICALL void GL_APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
GL_APICALL void GL_APIENTRY glDepthFunc (GLenum func);
GL_APICALL void GL_APIENTRY glDepthMask (GLboolean flag);
GL_APICALL void GL_APIENTRY glDepthRangef (GLfloat n, GLfloat f);
GL_APICALL void GL_APIENTRY glDetachShader (GLuint program, GLuint shader);
GL_APICALL void GL_APIENTRY glDisable (GLenum cap);
GL_APICALL void GL_APIENTRY glDisableVertexAttribArray (GLuint index);
GL_APICALL void GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
GL_APICALL void GL_APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
GL_APICALL void GL_APIENTRY glEnable (GLenum cap);
GL_APICALL void GL_APIENTRY glEnableVertexAttribArray (GLuint index);
GL_APICALL void GL_APIENTRY glFinish (void);
GL_APICALL void GL_APIENTRY glFlush (void);
GL_APICALL void GL_APIENTRY glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GL_APICALL void GL_APIENTRY glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_APICALL void GL_APIENTRY glFrontFace (GLenum mode);
GL_APICALL void GL_APIENTRY glGenBuffers (GLsizei n, GLuint *buffers);
GL_APICALL void GL_APIENTRY glGenerateMipmap (GLenum target);
GL_APICALL void GL_APIENTRY glGenFramebuffers (GLsizei n, GLuint *framebuffers);
GL_APICALL void GL_APIENTRY glGenRenderbuffers (GLsizei n, GLuint *renderbuffers);
GL_APICALL void GL_APIENTRY glGenTextures (GLsizei n, GLuint *textures);
GL_APICALL void GL_APIENTRY glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GL_APICALL GLint GL_APIENTRY glGetAttribLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glGetBooleanv (GLenum pname, GLboolean *data);
GL_APICALL void GL_APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL GLenum GL_APIENTRY glGetError (void);
GL_APICALL void GL_APIENTRY glGetFloatv (GLenum pname, GLfloat *data);
GL_APICALL void GL_APIENTRY glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetIntegerv (GLenum pname, GLint *data);
GL_APICALL void GL_APIENTRY glGetProgramiv (GLuint program, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_APICALL void GL_APIENTRY glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_APICALL void GL_APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
GL_APICALL void GL_APIENTRY glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GL_APICALL const GLubyte *GL_APIENTRY glGetString (GLenum name);
GL_APICALL void GL_APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetUniformfv (GLuint program, GLint location, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetUniformiv (GLuint program, GLint location, GLint *params);
GL_APICALL GLint GL_APIENTRY glGetUniformLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, void **pointer);
GL_APICALL void GL_APIENTRY glHint (GLenum target, GLenum mode);
GL_APICALL GLboolean GL_APIENTRY glIsBuffer (GLuint buffer);
GL_APICALL GLboolean GL_APIENTRY glIsEnabled (GLenum cap);
GL_APICALL GLboolean GL_APIENTRY glIsFramebuffer (GLuint framebuffer);
GL_APICALL GLboolean GL_APIENTRY glIsProgram (GLuint program);
GL_APICALL GLboolean GL_APIENTRY glIsRenderbuffer (GLuint renderbuffer);
GL_APICALL GLboolean GL_APIENTRY glIsShader (GLuint shader);
GL_APICALL GLboolean GL_APIENTRY glIsTexture (GLuint texture);
GL_APICALL void GL_APIENTRY glLineWidth (GLfloat width);
GL_APICALL void GL_APIENTRY glLinkProgram (GLuint program);
GL_APICALL void GL_APIENTRY glPixelStorei (GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
GL_APICALL void GL_APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
GL_APICALL void GL_APIENTRY glReleaseShaderCompiler (void);
GL_APICALL void GL_APIENTRY glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glSampleCoverage (GLfloat value, GLboolean invert);
GL_APICALL void GL_APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
GL_APICALL void GL_APIENTRY glShaderSource (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
GL_APICALL void GL_APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilMask (GLuint mask);
GL_APICALL void GL_APIENTRY glStencilMaskSeparate (GLenum face, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
GL_APICALL void GL_APIENTRY glStencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GL_APICALL void GL_APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
GL_APICALL void GL_APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
GL_APICALL void GL_APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
GL_APICALL void GL_APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glUniform1f (GLint location, GLfloat v0);
GL_APICALL void GL_APIENTRY glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform1i (GLint location, GLint v0);
GL_APICALL void GL_APIENTRY glUniform1iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform2f (GLint location, GLfloat v0, GLfloat v1);
GL_APICALL void GL_APIENTRY glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform2i (GLint location, GLint v0, GLint v1);
GL_APICALL void GL_APIENTRY glUniform2iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_APICALL void GL_APIENTRY glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
GL_APICALL void GL_APIENTRY glUniform3iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_APICALL void GL_APIENTRY glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_APICALL void GL_APIENTRY glUniform4iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUseProgram (GLuint program);
GL_APICALL void GL_APIENTRY glValidateProgram (GLuint program);
GL_APICALL void GL_APIENTRY glVertexAttrib1f (GLuint index, GLfloat x);
GL_APICALL void GL_APIENTRY glVertexAttrib1fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
GL_APICALL void GL_APIENTRY glVertexAttrib2fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
GL_APICALL void GL_APIENTRY glVertexAttrib3fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
GL_APICALL void GL_APIENTRY glVertexAttrib4fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
GL_APICALL void GL_APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
#endif
#endif /* GL_ES_VERSION_2_0 */

#ifndef GL_ES_VERSION_3_0
#define GL_ES_VERSION_3_0 1
typedef unsigned short GLhalf;
#define GL_READ_BUFFER                    0x0C02
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802
#define GL_RED                            0x1903
#define GL_RGB8                           0x8051
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_TEXTURE_BINDING_3D             0x806A
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_BUFFER_MAPPED                  0x88BC
#define GL_BUFFER_MAP_POINTER             0x88BD
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_COMPARE_REF_TO_TEXTURE         0x884E
#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C
#define GL_NUM_EXTENSIONS                 0x821D
#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER    0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS       0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET       0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET       0x8905
#define GL_MAX_VARYING_COMPONENTS         0x8B4B
#define GL_TEXTURE_2D_ARRAY               0x8C1A
#define GL_TEXTURE_BINDING_2D_ARRAY       0x8C1D
#define GL_R11F_G11F_B10F                 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV   0x8C3B
#define GL_RGB9_E5                        0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV       0x8C3E
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS    0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD             0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS            0x8C8C
#define GL_SEPARATE_ATTRIBS               0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER      0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F
#define GL_RED_INTEGER                    0x8D94
#define GL_RGB_INTEGER                    0x8D98
#define GL_RGBA_INTEGER                   0x8D99
#define GL_SAMPLER_2D_ARRAY               0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW        0x8DC4
#define GL_SAMPLER_CUBE_SHADOW            0x8DC5
#define GL_UNSIGNED_INT_VEC2              0x8DC6
#define GL_UNSIGNED_INT_VEC3              0x8DC7
#define GL_UNSIGNED_INT_VEC4              0x8DC8
#define GL_INT_SAMPLER_2D                 0x8DCA
#define GL_INT_SAMPLER_3D                 0x8DCB
#define GL_INT_SAMPLER_CUBE               0x8DCC
#define GL_INT_SAMPLER_2D_ARRAY           0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_2D        0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D        0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE      0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  0x8DD7
#define GL_BUFFER_ACCESS_FLAGS            0x911F
#define GL_BUFFER_MAP_LENGTH              0x9120
#define GL_BUFFER_MAP_OFFSET              0x9121
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH32F_STENCIL8              0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT            0x8218
#define GL_FRAMEBUFFER_UNDEFINED          0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A
#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA
#define GL_DEPTH24_STENCIL8               0x88F0
#define GL_UNSIGNED_NORMALIZED            0x8C17
#define GL_DRAW_FRAMEBUFFER_BINDING       0x8CA6
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING       0x8CAA
#define GL_RENDERBUFFER_SAMPLES           0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES                    0x8D57
#define GL_HALF_FLOAT                     0x140B
#define GL_MAP_READ_BIT                   0x0001
#define GL_MAP_WRITE_BIT                  0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT       0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT      0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT         0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
#define GL_RG                             0x8227
#define GL_RG_INTEGER                     0x8228
#define GL_R8                             0x8229
#define GL_RG8                            0x822B
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C
#define GL_VERTEX_ARRAY_BINDING           0x85B5
#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_SIGNED_NORMALIZED              0x8F9C
#define GL_PRIMITIVE_RESTART_FIXED_INDEX  0x8D69
#define GL_COPY_READ_BUFFER               0x8F36
#define GL_COPY_WRITE_BUFFER              0x8F37
#define GL_COPY_READ_BUFFER_BINDING       0x8F36
#define GL_COPY_WRITE_BUFFER_BINDING      0x8F37
#define GL_UNIFORM_BUFFER                 0x8A11
#define GL_UNIFORM_BUFFER_BINDING         0x8A28
#define GL_UNIFORM_BUFFER_START           0x8A29
#define GL_UNIFORM_BUFFER_SIZE            0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS      0x8A2B
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS    0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS    0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS    0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE         0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS          0x8A36
#define GL_UNIFORM_TYPE                   0x8A37
#define GL_UNIFORM_SIZE                   0x8A38
#define GL_UNIFORM_NAME_LENGTH            0x8A39
#define GL_UNIFORM_BLOCK_INDEX            0x8A3A
#define GL_UNIFORM_OFFSET                 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE           0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE          0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR           0x8A3E
#define GL_UNIFORM_BLOCK_BINDING          0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE        0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH      0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX                  0xFFFFFFFFu
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS   0x9122
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS  0x9125
#define GL_MAX_SERVER_WAIT_TIMEOUT        0x9111
#define GL_OBJECT_TYPE                    0x9112
#define GL_SYNC_CONDITION                 0x9113
#define GL_SYNC_STATUS                    0x9114
#define GL_SYNC_FLAGS                     0x9115
#define GL_SYNC_FENCE                     0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE     0x9117
#define GL_UNSIGNALED                     0x9118
#define GL_SIGNALED                       0x9119
#define GL_ALREADY_SIGNALED               0x911A
#define GL_TIMEOUT_EXPIRED                0x911B
#define GL_CONDITION_SATISFIED            0x911C
#define GL_WAIT_FAILED                    0x911D
#define GL_SYNC_FLUSH_COMMANDS_BIT        0x00000001
#define GL_TIMEOUT_IGNORED                0xFFFFFFFFFFFFFFFFull
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR    0x88FE
#define GL_ANY_SAMPLES_PASSED             0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_SAMPLER_BINDING                0x8919
#define GL_RGB10_A2UI                     0x906F
#define GL_TEXTURE_SWIZZLE_R              0x8E42
#define GL_TEXTURE_SWIZZLE_G              0x8E43
#define GL_TEXTURE_SWIZZLE_B              0x8E44
#define GL_TEXTURE_SWIZZLE_A              0x8E45
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_INT_2_10_10_10_REV             0x8D9F
#define GL_TRANSFORM_FEEDBACK             0x8E22
#define GL_TRANSFORM_FEEDBACK_PAUSED      0x8E23
#define GL_TRANSFORM_FEEDBACK_ACTIVE      0x8E24
#define GL_TRANSFORM_FEEDBACK_BINDING     0x8E25
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH          0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS     0x87FE
#define GL_PROGRAM_BINARY_FORMATS         0x87FF
#define GL_COMPRESSED_R11_EAC             0x9270
#define GL_COMPRESSED_SIGNED_R11_EAC      0x9271
#define GL_COMPRESSED_RG11_EAC            0x9272
#define GL_COMPRESSED_SIGNED_RG11_EAC     0x9273
#define GL_COMPRESSED_RGB8_ETC2           0x9274
#define GL_COMPRESSED_SRGB8_ETC2          0x9275
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_RGBA8_ETC2_EAC      0x9278
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_TEXTURE_IMMUTABLE_FORMAT       0x912F
#define GL_MAX_ELEMENT_INDEX              0x8D6B
#define GL_NUM_SAMPLE_COUNTS              0x9380
#define GL_TEXTURE_IMMUTABLE_LEVELS       0x82DF
typedef void (GL_APIENTRYP PFNGLREADBUFFERPROC) (GLenum src);
typedef void (GL_APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void (GL_APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void (GL_APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean (GL_APIENTRYP PFNGLISQUERYPROC) (GLuint id);
typedef void (GL_APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (GL_APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef GLboolean (GL_APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void **params);
typedef void (GL_APIENTRYP PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void *(GL_APIENTRYP PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (GL_APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (GL_APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (GL_APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);
typedef void (GL_APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean (GL_APIENTRYP PFNGLISVERTEXARRAYPROC) (GLuint array);
typedef void (GL_APIENTRYP PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint *data);
typedef void (GL_APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (GL_APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (GL_APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
typedef void (GL_APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint *v);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint *params);
typedef GLint (GL_APIENTRYP PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef const GLubyte *(GL_APIENTRYP PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void (GL_APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
typedef GLuint (GL_APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar *uniformBlockName);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
typedef void (GL_APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (GL_APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
typedef GLsync (GL_APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
typedef GLboolean (GL_APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
typedef void (GL_APIENTRYP PFNGLDELETESYNCPROC) (GLsync sync);
typedef GLenum (GL_APIENTRYP PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GL_APIENTRYP PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GL_APIENTRYP PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64 *data);
typedef void (GL_APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
typedef void (GL_APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
typedef void (GL_APIENTRYP PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint *samplers);
typedef void (GL_APIENTRYP PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint *samplers);
typedef GLboolean (GL_APIENTRYP PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (GL_APIENTRYP PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat *param);
typedef void (GL_APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
typedef void (GL_APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (GL_APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint *ids);
typedef void (GL_APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint *ids);
typedef GLboolean (GL_APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (GL_APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
typedef void (GL_APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void (GL_APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
typedef void (GL_APIENTRYP PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments);
typedef void (GL_APIENTRYP PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GL_APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#if GL_GLES_PROTOTYPES
GL_APICALL void GL_APIENTRY glReadBuffer (GLenum src);
GL_APICALL void GL_APIENTRY glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
GL_APICALL void GL_APIENTRY glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glGenQueries (GLsizei n, GLuint *ids);
GL_APICALL void GL_APIENTRY glDeleteQueries (GLsizei n, const GLuint *ids);
GL_APICALL GLboolean GL_APIENTRY glIsQuery (GLuint id);
GL_APICALL void GL_APIENTRY glBeginQuery (GLenum target, GLuint id);
GL_APICALL void GL_APIENTRY glEndQuery (GLenum target);
GL_APICALL void GL_APIENTRY glGetQueryiv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);
GL_APICALL GLboolean GL_APIENTRY glUnmapBuffer (GLenum target);
GL_APICALL void GL_APIENTRY glGetBufferPointerv (GLenum target, GLenum pname, void **params);
GL_APICALL void GL_APIENTRY glDrawBuffers (GLsizei n, const GLenum *bufs);
GL_APICALL void GL_APIENTRY glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GL_APICALL void GL_APIENTRY glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
GL_APICALL void *GL_APIENTRY glMapBufferRange (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GL_APICALL void GL_APIENTRY glFlushMappedBufferRange (GLenum target, GLintptr offset, GLsizeiptr length);
GL_APICALL void GL_APIENTRY glBindVertexArray (GLuint array);
GL_APICALL void GL_APIENTRY glDeleteVertexArrays (GLsizei n, const GLuint *arrays);
GL_APICALL void GL_APIENTRY glGenVertexArrays (GLsizei n, GLuint *arrays);
GL_APICALL GLboolean GL_APIENTRY glIsVertexArray (GLuint array);
GL_APICALL void GL_APIENTRY glGetIntegeri_v (GLenum target, GLuint index, GLint *data);
GL_APICALL void GL_APIENTRY glBeginTransformFeedback (GLenum primitiveMode);
GL_APICALL void GL_APIENTRY glEndTransformFeedback (void);
GL_APICALL void GL_APIENTRY glBindBufferRange (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GL_APICALL void GL_APIENTRY glBindBufferBase (GLenum target, GLuint index, GLuint buffer);
GL_APICALL void GL_APIENTRY glTransformFeedbackVaryings (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
GL_APICALL void GL_APIENTRY glGetTransformFeedbackVarying (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
GL_APICALL void GL_APIENTRY glGetVertexAttribIiv (GLuint index, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint *params);
GL_APICALL void GL_APIENTRY glVertexAttribI4i (GLuint index, GLint x, GLint y, GLint z, GLint w);
GL_APICALL void GL_APIENTRY glVertexAttribI4ui (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
GL_APICALL void GL_APIENTRY glVertexAttribI4iv (GLuint index, const GLint *v);
GL_APICALL void GL_APIENTRY glVertexAttribI4uiv (GLuint index, const GLuint *v);
GL_APICALL void GL_APIENTRY glGetUniformuiv (GLuint program, GLint location, GLuint *params);
GL_APICALL GLint GL_APIENTRY glGetFragDataLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glUniform1ui (GLint location, GLuint v0);
GL_APICALL void GL_APIENTRY glUniform2ui (GLint location, GLuint v0, GLuint v1);
GL_APICALL void GL_APIENTRY glUniform3ui (GLint location, GLuint v0, GLuint v1, GLuint v2);
GL_APICALL void GL_APIENTRY glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_APICALL void GL_APIENTRY glUniform1uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform2uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform3uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform4uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glClearBufferiv (GLenum buffer, GLint drawbuffer, const GLint *value);
GL_APICALL void GL_APIENTRY glClearBufferuiv (GLenum buffer, GLint drawbuffer, const GLuint *value);
GL_APICALL void GL_APIENTRY glClearBufferfv (GLenum buffer, GLint drawbuffer, const GLfloat *value);
GL_APICALL void GL_APIENTRY glClearBufferfi (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
GL_APICALL const GLubyte *GL_APIENTRY glGetStringi (GLenum name, GLuint index);
GL_APICALL void GL_APIENTRY glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
GL_APICALL void GL_APIENTRY glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
GL_APICALL void GL_APIENTRY glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GL_APICALL GLuint GL_APIENTRY glGetUniformBlockIndex (GLuint program, const GLchar *uniformBlockName);
GL_APICALL void GL_APIENTRY glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetActiveUniformBlockName (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GL_APICALL void GL_APIENTRY glUniformBlockBinding (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
GL_APICALL void GL_APIENTRY glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
GL_APICALL void GL_APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
GL_APICALL GLsync GL_APIENTRY glFenceSync (GLenum condition, GLbitfield flags);
GL_APICALL GLboolean GL_APIENTRY glIsSync (GLsync sync);
GL_APICALL void GL_APIENTRY glDeleteSync (GLsync sync);
GL_APICALL GLenum GL_APIENTRY glClientWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_APICALL void GL_APIENTRY glWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_APICALL void GL_APIENTRY glGetInteger64v (GLenum pname, GLint64 *data);
GL_APICALL void GL_APIENTRY glGetSynciv (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
GL_APICALL void GL_APIENTRY glGetInteger64i_v (GLenum target, GLuint index, GLint64 *data);
GL_APICALL void GL_APIENTRY glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 *params);
GL_APICALL void GL_APIENTRY glGenSamplers (GLsizei count, GLuint *samplers);
GL_APICALL void GL_APIENTRY glDeleteSamplers (GLsizei count, const GLuint *samplers);
GL_APICALL GLboolean GL_APIENTRY glIsSampler (GLuint sampler);
GL_APICALL void GL_APIENTRY glBindSampler (GLuint unit, GLuint sampler);
GL_APICALL void GL_APIENTRY glSamplerParameteri (GLuint sampler, GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glSamplerParameteriv (GLuint sampler, GLenum pname, const GLint *param);
GL_APICALL void GL_APIENTRY glSamplerParameterf (GLuint sampler, GLenum pname, GLfloat param);
GL_APICALL void GL_APIENTRY glSamplerParameterfv (GLuint sampler, GLenum pname, const GLfloat *param);
GL_APICALL void GL_APIENTRY glGetSamplerParameteriv (GLuint sampler, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetSamplerParameterfv (GLuint sampler, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glVertexAttribDivisor (GLuint index, GLuint divisor);
GL_APICALL void GL_APIENTRY glBindTransformFeedback (GLenum target, GLuint id);
GL_APICALL void GL_APIENTRY glDeleteTransformFeedbacks (GLsizei n, const GLuint *ids);
GL_APICALL void GL_APIENTRY glGenTransformFeedbacks (GLsizei n, GLuint *ids);
GL_APICALL GLboolean GL_APIENTRY glIsTransformFeedback (GLuint id);
GL_APICALL void GL_APIENTRY glPauseTransformFeedback (void);
GL_APICALL void GL_APIENTRY glResumeTransformFeedback (void);
GL_APICALL void GL_APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
GL_APICALL void GL_APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
GL_APICALL void GL_APIENTRY glProgramParameteri (GLuint program, GLenum pname, GLint value);
GL_APICALL void GL_APIENTRY glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments);
GL_APICALL void GL_APIENTRY glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glTexStorage2D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glTexStorage3D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GL_APICALL void GL_APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif
#endif /* GL_ES_VERSION_3_0 */

#ifdef __cplusplus
}
#endif

#endif


#ifndef __wgl_h_
#define __wgl_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif

/* Generated on date 20170121 */

/* Generated C header for:
 * API: wgl
 * Versions considered: .*
 * Versions emitted: .*
 * Default extensions included: wgl
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef WGL_VERSION_1_0
#define WGL_VERSION_1_0 1
#define WGL_FONT_LINES                    0
#define WGL_FONT_POLYGONS                 1
#define WGL_SWAP_MAIN_PLANE               0x00000001
#define WGL_SWAP_OVERLAY1                 0x00000002
#define WGL_SWAP_OVERLAY2                 0x00000004
#define WGL_SWAP_OVERLAY3                 0x00000008
#define WGL_SWAP_OVERLAY4                 0x00000010
#define WGL_SWAP_OVERLAY5                 0x00000020
#define WGL_SWAP_OVERLAY6                 0x00000040
#define WGL_SWAP_OVERLAY7                 0x00000080
#define WGL_SWAP_OVERLAY8                 0x00000100
#define WGL_SWAP_OVERLAY9                 0x00000200
#define WGL_SWAP_OVERLAY10                0x00000400
#define WGL_SWAP_OVERLAY11                0x00000800
#define WGL_SWAP_OVERLAY12                0x00001000
#define WGL_SWAP_OVERLAY13                0x00002000
#define WGL_SWAP_OVERLAY14                0x00004000
#define WGL_SWAP_OVERLAY15                0x00008000
#define WGL_SWAP_UNDERLAY1                0x00010000
#define WGL_SWAP_UNDERLAY2                0x00020000
#define WGL_SWAP_UNDERLAY3                0x00040000
#define WGL_SWAP_UNDERLAY4                0x00080000
#define WGL_SWAP_UNDERLAY5                0x00100000
#define WGL_SWAP_UNDERLAY6                0x00200000
#define WGL_SWAP_UNDERLAY7                0x00400000
#define WGL_SWAP_UNDERLAY8                0x00800000
#define WGL_SWAP_UNDERLAY9                0x01000000
#define WGL_SWAP_UNDERLAY10               0x02000000
#define WGL_SWAP_UNDERLAY11               0x04000000
#define WGL_SWAP_UNDERLAY12               0x08000000
#define WGL_SWAP_UNDERLAY13               0x10000000
#define WGL_SWAP_UNDERLAY14               0x20000000
#define WGL_SWAP_UNDERLAY15               0x40000000
typedef int (WINAPI * PFNCHOOSEPIXELFORMATPROC) (HDC hDc, const PIXELFORMATDESCRIPTOR *pPfd);
typedef int (WINAPI * PFNDESCRIBEPIXELFORMATPROC) (HDC hdc, int ipfd, UINT cjpfd, const PIXELFORMATDESCRIPTOR *ppfd);
typedef UINT (WINAPI * PFNGETENHMETAFILEPIXELFORMATPROC) (HENHMETAFILE hemf, const PIXELFORMATDESCRIPTOR *ppfd);
typedef int (WINAPI * PFNGETPIXELFORMATPROC) (HDC hdc);
typedef BOOL (WINAPI * PFNSETPIXELFORMATPROC) (HDC hdc, int ipfd, const PIXELFORMATDESCRIPTOR *ppfd);
typedef BOOL (WINAPI * PFNSWAPBUFFERSPROC) (HDC hdc);
typedef BOOL (WINAPI * PFNWGLCOPYCONTEXTPROC) (HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
typedef HGLRC (WINAPI * PFNWGLCREATECONTEXTPROC) (HDC hDc);
typedef HGLRC (WINAPI * PFNWGLCREATELAYERCONTEXTPROC) (HDC hDc, int level);
typedef BOOL (WINAPI * PFNWGLDELETECONTEXTPROC) (HGLRC oldContext);
typedef BOOL (WINAPI * PFNWGLDESCRIBELAYERPLANEPROC) (HDC hDc, int pixelFormat, int layerPlane, UINT nBytes, const LAYERPLANEDESCRIPTOR *plpd);
typedef HGLRC (WINAPI * PFNWGLGETCURRENTCONTEXTPROC) (void);
typedef HDC (WINAPI * PFNWGLGETCURRENTDCPROC) (void);
typedef int (WINAPI * PFNWGLGETLAYERPALETTEENTRIESPROC) (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
typedef PROC (WINAPI * PFNWGLGETPROCADDRESSPROC) (LPCSTR lpszProc);
typedef BOOL (WINAPI * PFNWGLMAKECURRENTPROC) (HDC hDc, HGLRC newContext);
typedef BOOL (WINAPI * PFNWGLREALIZELAYERPALETTEPROC) (HDC hdc, int iLayerPlane, BOOL bRealize);
typedef int (WINAPI * PFNWGLSETLAYERPALETTEENTRIESPROC) (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
typedef BOOL (WINAPI * PFNWGLSHARELISTSPROC) (HGLRC hrcSrvShare, HGLRC hrcSrvSource);
typedef BOOL (WINAPI * PFNWGLSWAPLAYERBUFFERSPROC) (HDC hdc, UINT fuFlags);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSAPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSWPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESAPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESWPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
#ifdef WGL_WGLEXT_PROTOTYPES
int WINAPI ChoosePixelFormat (HDC hDc, const PIXELFORMATDESCRIPTOR *pPfd);
int WINAPI DescribePixelFormat (HDC hdc, int ipfd, UINT cjpfd, const PIXELFORMATDESCRIPTOR *ppfd);
UINT WINAPI GetEnhMetaFilePixelFormat (HENHMETAFILE hemf, const PIXELFORMATDESCRIPTOR *ppfd);
int WINAPI GetPixelFormat (HDC hdc);
BOOL WINAPI SetPixelFormat (HDC hdc, int ipfd, const PIXELFORMATDESCRIPTOR *ppfd);
BOOL WINAPI SwapBuffers (HDC hdc);
BOOL WINAPI wglCopyContext (HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
HGLRC WINAPI wglCreateContext (HDC hDc);
HGLRC WINAPI wglCreateLayerContext (HDC hDc, int level);
BOOL WINAPI wglDeleteContext (HGLRC oldContext);
BOOL WINAPI wglDescribeLayerPlane (HDC hDc, int pixelFormat, int layerPlane, UINT nBytes, const LAYERPLANEDESCRIPTOR *plpd);
HGLRC WINAPI wglGetCurrentContext (void);
HDC WINAPI wglGetCurrentDC (void);
int WINAPI wglGetLayerPaletteEntries (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
PROC WINAPI wglGetProcAddress (LPCSTR lpszProc);
BOOL WINAPI wglMakeCurrent (HDC hDc, HGLRC newContext);
BOOL WINAPI wglRealizeLayerPalette (HDC hdc, int iLayerPlane, BOOL bRealize);
int WINAPI wglSetLayerPaletteEntries (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
BOOL WINAPI wglShareLists (HGLRC hrcSrvShare, HGLRC hrcSrvSource);
BOOL WINAPI wglSwapLayerBuffers (HDC hdc, UINT fuFlags);
BOOL WINAPI wglUseFontBitmaps (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontBitmapsA (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontBitmapsW (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontOutlines (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
BOOL WINAPI wglUseFontOutlinesA (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
BOOL WINAPI wglUseFontOutlinesW (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
#endif
#endif /* WGL_VERSION_1_0 */

#ifndef WGL_ARB_buffer_region
#define WGL_ARB_buffer_region 1
#define WGL_FRONT_COLOR_BUFFER_BIT_ARB    0x00000001
#define WGL_BACK_COLOR_BUFFER_BIT_ARB     0x00000002
#define WGL_DEPTH_BUFFER_BIT_ARB          0x00000004
#define WGL_STENCIL_BUFFER_BIT_ARB        0x00000008
typedef HANDLE (WINAPI * PFNWGLCREATEBUFFERREGIONARBPROC) (HDC hDC, int iLayerPlane, UINT uType);
typedef VOID (WINAPI * PFNWGLDELETEBUFFERREGIONARBPROC) (HANDLE hRegion);
typedef BOOL (WINAPI * PFNWGLSAVEBUFFERREGIONARBPROC) (HANDLE hRegion, int x, int y, int width, int height);
typedef BOOL (WINAPI * PFNWGLRESTOREBUFFERREGIONARBPROC) (HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
#ifdef WGL_WGLEXT_PROTOTYPES
HANDLE WINAPI wglCreateBufferRegionARB (HDC hDC, int iLayerPlane, UINT uType);
VOID WINAPI wglDeleteBufferRegionARB (HANDLE hRegion);
BOOL WINAPI wglSaveBufferRegionARB (HANDLE hRegion, int x, int y, int width, int height);
BOOL WINAPI wglRestoreBufferRegionARB (HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
#endif
#endif /* WGL_ARB_buffer_region */

#ifndef WGL_ARB_context_flush_control
#define WGL_ARB_context_flush_control 1
#define WGL_CONTEXT_RELEASE_BEHAVIOR_ARB  0x2097
#define WGL_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0
#define WGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
#endif /* WGL_ARB_context_flush_control */

#ifndef WGL_ARB_create_context
#define WGL_ARB_create_context 1
#define WGL_CONTEXT_DEBUG_BIT_ARB         0x00000001
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
#define WGL_CONTEXT_MAJOR_VERSION_ARB     0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB     0x2092
#define WGL_CONTEXT_LAYER_PLANE_ARB       0x2093
#define WGL_CONTEXT_FLAGS_ARB             0x2094
#define ERROR_INVALID_VERSION_ARB         0x2095
typedef HGLRC (WINAPI * PFNWGLCREATECONTEXTATTRIBSARBPROC) (HDC hDC, HGLRC hShareContext, const int *attribList);
#ifdef WGL_WGLEXT_PROTOTYPES
HGLRC WINAPI wglCreateContextAttribsARB (HDC hDC, HGLRC hShareContext, const int *attribList);
#endif
#endif /* WGL_ARB_create_context */

#ifndef WGL_ARB_create_context_profile
#define WGL_ARB_create_context_profile 1
#define WGL_CONTEXT_PROFILE_MASK_ARB      0x9126
#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define ERROR_INVALID_PROFILE_ARB         0x2096
#endif /* WGL_ARB_create_context_profile */

#ifndef WGL_ARB_create_context_robustness
#define WGL_ARB_create_context_robustness 1
#define WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
#define WGL_LOSE_CONTEXT_ON_RESET_ARB     0x8252
#define WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define WGL_NO_RESET_NOTIFICATION_ARB     0x8261
#endif /* WGL_ARB_create_context_robustness */

#ifndef WGL_ARB_extensions_string
#define WGL_ARB_extensions_string 1
typedef const char *(WINAPI * PFNWGLGETEXTENSIONSSTRINGARBPROC) (HDC hdc);
#ifdef WGL_WGLEXT_PROTOTYPES
const char *WINAPI wglGetExtensionsStringARB (HDC hdc);
#endif
#endif /* WGL_ARB_extensions_string */

#ifndef WGL_ARB_framebuffer_sRGB
#define WGL_ARB_framebuffer_sRGB 1
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20A9
#endif /* WGL_ARB_framebuffer_sRGB */

#ifndef WGL_ARB_make_current_read
#define WGL_ARB_make_current_read 1
#define ERROR_INVALID_PIXEL_TYPE_ARB      0x2043
#define ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB 0x2054
typedef BOOL (WINAPI * PFNWGLMAKECONTEXTCURRENTARBPROC) (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
typedef HDC (WINAPI * PFNWGLGETCURRENTREADDCARBPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglMakeContextCurrentARB (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
HDC WINAPI wglGetCurrentReadDCARB (void);
#endif
#endif /* WGL_ARB_make_current_read */

#ifndef WGL_ARB_multisample
#define WGL_ARB_multisample 1
#define WGL_SAMPLE_BUFFERS_ARB            0x2041
#define WGL_SAMPLES_ARB                   0x2042
#endif /* WGL_ARB_multisample */

#ifndef WGL_ARB_pbuffer
#define WGL_ARB_pbuffer 1
DECLARE_HANDLE(HPBUFFERARB);
#define WGL_DRAW_TO_PBUFFER_ARB           0x202D
#define WGL_MAX_PBUFFER_PIXELS_ARB        0x202E
#define WGL_MAX_PBUFFER_WIDTH_ARB         0x202F
#define WGL_MAX_PBUFFER_HEIGHT_ARB        0x2030
#define WGL_PBUFFER_LARGEST_ARB           0x2033
#define WGL_PBUFFER_WIDTH_ARB             0x2034
#define WGL_PBUFFER_HEIGHT_ARB            0x2035
#define WGL_PBUFFER_LOST_ARB              0x2036
typedef HPBUFFERARB (WINAPI * PFNWGLCREATEPBUFFERARBPROC) (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
typedef HDC (WINAPI * PFNWGLGETPBUFFERDCARBPROC) (HPBUFFERARB hPbuffer);
typedef int (WINAPI * PFNWGLRELEASEPBUFFERDCARBPROC) (HPBUFFERARB hPbuffer, HDC hDC);
typedef BOOL (WINAPI * PFNWGLDESTROYPBUFFERARBPROC) (HPBUFFERARB hPbuffer);
typedef BOOL (WINAPI * PFNWGLQUERYPBUFFERARBPROC) (HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
HPBUFFERARB WINAPI wglCreatePbufferARB (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
HDC WINAPI wglGetPbufferDCARB (HPBUFFERARB hPbuffer);
int WINAPI wglReleasePbufferDCARB (HPBUFFERARB hPbuffer, HDC hDC);
BOOL WINAPI wglDestroyPbufferARB (HPBUFFERARB hPbuffer);
BOOL WINAPI wglQueryPbufferARB (HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
#endif
#endif /* WGL_ARB_pbuffer */

#ifndef WGL_ARB_pixel_format
#define WGL_ARB_pixel_format 1
#define WGL_NUMBER_PIXEL_FORMATS_ARB      0x2000
#define WGL_DRAW_TO_WINDOW_ARB            0x2001
#define WGL_DRAW_TO_BITMAP_ARB            0x2002
#define WGL_ACCELERATION_ARB              0x2003
#define WGL_NEED_PALETTE_ARB              0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB       0x2005
#define WGL_SWAP_LAYER_BUFFERS_ARB        0x2006
#define WGL_SWAP_METHOD_ARB               0x2007
#define WGL_NUMBER_OVERLAYS_ARB           0x2008
#define WGL_NUMBER_UNDERLAYS_ARB          0x2009
#define WGL_TRANSPARENT_ARB               0x200A
#define WGL_TRANSPARENT_RED_VALUE_ARB     0x2037
#define WGL_TRANSPARENT_GREEN_VALUE_ARB   0x2038
#define WGL_TRANSPARENT_BLUE_VALUE_ARB    0x2039
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB   0x203A
#define WGL_TRANSPARENT_INDEX_VALUE_ARB   0x203B
#define WGL_SHARE_DEPTH_ARB               0x200C
#define WGL_SHARE_STENCIL_ARB             0x200D
#define WGL_SHARE_ACCUM_ARB               0x200E
#define WGL_SUPPORT_GDI_ARB               0x200F
#define WGL_SUPPORT_OPENGL_ARB            0x2010
#define WGL_DOUBLE_BUFFER_ARB             0x2011
#define WGL_STEREO_ARB                    0x2012
#define WGL_PIXEL_TYPE_ARB                0x2013
#define WGL_COLOR_BITS_ARB                0x2014
#define WGL_RED_BITS_ARB                  0x2015
#define WGL_RED_SHIFT_ARB                 0x2016
#define WGL_GREEN_BITS_ARB                0x2017
#define WGL_GREEN_SHIFT_ARB               0x2018
#define WGL_BLUE_BITS_ARB                 0x2019
#define WGL_BLUE_SHIFT_ARB                0x201A
#define WGL_ALPHA_BITS_ARB                0x201B
#define WGL_ALPHA_SHIFT_ARB               0x201C
#define WGL_ACCUM_BITS_ARB                0x201D
#define WGL_ACCUM_RED_BITS_ARB            0x201E
#define WGL_ACCUM_GREEN_BITS_ARB          0x201F
#define WGL_ACCUM_BLUE_BITS_ARB           0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB          0x2021
#define WGL_DEPTH_BITS_ARB                0x2022
#define WGL_STENCIL_BITS_ARB              0x2023
#define WGL_AUX_BUFFERS_ARB               0x2024
#define WGL_NO_ACCELERATION_ARB           0x2025
#define WGL_GENERIC_ACCELERATION_ARB      0x2026
#define WGL_FULL_ACCELERATION_ARB         0x2027
#define WGL_SWAP_EXCHANGE_ARB             0x2028
#define WGL_SWAP_COPY_ARB                 0x2029
#define WGL_SWAP_UNDEFINED_ARB            0x202A
#define WGL_TYPE_RGBA_ARB                 0x202B
#define WGL_TYPE_COLORINDEX_ARB           0x202C
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVARBPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues);
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBFVARBPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues);
typedef BOOL (WINAPI * PFNWGLCHOOSEPIXELFORMATARBPROC) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetPixelFormatAttribivARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues);
BOOL WINAPI wglGetPixelFormatAttribfvARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues);
BOOL WINAPI wglChoosePixelFormatARB (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#endif
#endif /* WGL_ARB_pixel_format */

#ifndef WGL_ARB_pixel_format_float
#define WGL_ARB_pixel_format_float 1
#define WGL_TYPE_RGBA_FLOAT_ARB           0x21A0
#endif /* WGL_ARB_pixel_format_float */

#ifndef WGL_ARB_render_texture
#define WGL_ARB_render_texture 1
#define WGL_BIND_TO_TEXTURE_RGB_ARB       0x2070
#define WGL_BIND_TO_TEXTURE_RGBA_ARB      0x2071
#define WGL_TEXTURE_FORMAT_ARB            0x2072
#define WGL_TEXTURE_TARGET_ARB            0x2073
#define WGL_MIPMAP_TEXTURE_ARB            0x2074
#define WGL_TEXTURE_RGB_ARB               0x2075
#define WGL_TEXTURE_RGBA_ARB              0x2076
#define WGL_NO_TEXTURE_ARB                0x2077
#define WGL_TEXTURE_CUBE_MAP_ARB          0x2078
#define WGL_TEXTURE_1D_ARB                0x2079
#define WGL_TEXTURE_2D_ARB                0x207A
#define WGL_MIPMAP_LEVEL_ARB              0x207B
#define WGL_CUBE_MAP_FACE_ARB             0x207C
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x207D
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x207E
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x207F
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x2080
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x2081
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x2082
#define WGL_FRONT_LEFT_ARB                0x2083
#define WGL_FRONT_RIGHT_ARB               0x2084
#define WGL_BACK_LEFT_ARB                 0x2085
#define WGL_BACK_RIGHT_ARB                0x2086
#define WGL_AUX0_ARB                      0x2087
#define WGL_AUX1_ARB                      0x2088
#define WGL_AUX2_ARB                      0x2089
#define WGL_AUX3_ARB                      0x208A
#define WGL_AUX4_ARB                      0x208B
#define WGL_AUX5_ARB                      0x208C
#define WGL_AUX6_ARB                      0x208D
#define WGL_AUX7_ARB                      0x208E
#define WGL_AUX8_ARB                      0x208F
#define WGL_AUX9_ARB                      0x2090
typedef BOOL (WINAPI * PFNWGLBINDTEXIMAGEARBPROC) (HPBUFFERARB hPbuffer, int iBuffer);
typedef BOOL (WINAPI * PFNWGLRELEASETEXIMAGEARBPROC) (HPBUFFERARB hPbuffer, int iBuffer);
typedef BOOL (WINAPI * PFNWGLSETPBUFFERATTRIBARBPROC) (HPBUFFERARB hPbuffer, const int *piAttribList);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglBindTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
BOOL WINAPI wglReleaseTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
BOOL WINAPI wglSetPbufferAttribARB (HPBUFFERARB hPbuffer, const int *piAttribList);
#endif
#endif /* WGL_ARB_render_texture */

#ifndef WGL_ARB_robustness_application_isolation
#define WGL_ARB_robustness_application_isolation 1
#define WGL_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
#endif /* WGL_ARB_robustness_application_isolation */

#ifndef WGL_ARB_robustness_share_group_isolation
#define WGL_ARB_robustness_share_group_isolation 1
#endif /* WGL_ARB_robustness_share_group_isolation */

#ifndef WGL_3DFX_multisample
#define WGL_3DFX_multisample 1
#define WGL_SAMPLE_BUFFERS_3DFX           0x2060
#define WGL_SAMPLES_3DFX                  0x2061
#endif /* WGL_3DFX_multisample */

#ifndef WGL_3DL_stereo_control
#define WGL_3DL_stereo_control 1
#define WGL_STEREO_EMITTER_ENABLE_3DL     0x2055
#define WGL_STEREO_EMITTER_DISABLE_3DL    0x2056
#define WGL_STEREO_POLARITY_NORMAL_3DL    0x2057
#define WGL_STEREO_POLARITY_INVERT_3DL    0x2058
typedef BOOL (WINAPI * PFNWGLSETSTEREOEMITTERSTATE3DLPROC) (HDC hDC, UINT uState);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglSetStereoEmitterState3DL (HDC hDC, UINT uState);
#endif
#endif /* WGL_3DL_stereo_control */

#ifndef WGL_AMD_gpu_association
#define WGL_AMD_gpu_association 1
#define WGL_GPU_VENDOR_AMD                0x1F00
#define WGL_GPU_RENDERER_STRING_AMD       0x1F01
#define WGL_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
#define WGL_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
#define WGL_GPU_RAM_AMD                   0x21A3
#define WGL_GPU_CLOCK_AMD                 0x21A4
#define WGL_GPU_NUM_PIPES_AMD             0x21A5
#define WGL_GPU_NUM_SIMD_AMD              0x21A6
#define WGL_GPU_NUM_RB_AMD                0x21A7
#define WGL_GPU_NUM_SPI_AMD               0x21A8
typedef UINT (WINAPI * PFNWGLGETGPUIDSAMDPROC) (UINT maxCount, UINT *ids);
typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, int property, GLenum dataType, UINT size, void *data);
typedef UINT (WINAPI * PFNWGLGETCONTEXTGPUIDAMDPROC) (HGLRC hglrc);
typedef HGLRC (WINAPI * PFNWGLCREATEASSOCIATEDCONTEXTAMDPROC) (UINT id);
typedef HGLRC (WINAPI * PFNWGLCREATEASSOCIATEDCONTEXTATTRIBSAMDPROC) (UINT id, HGLRC hShareContext, const int *attribList);
typedef BOOL (WINAPI * PFNWGLDELETEASSOCIATEDCONTEXTAMDPROC) (HGLRC hglrc);
typedef BOOL (WINAPI * PFNWGLMAKEASSOCIATEDCONTEXTCURRENTAMDPROC) (HGLRC hglrc);
typedef HGLRC (WINAPI * PFNWGLGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
typedef VOID (WINAPI * PFNWGLBLITCONTEXTFRAMEBUFFERAMDPROC) (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#ifdef WGL_WGLEXT_PROTOTYPES
UINT WINAPI wglGetGPUIDsAMD (UINT maxCount, UINT *ids);
INT WINAPI wglGetGPUInfoAMD (UINT id, int property, GLenum dataType, UINT size, void *data);
UINT WINAPI wglGetContextGPUIDAMD (HGLRC hglrc);
HGLRC WINAPI wglCreateAssociatedContextAMD (UINT id);
HGLRC WINAPI wglCreateAssociatedContextAttribsAMD (UINT id, HGLRC hShareContext, const int *attribList);
BOOL WINAPI wglDeleteAssociatedContextAMD (HGLRC hglrc);
BOOL WINAPI wglMakeAssociatedContextCurrentAMD (HGLRC hglrc);
HGLRC WINAPI wglGetCurrentAssociatedContextAMD (void);
VOID WINAPI wglBlitContextFramebufferAMD (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#endif
#endif /* WGL_AMD_gpu_association */

#ifndef WGL_ATI_pixel_format_float
#define WGL_ATI_pixel_format_float 1
#define WGL_TYPE_RGBA_FLOAT_ATI           0x21A0
#endif /* WGL_ATI_pixel_format_float */

#ifndef WGL_EXT_colorspace
#define WGL_EXT_colorspace 1
#define WGL_COLORSPACE_EXT                0x3087
#define WGL_COLORSPACE_SRGB_EXT           0x3089
#define WGL_COLORSPACE_LINEAR_EXT         0x308A
#endif /* WGL_EXT_colorspace */

#ifndef WGL_EXT_create_context_es2_profile
#define WGL_EXT_create_context_es2_profile 1
#define WGL_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
#endif /* WGL_EXT_create_context_es2_profile */

#ifndef WGL_EXT_create_context_es_profile
#define WGL_EXT_create_context_es_profile 1
#define WGL_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
#endif /* WGL_EXT_create_context_es_profile */

#ifndef WGL_EXT_depth_float
#define WGL_EXT_depth_float 1
#define WGL_DEPTH_FLOAT_EXT               0x2040
#endif /* WGL_EXT_depth_float */

#ifndef WGL_EXT_display_color_table
#define WGL_EXT_display_color_table 1
typedef GLboolean (WINAPI * PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC) (GLushort id);
typedef GLboolean (WINAPI * PFNWGLLOADDISPLAYCOLORTABLEEXTPROC) (const GLushort *table, GLuint length);
typedef GLboolean (WINAPI * PFNWGLBINDDISPLAYCOLORTABLEEXTPROC) (GLushort id);
typedef VOID (WINAPI * PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC) (GLushort id);
#ifdef WGL_WGLEXT_PROTOTYPES
GLboolean WINAPI wglCreateDisplayColorTableEXT (GLushort id);
GLboolean WINAPI wglLoadDisplayColorTableEXT (const GLushort *table, GLuint length);
GLboolean WINAPI wglBindDisplayColorTableEXT (GLushort id);
VOID WINAPI wglDestroyDisplayColorTableEXT (GLushort id);
#endif
#endif /* WGL_EXT_display_color_table */

#ifndef WGL_EXT_extensions_string
#define WGL_EXT_extensions_string 1
typedef const char *(WINAPI * PFNWGLGETEXTENSIONSSTRINGEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
const char *WINAPI wglGetExtensionsStringEXT (void);
#endif
#endif /* WGL_EXT_extensions_string */

#ifndef WGL_EXT_framebuffer_sRGB
#define WGL_EXT_framebuffer_sRGB 1
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20A9
#endif /* WGL_EXT_framebuffer_sRGB */

#ifndef WGL_EXT_make_current_read
#define WGL_EXT_make_current_read 1
#define ERROR_INVALID_PIXEL_TYPE_EXT      0x2043
typedef BOOL (WINAPI * PFNWGLMAKECONTEXTCURRENTEXTPROC) (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
typedef HDC (WINAPI * PFNWGLGETCURRENTREADDCEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglMakeContextCurrentEXT (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
HDC WINAPI wglGetCurrentReadDCEXT (void);
#endif
#endif /* WGL_EXT_make_current_read */

#ifndef WGL_EXT_multisample
#define WGL_EXT_multisample 1
#define WGL_SAMPLE_BUFFERS_EXT            0x2041
#define WGL_SAMPLES_EXT                   0x2042
#endif /* WGL_EXT_multisample */

#ifndef WGL_EXT_pbuffer
#define WGL_EXT_pbuffer 1
DECLARE_HANDLE(HPBUFFEREXT);
#define WGL_DRAW_TO_PBUFFER_EXT           0x202D
#define WGL_MAX_PBUFFER_PIXELS_EXT        0x202E
#define WGL_MAX_PBUFFER_WIDTH_EXT         0x202F
#define WGL_MAX_PBUFFER_HEIGHT_EXT        0x2030
#define WGL_OPTIMAL_PBUFFER_WIDTH_EXT     0x2031
#define WGL_OPTIMAL_PBUFFER_HEIGHT_EXT    0x2032
#define WGL_PBUFFER_LARGEST_EXT           0x2033
#define WGL_PBUFFER_WIDTH_EXT             0x2034
#define WGL_PBUFFER_HEIGHT_EXT            0x2035
typedef HPBUFFEREXT (WINAPI * PFNWGLCREATEPBUFFEREXTPROC) (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
typedef HDC (WINAPI * PFNWGLGETPBUFFERDCEXTPROC) (HPBUFFEREXT hPbuffer);
typedef int (WINAPI * PFNWGLRELEASEPBUFFERDCEXTPROC) (HPBUFFEREXT hPbuffer, HDC hDC);
typedef BOOL (WINAPI * PFNWGLDESTROYPBUFFEREXTPROC) (HPBUFFEREXT hPbuffer);
typedef BOOL (WINAPI * PFNWGLQUERYPBUFFEREXTPROC) (HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
HPBUFFEREXT WINAPI wglCreatePbufferEXT (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
HDC WINAPI wglGetPbufferDCEXT (HPBUFFEREXT hPbuffer);
int WINAPI wglReleasePbufferDCEXT (HPBUFFEREXT hPbuffer, HDC hDC);
BOOL WINAPI wglDestroyPbufferEXT (HPBUFFEREXT hPbuffer);
BOOL WINAPI wglQueryPbufferEXT (HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
#endif
#endif /* WGL_EXT_pbuffer */

#ifndef WGL_EXT_pixel_format
#define WGL_EXT_pixel_format 1
#define WGL_NUMBER_PIXEL_FORMATS_EXT      0x2000
#define WGL_DRAW_TO_WINDOW_EXT            0x2001
#define WGL_DRAW_TO_BITMAP_EXT            0x2002
#define WGL_ACCELERATION_EXT              0x2003
#define WGL_NEED_PALETTE_EXT              0x2004
#define WGL_NEED_SYSTEM_PALETTE_EXT       0x2005
#define WGL_SWAP_LAYER_BUFFERS_EXT        0x2006
#define WGL_SWAP_METHOD_EXT               0x2007
#define WGL_NUMBER_OVERLAYS_EXT           0x2008
#define WGL_NUMBER_UNDERLAYS_EXT          0x2009
#define WGL_TRANSPARENT_EXT               0x200A
#define WGL_TRANSPARENT_VALUE_EXT         0x200B
#define WGL_SHARE_DEPTH_EXT               0x200C
#define WGL_SHARE_STENCIL_EXT             0x200D
#define WGL_SHARE_ACCUM_EXT               0x200E
#define WGL_SUPPORT_GDI_EXT               0x200F
#define WGL_SUPPORT_OPENGL_EXT            0x2010
#define WGL_DOUBLE_BUFFER_EXT             0x2011
#define WGL_STEREO_EXT                    0x2012
#define WGL_PIXEL_TYPE_EXT                0x2013
#define WGL_COLOR_BITS_EXT                0x2014
#define WGL_RED_BITS_EXT                  0x2015
#define WGL_RED_SHIFT_EXT                 0x2016
#define WGL_GREEN_BITS_EXT                0x2017
#define WGL_GREEN_SHIFT_EXT               0x2018
#define WGL_BLUE_BITS_EXT                 0x2019
#define WGL_BLUE_SHIFT_EXT                0x201A
#define WGL_ALPHA_BITS_EXT                0x201B
#define WGL_ALPHA_SHIFT_EXT               0x201C
#define WGL_ACCUM_BITS_EXT                0x201D
#define WGL_ACCUM_RED_BITS_EXT            0x201E
#define WGL_ACCUM_GREEN_BITS_EXT          0x201F
#define WGL_ACCUM_BLUE_BITS_EXT           0x2020
#define WGL_ACCUM_ALPHA_BITS_EXT          0x2021
#define WGL_DEPTH_BITS_EXT                0x2022
#define WGL_STENCIL_BITS_EXT              0x2023
#define WGL_AUX_BUFFERS_EXT               0x2024
#define WGL_NO_ACCELERATION_EXT           0x2025
#define WGL_GENERIC_ACCELERATION_EXT      0x2026
#define WGL_FULL_ACCELERATION_EXT         0x2027
#define WGL_SWAP_EXCHANGE_EXT             0x2028
#define WGL_SWAP_COPY_EXT                 0x2029
#define WGL_SWAP_UNDEFINED_EXT            0x202A
#define WGL_TYPE_RGBA_EXT                 0x202B
#define WGL_TYPE_COLORINDEX_EXT           0x202C
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVEXTPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBFVEXTPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
typedef BOOL (WINAPI * PFNWGLCHOOSEPIXELFORMATEXTPROC) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetPixelFormatAttribivEXT (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
BOOL WINAPI wglGetPixelFormatAttribfvEXT (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
BOOL WINAPI wglChoosePixelFormatEXT (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#endif
#endif /* WGL_EXT_pixel_format */

#ifndef WGL_EXT_pixel_format_packed_float
#define WGL_EXT_pixel_format_packed_float 1
#define WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT  0x20A8
#endif /* WGL_EXT_pixel_format_packed_float */

#ifndef WGL_EXT_swap_control
#define WGL_EXT_swap_control 1
typedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC) (int interval);
typedef int (WINAPI * PFNWGLGETSWAPINTERVALEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglSwapIntervalEXT (int interval);
int WINAPI wglGetSwapIntervalEXT (void);
#endif
#endif /* WGL_EXT_swap_control */

#ifndef WGL_EXT_swap_control_tear
#define WGL_EXT_swap_control_tear 1
#endif /* WGL_EXT_swap_control_tear */

#ifndef WGL_I3D_digital_video_control
#define WGL_I3D_digital_video_control 1
#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D 0x2050
#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D 0x2051
#define WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D 0x2052
#define WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D 0x2053
typedef BOOL (WINAPI * PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC) (HDC hDC, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC) (HDC hDC, int iAttribute, const int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetDigitalVideoParametersI3D (HDC hDC, int iAttribute, int *piValue);
BOOL WINAPI wglSetDigitalVideoParametersI3D (HDC hDC, int iAttribute, const int *piValue);
#endif
#endif /* WGL_I3D_digital_video_control */

#ifndef WGL_I3D_gamma
#define WGL_I3D_gamma 1
#define WGL_GAMMA_TABLE_SIZE_I3D          0x204E
#define WGL_GAMMA_EXCLUDE_DESKTOP_I3D     0x204F
typedef BOOL (WINAPI * PFNWGLGETGAMMATABLEPARAMETERSI3DPROC) (HDC hDC, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLSETGAMMATABLEPARAMETERSI3DPROC) (HDC hDC, int iAttribute, const int *piValue);
typedef BOOL (WINAPI * PFNWGLGETGAMMATABLEI3DPROC) (HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
typedef BOOL (WINAPI * PFNWGLSETGAMMATABLEI3DPROC) (HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetGammaTableParametersI3D (HDC hDC, int iAttribute, int *piValue);
BOOL WINAPI wglSetGammaTableParametersI3D (HDC hDC, int iAttribute, const int *piValue);
BOOL WINAPI wglGetGammaTableI3D (HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
BOOL WINAPI wglSetGammaTableI3D (HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
#endif
#endif /* WGL_I3D_gamma */

#ifndef WGL_I3D_genlock
#define WGL_I3D_genlock 1
#define WGL_GENLOCK_SOURCE_MULTIVIEW_I3D  0x2044
#define WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D 0x2045
#define WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D 0x2046
#define WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D 0x2047
#define WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D 0x2048
#define WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D 0x2049
#define WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D 0x204A
#define WGL_GENLOCK_SOURCE_EDGE_RISING_I3D 0x204B
#define WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D  0x204C
typedef BOOL (WINAPI * PFNWGLENABLEGENLOCKI3DPROC) (HDC hDC);
typedef BOOL (WINAPI * PFNWGLDISABLEGENLOCKI3DPROC) (HDC hDC);
typedef BOOL (WINAPI * PFNWGLISENABLEDGENLOCKI3DPROC) (HDC hDC, BOOL *pFlag);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEI3DPROC) (HDC hDC, UINT uSource);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEI3DPROC) (HDC hDC, UINT *uSource);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEEDGEI3DPROC) (HDC hDC, UINT uEdge);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEEDGEI3DPROC) (HDC hDC, UINT *uEdge);
typedef BOOL (WINAPI * PFNWGLGENLOCKSAMPLERATEI3DPROC) (HDC hDC, UINT uRate);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSAMPLERATEI3DPROC) (HDC hDC, UINT *uRate);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEDELAYI3DPROC) (HDC hDC, UINT uDelay);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEDELAYI3DPROC) (HDC hDC, UINT *uDelay);
typedef BOOL (WINAPI * PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC) (HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnableGenlockI3D (HDC hDC);
BOOL WINAPI wglDisableGenlockI3D (HDC hDC);
BOOL WINAPI wglIsEnabledGenlockI3D (HDC hDC, BOOL *pFlag);
BOOL WINAPI wglGenlockSourceI3D (HDC hDC, UINT uSource);
BOOL WINAPI wglGetGenlockSourceI3D (HDC hDC, UINT *uSource);
BOOL WINAPI wglGenlockSourceEdgeI3D (HDC hDC, UINT uEdge);
BOOL WINAPI wglGetGenlockSourceEdgeI3D (HDC hDC, UINT *uEdge);
BOOL WINAPI wglGenlockSampleRateI3D (HDC hDC, UINT uRate);
BOOL WINAPI wglGetGenlockSampleRateI3D (HDC hDC, UINT *uRate);
BOOL WINAPI wglGenlockSourceDelayI3D (HDC hDC, UINT uDelay);
BOOL WINAPI wglGetGenlockSourceDelayI3D (HDC hDC, UINT *uDelay);
BOOL WINAPI wglQueryGenlockMaxSourceDelayI3D (HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);
#endif
#endif /* WGL_I3D_genlock */

#ifndef WGL_I3D_image_buffer
#define WGL_I3D_image_buffer 1
#define WGL_IMAGE_BUFFER_MIN_ACCESS_I3D   0x00000001
#define WGL_IMAGE_BUFFER_LOCK_I3D         0x00000002
typedef LPVOID (WINAPI * PFNWGLCREATEIMAGEBUFFERI3DPROC) (HDC hDC, DWORD dwSize, UINT uFlags);
typedef BOOL (WINAPI * PFNWGLDESTROYIMAGEBUFFERI3DPROC) (HDC hDC, LPVOID pAddress);
typedef BOOL (WINAPI * PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC) (HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count);
typedef BOOL (WINAPI * PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC) (HDC hDC, const LPVOID *pAddress, UINT count);
#ifdef WGL_WGLEXT_PROTOTYPES
LPVOID WINAPI wglCreateImageBufferI3D (HDC hDC, DWORD dwSize, UINT uFlags);
BOOL WINAPI wglDestroyImageBufferI3D (HDC hDC, LPVOID pAddress);
BOOL WINAPI wglAssociateImageBufferEventsI3D (HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count);
BOOL WINAPI wglReleaseImageBufferEventsI3D (HDC hDC, const LPVOID *pAddress, UINT count);
#endif
#endif /* WGL_I3D_image_buffer */

#ifndef WGL_I3D_swap_frame_lock
#define WGL_I3D_swap_frame_lock 1
typedef BOOL (WINAPI * PFNWGLENABLEFRAMELOCKI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLDISABLEFRAMELOCKI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLISENABLEDFRAMELOCKI3DPROC) (BOOL *pFlag);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMELOCKMASTERI3DPROC) (BOOL *pFlag);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnableFrameLockI3D (void);
BOOL WINAPI wglDisableFrameLockI3D (void);
BOOL WINAPI wglIsEnabledFrameLockI3D (BOOL *pFlag);
BOOL WINAPI wglQueryFrameLockMasterI3D (BOOL *pFlag);
#endif
#endif /* WGL_I3D_swap_frame_lock */

#ifndef WGL_I3D_swap_frame_usage
#define WGL_I3D_swap_frame_usage 1
typedef BOOL (WINAPI * PFNWGLGETFRAMEUSAGEI3DPROC) (float *pUsage);
typedef BOOL (WINAPI * PFNWGLBEGINFRAMETRACKINGI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLENDFRAMETRACKINGI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMETRACKINGI3DPROC) (DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetFrameUsageI3D (float *pUsage);
BOOL WINAPI wglBeginFrameTrackingI3D (void);
BOOL WINAPI wglEndFrameTrackingI3D (void);
BOOL WINAPI wglQueryFrameTrackingI3D (DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);
#endif
#endif /* WGL_I3D_swap_frame_usage */

#ifndef WGL_NV_DX_interop
#define WGL_NV_DX_interop 1
#define WGL_ACCESS_READ_ONLY_NV           0x00000000
#define WGL_ACCESS_READ_WRITE_NV          0x00000001
#define WGL_ACCESS_WRITE_DISCARD_NV       0x00000002
typedef BOOL (WINAPI * PFNWGLDXSETRESOURCESHAREHANDLENVPROC) (void *dxObject, HANDLE shareHandle);
typedef HANDLE (WINAPI * PFNWGLDXOPENDEVICENVPROC) (void *dxDevice);
typedef BOOL (WINAPI * PFNWGLDXCLOSEDEVICENVPROC) (HANDLE hDevice);
typedef HANDLE (WINAPI * PFNWGLDXREGISTEROBJECTNVPROC) (HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access);
typedef BOOL (WINAPI * PFNWGLDXUNREGISTEROBJECTNVPROC) (HANDLE hDevice, HANDLE hObject);
typedef BOOL (WINAPI * PFNWGLDXOBJECTACCESSNVPROC) (HANDLE hObject, GLenum access);
typedef BOOL (WINAPI * PFNWGLDXLOCKOBJECTSNVPROC) (HANDLE hDevice, GLint count, HANDLE *hObjects);
typedef BOOL (WINAPI * PFNWGLDXUNLOCKOBJECTSNVPROC) (HANDLE hDevice, GLint count, HANDLE *hObjects);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglDXSetResourceShareHandleNV (void *dxObject, HANDLE shareHandle);
HANDLE WINAPI wglDXOpenDeviceNV (void *dxDevice);
BOOL WINAPI wglDXCloseDeviceNV (HANDLE hDevice);
HANDLE WINAPI wglDXRegisterObjectNV (HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access);
BOOL WINAPI wglDXUnregisterObjectNV (HANDLE hDevice, HANDLE hObject);
BOOL WINAPI wglDXObjectAccessNV (HANDLE hObject, GLenum access);
BOOL WINAPI wglDXLockObjectsNV (HANDLE hDevice, GLint count, HANDLE *hObjects);
BOOL WINAPI wglDXUnlockObjectsNV (HANDLE hDevice, GLint count, HANDLE *hObjects);
#endif
#endif /* WGL_NV_DX_interop */

#ifndef WGL_NV_DX_interop2
#define WGL_NV_DX_interop2 1
#endif /* WGL_NV_DX_interop2 */

#ifndef WGL_NV_copy_image
#define WGL_NV_copy_image 1
typedef BOOL (WINAPI * PFNWGLCOPYIMAGESUBDATANVPROC) (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglCopyImageSubDataNV (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#endif
#endif /* WGL_NV_copy_image */

#ifndef WGL_NV_delay_before_swap
#define WGL_NV_delay_before_swap 1
typedef BOOL (WINAPI * PFNWGLDELAYBEFORESWAPNVPROC) (HDC hDC, GLfloat seconds);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglDelayBeforeSwapNV (HDC hDC, GLfloat seconds);
#endif
#endif /* WGL_NV_delay_before_swap */

#ifndef WGL_NV_float_buffer
#define WGL_NV_float_buffer 1
#define WGL_FLOAT_COMPONENTS_NV           0x20B0
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV 0x20B1
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV 0x20B2
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV 0x20B3
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV 0x20B4
#define WGL_TEXTURE_FLOAT_R_NV            0x20B5
#define WGL_TEXTURE_FLOAT_RG_NV           0x20B6
#define WGL_TEXTURE_FLOAT_RGB_NV          0x20B7
#define WGL_TEXTURE_FLOAT_RGBA_NV         0x20B8
#endif /* WGL_NV_float_buffer */

#ifndef WGL_NV_gpu_affinity
#define WGL_NV_gpu_affinity 1
DECLARE_HANDLE(HGPUNV);
struct _GPU_DEVICE {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  Flags;
    RECT   rcVirtualScreen;
};
typedef struct _GPU_DEVICE *PGPU_DEVICE;
#define ERROR_INCOMPATIBLE_AFFINITY_MASKS_NV 0x20D0
#define ERROR_MISSING_AFFINITY_MASK_NV    0x20D1
typedef BOOL (WINAPI * PFNWGLENUMGPUSNVPROC) (UINT iGpuIndex, HGPUNV *phGpu);
typedef BOOL (WINAPI * PFNWGLENUMGPUDEVICESNVPROC) (HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice);
typedef HDC (WINAPI * PFNWGLCREATEAFFINITYDCNVPROC) (const HGPUNV *phGpuList);
typedef BOOL (WINAPI * PFNWGLENUMGPUSFROMAFFINITYDCNVPROC) (HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu);
typedef BOOL (WINAPI * PFNWGLDELETEDCNVPROC) (HDC hdc);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnumGpusNV (UINT iGpuIndex, HGPUNV *phGpu);
BOOL WINAPI wglEnumGpuDevicesNV (HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice);
HDC WINAPI wglCreateAffinityDCNV (const HGPUNV *phGpuList);
BOOL WINAPI wglEnumGpusFromAffinityDCNV (HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu);
BOOL WINAPI wglDeleteDCNV (HDC hdc);
#endif
#endif /* WGL_NV_gpu_affinity */

#ifndef WGL_NV_multisample_coverage
#define WGL_NV_multisample_coverage 1
#define WGL_COVERAGE_SAMPLES_NV           0x2042
#define WGL_COLOR_SAMPLES_NV              0x20B9
#endif /* WGL_NV_multisample_coverage */

#ifndef WGL_NV_present_video
#define WGL_NV_present_video 1
DECLARE_HANDLE(HVIDEOOUTPUTDEVICENV);
#define WGL_NUM_VIDEO_SLOTS_NV            0x20F0
typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);
typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);
typedef BOOL (WINAPI * PFNWGLQUERYCURRENTCONTEXTNVPROC) (int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
int WINAPI wglEnumerateVideoDevicesNV (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);
BOOL WINAPI wglBindVideoDeviceNV (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);
BOOL WINAPI wglQueryCurrentContextNV (int iAttribute, int *piValue);
#endif
#endif /* WGL_NV_present_video */

#ifndef WGL_NV_render_depth_texture
#define WGL_NV_render_depth_texture 1
#define WGL_BIND_TO_TEXTURE_DEPTH_NV      0x20A3
#define WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV 0x20A4
#define WGL_DEPTH_TEXTURE_FORMAT_NV       0x20A5
#define WGL_TEXTURE_DEPTH_COMPONENT_NV    0x20A6
#define WGL_DEPTH_COMPONENT_NV            0x20A7
#endif /* WGL_NV_render_depth_texture */

#ifndef WGL_NV_render_texture_rectangle
#define WGL_NV_render_texture_rectangle 1
#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV 0x20A0
#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV 0x20A1
#define WGL_TEXTURE_RECTANGLE_NV          0x20A2
#endif /* WGL_NV_render_texture_rectangle */

#ifndef WGL_NV_swap_group
#define WGL_NV_swap_group 1
typedef BOOL (WINAPI * PFNWGLJOINSWAPGROUPNVPROC) (HDC hDC, GLuint group);
typedef BOOL (WINAPI * PFNWGLBINDSWAPBARRIERNVPROC) (GLuint group, GLuint barrier);
typedef BOOL (WINAPI * PFNWGLQUERYSWAPGROUPNVPROC) (HDC hDC, GLuint *group, GLuint *barrier);
typedef BOOL (WINAPI * PFNWGLQUERYMAXSWAPGROUPSNVPROC) (HDC hDC, GLuint *maxGroups, GLuint *maxBarriers);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMECOUNTNVPROC) (HDC hDC, GLuint *count);
typedef BOOL (WINAPI * PFNWGLRESETFRAMECOUNTNVPROC) (HDC hDC);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglJoinSwapGroupNV (HDC hDC, GLuint group);
BOOL WINAPI wglBindSwapBarrierNV (GLuint group, GLuint barrier);
BOOL WINAPI wglQuerySwapGroupNV (HDC hDC, GLuint *group, GLuint *barrier);
BOOL WINAPI wglQueryMaxSwapGroupsNV (HDC hDC, GLuint *maxGroups, GLuint *maxBarriers);
BOOL WINAPI wglQueryFrameCountNV (HDC hDC, GLuint *count);
BOOL WINAPI wglResetFrameCountNV (HDC hDC);
#endif
#endif /* WGL_NV_swap_group */

#ifndef WGL_NV_vertex_array_range
#define WGL_NV_vertex_array_range 1
typedef void *(WINAPI * PFNWGLALLOCATEMEMORYNVPROC) (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
typedef void (WINAPI * PFNWGLFREEMEMORYNVPROC) (void *pointer);
#ifdef WGL_WGLEXT_PROTOTYPES
void *WINAPI wglAllocateMemoryNV (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
void WINAPI wglFreeMemoryNV (void *pointer);
#endif
#endif /* WGL_NV_vertex_array_range */

#ifndef WGL_NV_video_capture
#define WGL_NV_video_capture 1
DECLARE_HANDLE(HVIDEOINPUTDEVICENV);
#define WGL_UNIQUE_ID_NV                  0x20CE
#define WGL_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
typedef BOOL (WINAPI * PFNWGLBINDVIDEOCAPTUREDEVICENVPROC) (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
typedef UINT (WINAPI * PFNWGLENUMERATEVIDEOCAPTUREDEVICESNVPROC) (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList);
typedef BOOL (WINAPI * PFNWGLLOCKVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
typedef BOOL (WINAPI * PFNWGLQUERYVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglBindVideoCaptureDeviceNV (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
UINT WINAPI wglEnumerateVideoCaptureDevicesNV (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList);
BOOL WINAPI wglLockVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
BOOL WINAPI wglQueryVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
BOOL WINAPI wglReleaseVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
#endif
#endif /* WGL_NV_video_capture */

#ifndef WGL_NV_video_output
#define WGL_NV_video_output 1
DECLARE_HANDLE(HPVIDEODEV);
#define WGL_BIND_TO_VIDEO_RGB_NV          0x20C0
#define WGL_BIND_TO_VIDEO_RGBA_NV         0x20C1
#define WGL_BIND_TO_VIDEO_RGB_AND_DEPTH_NV 0x20C2
#define WGL_VIDEO_OUT_COLOR_NV            0x20C3
#define WGL_VIDEO_OUT_ALPHA_NV            0x20C4
#define WGL_VIDEO_OUT_DEPTH_NV            0x20C5
#define WGL_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
#define WGL_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
#define WGL_VIDEO_OUT_FRAME               0x20C8
#define WGL_VIDEO_OUT_FIELD_1             0x20C9
#define WGL_VIDEO_OUT_FIELD_2             0x20CA
#define WGL_VIDEO_OUT_STACKED_FIELDS_1_2  0x20CB
#define WGL_VIDEO_OUT_STACKED_FIELDS_2_1  0x20CC
typedef BOOL (WINAPI * PFNWGLGETVIDEODEVICENVPROC) (HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEODEVICENVPROC) (HPVIDEODEV hVideoDevice);
typedef BOOL (WINAPI * PFNWGLBINDVIDEOIMAGENVPROC) (HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEOIMAGENVPROC) (HPBUFFERARB hPbuffer, int iVideoBuffer);
typedef BOOL (WINAPI * PFNWGLSENDPBUFFERTOVIDEONVPROC) (HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock);
typedef BOOL (WINAPI * PFNWGLGETVIDEOINFONVPROC) (HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetVideoDeviceNV (HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice);
BOOL WINAPI wglReleaseVideoDeviceNV (HPVIDEODEV hVideoDevice);
BOOL WINAPI wglBindVideoImageNV (HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer);
BOOL WINAPI wglReleaseVideoImageNV (HPBUFFERARB hPbuffer, int iVideoBuffer);
BOOL WINAPI wglSendPbufferToVideoNV (HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock);
BOOL WINAPI wglGetVideoInfoNV (HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#endif
#endif /* WGL_NV_video_output */

#ifndef WGL_OML_sync_control
#define WGL_OML_sync_control 1
typedef BOOL (WINAPI * PFNWGLGETSYNCVALUESOMLPROC) (HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc);
typedef BOOL (WINAPI * PFNWGLGETMSCRATEOMLPROC) (HDC hdc, INT32 *numerator, INT32 *denominator);
typedef INT64 (WINAPI * PFNWGLSWAPBUFFERSMSCOMLPROC) (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder);
typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
typedef BOOL (WINAPI * PFNWGLWAITFORMSCOMLPROC) (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
typedef BOOL (WINAPI * PFNWGLWAITFORSBCOMLPROC) (HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetSyncValuesOML (HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc);
BOOL WINAPI wglGetMscRateOML (HDC hdc, INT32 *numerator, INT32 *denominator);
INT64 WINAPI wglSwapBuffersMscOML (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder);
INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
BOOL WINAPI wglWaitForMscOML (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
BOOL WINAPI wglWaitForSbcOML (HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);
#endif
#endif /* WGL_OML_sync_control */

#ifdef __cplusplus
}
#endif

#endif


#pragma comment(lib, "OpenGL32.lib")

namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface,
			private virtual GEventReceiverImplementation, private virtual GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventReceiver receiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH = {nullptr, nullptr};
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0;

			GLint extensionCount = 0;
			const char* glExtensions = nullptr;

			HDC                         hdc			= NULL;
			HGLRC                       OGLcontext	= NULL;
			//				 WGL FUNCTION POINTERS				   //
			PFNWGLGETEXTENSIONSSTRINGARBPROC	wglGetExtensionsStringARB = NULL;
			PFNWGLGETEXTENSIONSSTRINGEXTPROC	wglGetExtensionsStringEXT = NULL;
			PFNWGLCREATECONTEXTATTRIBSARBPROC	wglCreateContextAttribsARB = NULL;
			PFNWGLSWAPINTERVALEXTPROC			wglSwapIntervalEXT = NULL;
			PFNWGLGETPIXELFORMATATTRIBIVARBPROC wglGetPixelFormatAttribivARB = NULL;
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::OPENGL_ES_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);
				hdc = GetDC(static_cast<HWND>(UWH.window));

				PIXELFORMATDESCRIPTOR pfd =
				{
					sizeof(PIXELFORMATDESCRIPTOR),
					1,
					PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
					PFD_TYPE_RGBA,
					32,
					8, 0,
					8, 0,
					8, 0,
					8, 0,
					0,
					0, 0, 0, 0,
					32,
					0,
					0,
					PFD_MAIN_PLANE,
					0,
					0, 0, 0
				};

				int pixelFormat = ChoosePixelFormat(hdc, &pfd);
				bool ret = SetPixelFormat(hdc, pixelFormat, &pfd);

				OGLcontext = wglCreateContext(hdc);
				if (OGLcontext == NULL) // is OpenGL functional?
					return GReturn::HARDWARE_UNAVAILABLE;

				wglMakeCurrent(hdc, OGLcontext);

				wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)wglGetProcAddress("wglGetExtensionsStringARB");
				wglGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)wglGetProcAddress("wglGetExtensionsStringEXT");
				wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress("wglCreateContextAttribsARB");
				wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress("wglSwapIntervalEXT");
				wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)wglGetProcAddress("wglGetPixelFormatAttribivARB");

				int pixelAttributes[] =
				{
					WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
					WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
					WGL_COLOR_BITS_ARB, 32,
					WGL_RED_BITS_ARB, 8,
					WGL_GREEN_BITS_ARB, 8,
					WGL_BLUE_BITS_ARB, 8,
					WGL_ALPHA_BITS_ARB, 8,
					WGL_DEPTH_BITS_ARB, 0,
					WGL_STENCIL_BITS_ARB, 0,
					WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
					WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
					0, 0
				};

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					pixelAttributes[7] = 10;
					pixelAttributes[9] = 10;
					pixelAttributes[11] = 10;
					pixelAttributes[13] = 2;
				}

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					pixelAttributes[15] = 32;

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					pixelAttributes[15] = 24;
					pixelAttributes[17] = 8;
				}

				UINT pixelCount = 0;

				PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = nullptr;
				QueryExtensionFunction("WGL_ARB_extensions_string", "wglChoosePixelFormatARB", (void**)&wglChoosePixelFormatARB);

				ret = wglChoosePixelFormatARB(hdc, pixelAttributes, NULL, 1, &pixelFormat, &pixelCount);
				ret = SetPixelFormat(hdc, pixelFormat, &pfd);

				wglMakeCurrent(NULL, NULL);
				ReleaseDC(static_cast<HWND>(UWH.window), hdc);
				wglDeleteContext(OGLcontext);

				// Create an OpenGL 3.0 Context //
				int contextAttributes[] =
				{
					WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
					WGL_CONTEXT_MINOR_VERSION_ARB, 0,
					WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
					0
				};

				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					// Create an OpenGL ES 3.0 Context //
					contextAttributes[5] = WGL_CONTEXT_ES2_PROFILE_BIT_EXT;
				}

				OGLcontext = wglCreateContextAttribsARB(hdc, 0, contextAttributes);
				wglMakeCurrent(hdc, OGLcontext);

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					glEnable(GL_DEPTH_TEST);

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
					glEnable(GL_STENCIL_TEST);

				int pfValues[6] = { 0 };
				int pfQuery[] =
				{
					WGL_RED_BITS_ARB,
					WGL_GREEN_BITS_ARB,
					WGL_BLUE_BITS_ARB,
					WGL_ALPHA_BITS_ARB,
					WGL_DEPTH_BITS_ARB,
					WGL_STENCIL_BITS_ARB
				};

				ret = wglGetPixelFormatAttribivARB(hdc, pixelFormat, PFD_MAIN_PLANE, 6, pfQuery, pfValues);

				// CHECK IF INIT FLAGS WERE MET //
				// 10 BIT COLOR //
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					if (pfValues[0] != 10 && pfValues[1] != 10 && pfValues[2] != 10)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH BUFFER SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					if (pfValues[4] == 0 || !glIsEnabled(GL_DEPTH_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH STENCIL SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					if (pfValues[5] == 0 || !glIsEnabled(GL_STENCIL_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// ES CONTEXT SUPPORT //
				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					char* version = (char*)glGetString(GL_VERSION);

					if (strstr(version, "OpenGL ES") == NULL)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DIRECT2D SUPPORT //
				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				// Call back event handler for OpenGL
				return receiver.Create(gwindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					receiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE:
					case GW::SYSTEM::GWindow::Events::DESTROY:
						break;

					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					case GW::SYSTEM::GWindow::Events::RESIZE:
					case GW::SYSTEM::GWindow::Events::MOVE:
					{
						gwindow.GetClientWidth(width);
						gwindow.GetClientHeight(height);
						aspectRatio = static_cast<float>(width) / static_cast<float>(height);
						glViewport(0, 0, width, height);
					}
					break;
					}
				});
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetContext(void** _outContext) const override
			{
				if (!OGLcontext)
					return GReturn::FAILURE;

				*_outContext = OGLcontext;
				return GReturn::SUCCESS;
			}

			GReturn UniversalSwapBuffers() override
			{
				if (!hdc)
					return GReturn::FAILURE;

				SwapBuffers(hdc);
				return GReturn::SUCCESS;
			}

			GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) override
			{
				if ((_funcName == nullptr && _outFuncAddress != nullptr) ||
					(_funcName != nullptr && _outFuncAddress == nullptr) ||
					_extension == nullptr && _funcName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				// User only passed in function name, without extension //
				if (_extension == nullptr && _funcName != nullptr && _outFuncAddress != nullptr)
				{
					*_outFuncAddress = wglGetProcAddress(_funcName);
					if (*_outFuncAddress == nullptr)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User only passed in extension name, without function //
				if (_funcName == nullptr && _outFuncAddress == nullptr)
				{
					if (wglGetExtensionsStringEXT)
					{
						glExtensions = wglGetExtensionsStringEXT();
						if (strstr(glExtensions, _extension) != NULL)
							return GReturn::SUCCESS;
					}
					if (wglGetExtensionsStringARB)
					{
						glExtensions = wglGetExtensionsStringARB(hdc);
						if (strstr(glExtensions, _extension) != NULL)
							return GReturn::SUCCESS;
					}
					return GReturn::FAILURE;
				}

				// User passed in extension name and function name //
				if (wglGetExtensionsStringEXT)
				{
					glExtensions = wglGetExtensionsStringEXT();
					if (strstr(glExtensions, _extension) != NULL)
					{
						if (_funcName != NULL)
							*_outFuncAddress = wglGetProcAddress(_funcName);
						else
							*_outFuncAddress = wglGetProcAddress(_extension);
						return GReturn::SUCCESS;
					}
				}
				if (wglGetExtensionsStringARB)
				{
					glExtensions = wglGetExtensionsStringARB(hdc);
					if (strstr(glExtensions, _extension) != NULL)
					{
						if (_funcName != NULL)
							_outFuncAddress = (void**)wglGetProcAddress(_funcName);
						else
							_outFuncAddress = (void**)wglGetProcAddress(_extension);
						return GReturn::SUCCESS;
					}
				}
				return GReturn::FAILURE;
			}

			GReturn EnableSwapControl(bool _setSwapControl)
			{
				if (!wglSwapIntervalEXT)
					return GReturn::FEATURE_UNSUPPORTED;
				if (!OGLcontext)
					return GReturn::FAILURE;

				if (_setSwapControl == true)
					wglSwapIntervalEXT(1);
				else
					wglSwapIntervalEXT(0);

				return GReturn::SUCCESS;
			}

			GReturn Append(const GEvent& _inEvent) override { return receiver.Append(_inEvent); }
			GReturn Waiting(unsigned int& _outCount) const override { return receiver.Waiting(_outCount); }
			GReturn Pop(GEvent& _outEvent) override { return receiver.Pop(_outEvent); }
			GReturn Peek(GEvent& _outEvent) const override { return receiver.Peek(_outEvent); }
			GReturn Missed(unsigned int& _outCount) const override { return receiver.Missed(_outCount); }
			GReturn Clear() override { return receiver.Clear(); }
			GReturn Invoke() const override { return receiver.Invoke(); }
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) { return receiver.Find(_check, _remove); }
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) { return receiver.Find(_check, _remove, _outData); }
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GOpenGLSurface final
			: public I::GProxy<I::GOpenGLSurfaceInterface, I::GOpenGLSurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback {
				init_callback() {
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GW::CORE::GEventReceiver>;
				}
			}init;
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GOpenGLSurface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetContext)
			GATEWARE_FUNCTION(UniversalSwapBuffers)
			GATEWARE_FUNCTION(QueryExtensionFunction)
			GATEWARE_FUNCTION(EnableSwapControl)

			// reimplemented functions
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GOPENGLSURFACE_H

/*---------------------------------
|	End of GOpenGLSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GDirectX12Surface.h
----------------------------------*/
#ifndef GDIRECTX12SURFACE_H
#define GDIRECTX12SURFACE_H






namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceInterface : public virtual GEventReceiverInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& outRatio) const = 0;
			virtual GReturn GetSwapchain4(void** ppOutSwapchain) const = 0;
			virtual GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const = 0;

			virtual GReturn GetDevice(void** ppOutDevice) const = 0;

			virtual GReturn GetCommandList(void** ppOutDirectCommandList) const = 0;
			virtual GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const = 0;
			virtual GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const = 0;
			virtual GReturn GetFence(void** ppOutDirectFence) const = 0;

			virtual GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const = 0;
			virtual GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const = 0;
			virtual GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const = 0;
			virtual GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const = 0;

			virtual GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const = 0;
			virtual GReturn GetDepthStencil(void** ppOutDepthStencil) const = 0;

			virtual GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const = 0;
			virtual GReturn GetDepthStencilView(void* pOutDepthStencilView) const = 0;

			virtual GReturn StartFrame() = 0;
			virtual GReturn EndFrame(bool VSync) = 0;
		};
	}
}

// Implementaion for GDirectX12Surface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GDIRECTX12SURFACE) || defined(__APPLE__) || defined(__linux__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GDIRECTX12SURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceImplementation : public virtual GDirectX12SurfaceInterface
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) { return GReturn::FEATURE_UNSUPPORTED; }

			GReturn GetAspectRatio(float& outRatio) const override { return GReturn::FAILURE; }
			GReturn GetSwapchain4(void** ppOutSwapchain) const override { return GReturn::FAILURE; }
			GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const override { return GReturn::FAILURE; }

			GReturn GetDevice(void** ppOutDevice) const override { return GReturn::FAILURE; }

			GReturn GetCommandList(void** ppOutDirectCommandList) const override { return GReturn::FAILURE; }
			GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const override { return GReturn::FAILURE; }
			GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const override { return GReturn::FAILURE; }
			GReturn GetFence(void** ppOutDirectFence) const override { return GReturn::FAILURE; }

			GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const override { return GReturn::FAILURE; }

			GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencil(void** ppOutDepthStencil) const override { return GReturn::FAILURE; }

			GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencilView(void* pOutDepthStencilView) const override { return GReturn::FAILURE; }

			GReturn StartFrame() override { return GReturn::FAILURE; }
			GReturn EndFrame(bool VSync) override { return GReturn::FAILURE; }

			GReturn Append(const GEvent& _inEvent) override { return GReturn::FAILURE; }
			GReturn Waiting(unsigned int& _outCount) const override { return GReturn::FAILURE; }
			GReturn Pop(GEvent& _outEvent) override { return GReturn::FAILURE; }
			GReturn Peek(GEvent& _outEvent) const override { return GReturn::FAILURE; }
			GReturn Missed(unsigned int& _outCount) const override { return GReturn::FAILURE; }
			GReturn Clear() override { return GReturn::FAILURE; }
			GReturn Invoke() const override { return GReturn::FAILURE; }
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) { return GReturn::FAILURE; }
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(_WIN32)
    #pragma warning(disable : 26812) // prefer enum class over enum warning
#include <wrl/client.h>
#include <dxgi1_6.h>
#if defined(_DEBUG)
#include <dxgidebug.h>
#endif
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "dxguid.lib")
#include <d3d12.h>
#pragma comment(lib, "d3d12.lib")
#include <vector>

namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceImplementation : public virtual GDirectX12SurfaceInterface,
			private virtual GEventReceiverImplementation,
			private virtual GThreadSharedImplementation
		{
		private:
			template<class T>
			void SafeRelease(T*& COMObject)
			{
				if (COMObject)
				{
					COMObject->Release();
					COMObject = nullptr;
				}
			}

			GW::SYSTEM::GWindow m_GWindow;
			GW::CORE::GEventReceiver m_GEventReceiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE m_UWH;
			unsigned int m_Width = 0;
			unsigned int m_Height = 0;
			float m_AspectRatio = 0.0f;

			bool m_Deallocated;

			static constexpr UINT m_SwapChainBufferCount = 2u; // How many swapchain back buffers will be createcd

			DXGI_FORMAT m_SwapChainBufferFormat;
			DXGI_FORMAT m_DepthBufferFormat;
			bool m_DepthBufferSupport;

			IDXGIFactory6* m_pDXGIFactory = nullptr;
			IDXGISwapChain4* m_pSwapChain = nullptr;
			IDXGIAdapter4* m_pAdapter = nullptr;

			ID3D12Device* m_pDevice = nullptr;

			struct CommandList
			{
				ID3D12CommandAllocator* m_pCommandAllocator;
				ID3D12GraphicsCommandList* m_pCommandList;

				CommandList()
				{
					m_pCommandAllocator = nullptr;
					m_pCommandList = nullptr;
				}
			} m_CommandList;

			struct CommandQueue
			{
				ID3D12CommandQueue* m_pCommandQueue;
				ID3D12Fence* m_pFence;
				HANDLE m_EventHandle; // Handle used to synchronize
				UINT64 m_FenceValue; // The fence value CPU should wait for

				operator bool()
				{
					return m_pCommandQueue && m_pFence && m_EventHandle;
				}

				void Signal()
				{
					m_pCommandQueue->Signal(m_pFence, ++m_FenceValue);
				}

				void Flush()
				{
					if (!(m_pFence->GetCompletedValue() >= m_FenceValue))
					{
						HRESULT hr = m_pFence->SetEventOnCompletion(m_FenceValue, m_EventHandle);
						if (FAILED(hr))
							return;
						::WaitForSingleObjectEx(m_EventHandle, INFINITE, FALSE);
					}
				}

				CommandQueue()
				{
					m_pCommandQueue = nullptr;
					m_pFence = nullptr;
					m_EventHandle = nullptr;
					m_FenceValue = 0u;
				}
			} m_CommandQueue;

			struct DescriptorInfo
			{
				UINT CBSRUADescriptorSize;
				UINT SamplerDescriptorSize;
				UINT RenderTargetDescriptorSize;
				UINT DepthStencilDescriptorSize;

				DescriptorInfo()
				{
					CBSRUADescriptorSize = 0;
					SamplerDescriptorSize = 0;
					RenderTargetDescriptorSize = 0;
					DepthStencilDescriptorSize = 0;
				}
			} m_DescriptorInfo;

			ID3D12DescriptorHeap* m_pRenderTargetDescriptorHeap = nullptr;
			ID3D12DescriptorHeap* m_pDepthStencilDescriptorHeap = nullptr;

			ID3D12Resource* m_pRenderTargets[m_SwapChainBufferCount] = { nullptr, nullptr };
			ID3D12Resource* m_pDepthStencil = nullptr;

			D3D12_VIEWPORT m_ScreenViewport = {};
			D3D12_RECT m_ScissorRect = {};

			GReturn CreateFactory()
			{
				UINT factoryFlags = 0;
#if defined (_DEBUG)
				factoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif
				HRESULT hr = ::CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(&m_pDXGIFactory));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn QueryAdapter()
			{
				std::vector<Microsoft::WRL::ComPtr<IDXGIAdapter4>> m_pAdapters;
				// Enumerate hardware
				{
					// Enumerating iGPU, dGPU, xGPU
					Microsoft::WRL::ComPtr<IDXGIAdapter1> pAdapter1 = nullptr;
					Microsoft::WRL::ComPtr<IDXGIAdapter4> pAdapter4 = nullptr;
					for (UINT index = 0; m_pDXGIFactory->EnumAdapterByGpuPreference(index, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(pAdapter1.GetAddressOf())) != DXGI_ERROR_NOT_FOUND; ++index)
					{
						pAdapter1.As(&pAdapter4);
						m_pAdapters.push_back(pAdapter4);
						pAdapter1.Reset();
					}
				}

				if (m_pAdapters.size() == 0)
					return GW::GReturn::HARDWARE_UNAVAILABLE;

				// Quering adapter
				{
					HRESULT hardwareResult = E_FAIL;
					DXGI_ADAPTER_DESC3 adapterDesc;

					for (unsigned int i = 0; i < static_cast<unsigned int>(m_pAdapters.size()); ++i)
					{
						HRESULT hr = m_pAdapters[i]->GetDesc3(&adapterDesc);
						if (FAILED(hr))
							return GW::GReturn::FAILURE;
						// Attempt to create a DX12 compatible device
						if ((adapterDesc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) == 0)
						{
							hardwareResult = ::D3D12CreateDevice(
								m_pAdapters[i].Get(),
								D3D_FEATURE_LEVEL_11_0,
								__uuidof(ID3D12Device), nullptr);
							if (SUCCEEDED(hardwareResult))
							{
								m_pAdapter = m_pAdapters[i].Get();
								m_pAdapter->AddRef();
								break;
							}
						}
					}

					if (!m_pAdapter)
						return GW::GReturn::HARDWARE_UNAVAILABLE;
				}
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateDevice()
			{
				HRESULT hr;
#if defined(_DEBUG)
				// NOTE: Enabling the debug layer after creating the ID3D12Device will cause the DX runtime to remove the device.
				ID3D12Debug* pDebug = nullptr;
				hr = ::D3D12GetDebugInterface(IID_PPV_ARGS(&pDebug));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				pDebug->EnableDebugLayer();
				pDebug->Release();
#endif

				// Create our virtual device used for interacting with the GPU so we can create resources
				{
					hr = ::D3D12CreateDevice(m_pAdapter, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_pDevice));
					if (FAILED(hr))
						return GW::GReturn::FAILURE;
				}

				// Query descriptor size (descriptor size vary based on GPU vendor)
				{
					m_DescriptorInfo.CBSRUADescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
					m_DescriptorInfo.SamplerDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
					m_DescriptorInfo.RenderTargetDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
					m_DescriptorInfo.DepthStencilDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);
				}
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateCommandLists()
			{
				HRESULT hr = m_pDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&m_CommandList.m_pCommandAllocator));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT,
					m_CommandList.m_pCommandAllocator,
					nullptr, IID_PPV_ARGS(&m_CommandList.m_pCommandList));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_CommandList.m_pCommandList->Close();
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateCommandQueues()
			{
				D3D12_COMMAND_QUEUE_DESC commandQueueDesc = {};
				commandQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
				commandQueueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
				commandQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
				commandQueueDesc.NodeMask = 0;
				HRESULT hr = m_pDevice->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&m_CommandQueue.m_pCommandQueue));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDevice->CreateFence(m_CommandQueue.m_FenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&m_CommandQueue.m_pFence));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				m_CommandQueue.m_EventHandle = ::CreateEventEx(nullptr, nullptr, false, EVENT_ALL_ACCESS);
				if (!m_CommandQueue.m_EventHandle)
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateSwapChain()
			{
				Microsoft::WRL::ComPtr<IDXGISwapChain4> pSwapChain;
				DXGI_SWAP_CHAIN_DESC1 swapChainDesc;
				swapChainDesc.Width = m_Width;
				swapChainDesc.Height = m_Height;
				swapChainDesc.Format = m_SwapChainBufferFormat;
				swapChainDesc.Stereo = FALSE;
				swapChainDesc.SampleDesc.Count = 1u;
				swapChainDesc.SampleDesc.Quality = 0u;
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainDesc.BufferCount = m_SwapChainBufferCount;
				swapChainDesc.Scaling = DXGI_SCALING_NONE;
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
				swapChainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
				Microsoft::WRL::ComPtr<IDXGISwapChain1> pSwapChain1;
				HRESULT hr = m_pDXGIFactory->CreateSwapChainForHwnd(m_CommandQueue.m_pCommandQueue,
					static_cast<HWND>(m_UWH.window), &swapChainDesc, nullptr, nullptr, pSwapChain1.GetAddressOf());
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDXGIFactory->MakeWindowAssociation(static_cast<HWND>(m_UWH.window), DXGI_MWA_NO_ALT_ENTER);
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = pSwapChain1.As(&pSwapChain);
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				m_pSwapChain = pSwapChain.Get();
				m_pSwapChain->AddRef();
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateDescriptorHeap()
			{
				// RT Descriptor Heap
				{
					D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc;
					descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
					descriptorHeapDesc.NumDescriptors = m_SwapChainBufferCount;
					descriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
					descriptorHeapDesc.NodeMask = 0;

					HRESULT hr = m_pDevice->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&m_pRenderTargetDescriptorHeap));
					if (FAILED(hr))
						return GW::GReturn::FAILURE;
				}

				if (m_DepthBufferSupport)
				{
					// DS Descriptor Heap
					{
						D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc;
						descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
						descriptorHeapDesc.NumDescriptors = 1;
						descriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
						descriptorHeapDesc.NodeMask = 0;

						HRESULT hr = m_pDevice->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&m_pDepthStencilDescriptorHeap));
						if (FAILED(hr))
							return GW::GReturn::FAILURE;
					}
				}
				return GW::GReturn::SUCCESS;
			}

			void Resize()
			{
				m_GWindow.GetClientWidth(m_Width);
				m_GWindow.GetClientHeight(m_Height);
				m_AspectRatio = static_cast<float>(m_Width) / static_cast<float>(m_Height);

				// Wait for GPU to finish before changing any resources
				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
				{
					// Release resources
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
						if (m_pRenderTargets[i])
							m_pRenderTargets[i]->Release();

					// Resize backbuffer
					UINT nodes[m_SwapChainBufferCount] = { 0, 0 };
					IUnknown* commandQueues[m_SwapChainBufferCount] =
					{
						m_CommandQueue.m_pCommandQueue,
						m_CommandQueue.m_pCommandQueue
					};
					m_pSwapChain->ResizeBuffers1(m_SwapChainBufferCount, m_Width, m_Height, m_SwapChainBufferFormat,
						DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH, nodes, commandQueues);

					// Recreate RT resource and descriptors
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
					{
						ID3D12Resource* pBackBuffer = nullptr;
						m_pSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));
						m_pRenderTargets[i] = pBackBuffer;
						D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc = {};
						renderTargetViewDesc.Format = m_SwapChainBufferFormat;
						renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
						renderTargetViewDesc.Texture2D.MipSlice = 0;
						renderTargetViewDesc.Texture2D.PlaneSlice = 0;
						D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle;
						cpuHandle.ptr = m_pRenderTargetDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr + (static_cast<size_t>(i) * m_DescriptorInfo.RenderTargetDescriptorSize);
						m_pDevice->CreateRenderTargetView(m_pRenderTargets[i], &renderTargetViewDesc, cpuHandle);
					}

					if (m_DepthBufferSupport)
					{
						// Recreate DS resource and descriptors
						if (m_pDepthStencil)
						{
							m_pDepthStencil->Release();
							m_pDepthStencil = nullptr;
						}

						D3D12_RESOURCE_DESC resourceDesc = {};
						resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
						resourceDesc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
						resourceDesc.Width = m_Width;
						resourceDesc.Height = m_Height;
						resourceDesc.DepthOrArraySize = resourceDesc.MipLevels = 1;
						resourceDesc.Format = m_DepthBufferFormat;
						resourceDesc.SampleDesc = { 1, 0 };
						resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
						resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

						D3D12_CLEAR_VALUE clearValue = {};
						clearValue.Format = m_DepthBufferFormat;
						clearValue.DepthStencil.Depth = 1.0f;
						clearValue.DepthStencil.Stencil = 0;

						// Create GPU Memory
						{
							D3D12_HEAP_PROPERTIES defaultHeapProperties;
							defaultHeapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;
							defaultHeapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
							defaultHeapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
							defaultHeapProperties.CreationNodeMask = 1;
							defaultHeapProperties.VisibleNodeMask = 1;
							const D3D12_HEAP_FLAGS heapFlags = D3D12_HEAP_FLAG_NONE;
							const D3D12_RESOURCE_STATES depthWriteState = D3D12_RESOURCE_STATE_DEPTH_WRITE;
							m_pDevice->CreateCommittedResource(&defaultHeapProperties, heapFlags,
								&resourceDesc, depthWriteState, &clearValue, IID_PPV_ARGS(&m_pDepthStencil));
						}

						D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = {};
						depthStencilViewDesc.Format = m_DepthBufferFormat;
						depthStencilViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
						depthStencilViewDesc.Flags = D3D12_DSV_FLAG_NONE;
						depthStencilViewDesc.Texture2D.MipSlice = 0;
						m_pDevice->CreateDepthStencilView(m_pDepthStencil, &depthStencilViewDesc, m_pDepthStencilDescriptorHeap->GetCPUDescriptorHandleForHeapStart());
					}

					// Update the viewport transform to cover the client area.
					m_ScreenViewport.TopLeftX = m_ScreenViewport.TopLeftY = 0.0f;
					m_ScreenViewport.Width = static_cast<FLOAT>(m_Width);
					m_ScreenViewport.Height = static_cast<FLOAT>(m_Height);
					m_ScreenViewport.MinDepth = 0.0f;
					m_ScreenViewport.MaxDepth = 1.0f;
					m_ScissorRect.left = m_ScissorRect.top = 0;
					m_ScissorRect.right = m_Width;
					m_ScissorRect.bottom = m_Height;
				}
				// Wait until resize is complete.
				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
			}

			void Release()
			{
				if (!m_Deallocated)
				{
					if (m_CommandQueue)
					{
						m_CommandQueue.Signal();
						m_CommandQueue.Flush();
					}
					SafeRelease(m_pDepthStencil);
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
					{
						SafeRelease(m_pRenderTargets[i]);
					}
					SafeRelease(m_pDepthStencilDescriptorHeap);
					SafeRelease(m_pRenderTargetDescriptorHeap);
					::CloseHandle(m_CommandQueue.m_EventHandle);
					if (m_CommandQueue)
					{
						m_CommandQueue.m_EventHandle = nullptr;
					}
					SafeRelease(m_CommandQueue.m_pFence);
					SafeRelease(m_CommandQueue.m_pCommandQueue);
					SafeRelease(m_CommandList.m_pCommandList);
					SafeRelease(m_CommandList.m_pCommandAllocator);
					SafeRelease(m_pDevice);
					SafeRelease(m_pAdapter);
					SafeRelease(m_pSwapChain);
					SafeRelease(m_pDXGIFactory);
					m_Deallocated = true;
				}
			}
		public:
			~GDirectX12SurfaceImplementation()
			{
				Release();
			}

			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				m_GWindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::INVALID_ARGUMENT;
				}

				// Set swap chain buffer format
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
					m_SwapChainBufferFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
				else if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
					m_SwapChainBufferFormat = DXGI_FORMAT_B8G8R8A8_UNORM;
				else
					m_SwapChainBufferFormat = DXGI_FORMAT_R8G8B8A8_UNORM;

				// If depth buffer or depth stencil support is requested, set m_DepthBufferSupport to true, else false
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT || _initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					m_DepthBufferSupport = true;
					// If depth stencil support is requested set format to DXGI_FORMAT_D24_UNORM_S8_UINT, else DXGI_FORMAT_D32_FLOAT
					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						m_DepthBufferFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						m_DepthBufferFormat = DXGI_FORMAT_D32_FLOAT;
				}
				else
					m_DepthBufferSupport = false;

				m_GWindow.GetWindowHandle(m_UWH);
				m_GWindow.GetClientWidth(m_Width);
				m_GWindow.GetClientHeight(m_Height);
				m_AspectRatio = static_cast<float>(m_Width) / static_cast<float>(m_Height);

				m_Deallocated = false;

				GReturn gr = CreateFactory();
				if (G_FAIL(gr))
					return gr;

				gr = QueryAdapter();
				if (G_FAIL(gr))
					return gr;

				gr = CreateDevice();
				if (G_FAIL(gr))
					return gr;

				gr = CreateCommandLists();
				if (G_FAIL(gr))
					return gr;

				gr = CreateCommandQueues();
				if (G_FAIL(gr))
					return gr;

				gr = CreateSwapChain();
				if (G_FAIL(gr))
					return gr;

				gr = CreateDescriptorHeap();
				if (G_FAIL(gr))
					return gr;

				Resize();

				return m_GEventReceiver.Create(m_GWindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					m_GEventReceiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
					case GW::SYSTEM::GWindow::Events::DESTROY:
					{
						Release();
					}
					break;

					case GW::SYSTEM::GWindow::Events::MOVE:
					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					case GW::SYSTEM::GWindow::Events::RESIZE:
					{
						Resize();
					}
					break;
					}
				});
			}

			GReturn GetAspectRatio(float& outRatio) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_GWindow)
					return GReturn::FAILURE;

				outRatio = m_AspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain4(void** ppOutSwapchain) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pSwapChain)
					return GReturn::FAILURE;

				if (!ppOutSwapchain)
					return GReturn::INVALID_ARGUMENT;

				*ppOutSwapchain = m_pSwapChain;
				m_pSwapChain->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pSwapChain)
					return GReturn::FAILURE;

				outSwapChainBufferIndex = m_pSwapChain->GetCurrentBackBufferIndex();
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** ppOutDevice) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				if (!ppOutDevice)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDevice = m_pDevice;
				m_pDevice->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandList(void** ppOutDirectCommandList) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandList.m_pCommandList)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandList)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandList = m_CommandList.m_pCommandList;
				m_CommandList.m_pCommandList->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandList.m_pCommandAllocator)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandAllocator)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandAllocator = m_CommandList.m_pCommandAllocator;
				m_CommandList.m_pCommandAllocator->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandQueue)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandQueue = m_CommandQueue.m_pCommandQueue;
				m_CommandQueue.m_pCommandQueue->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetFence(void** ppOutDirectFence) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pFence)
					return GReturn::FAILURE;

				if (!ppOutDirectFence)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectFence = m_CommandQueue.m_pFence;
				m_CommandQueue.m_pFence->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outCBSRUADescriptorSize = m_DescriptorInfo.CBSRUADescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outSamplerDescriptorSize = m_DescriptorInfo.SamplerDescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outRenderTargetDescriptorSize = m_DescriptorInfo.RenderTargetDescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outDepthStencilDescriptorSize = m_DescriptorInfo.DepthStencilDescriptorSize;
				return GReturn::SUCCESS;
			}

			GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()])
					return GReturn::FAILURE;

				if (!ppOutRenderTarget)
					return GReturn::INVALID_ARGUMENT;

				*ppOutRenderTarget = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()]->AddRef();
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencil(void** ppOutDepthStencil) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDepthStencil)
					return GReturn::FAILURE;

				if (!ppOutDepthStencil)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDepthStencil = m_pDepthStencil;
				m_pDepthStencil->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pRenderTargetDescriptorHeap)
					return GReturn::FAILURE;

				if (!pOutRenderTargetView)
					return GReturn::INVALID_ARGUMENT;

				reinterpret_cast<D3D12_CPU_DESCRIPTOR_HANDLE*>(pOutRenderTargetView)->ptr =
					m_pRenderTargetDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr + (SIZE_T(m_pSwapChain->GetCurrentBackBufferIndex()) * SIZE_T(m_DescriptorInfo.RenderTargetDescriptorSize));
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencilView(void* pOutDepthStencilView) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDepthStencilDescriptorHeap)
					return GReturn::FAILURE;

				if (!pOutDepthStencilView)
					return GReturn::INVALID_ARGUMENT;

				reinterpret_cast<D3D12_CPU_DESCRIPTOR_HANDLE*>(pOutDepthStencilView)->ptr = m_pDepthStencilDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr;
				return GReturn::SUCCESS;
			}

			GReturn StartFrame() override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue ||
					!m_CommandList.m_pCommandAllocator ||
					!m_CommandList.m_pCommandList)
					return GReturn::FAILURE;

				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
				m_CommandList.m_pCommandAllocator->Reset();
				m_CommandList.m_pCommandList->Reset(m_CommandList.m_pCommandAllocator, nullptr);

				D3D12_RESOURCE_BARRIER rtTransitionBarrier = {};
				rtTransitionBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
				rtTransitionBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
				rtTransitionBarrier.Transition.pResource = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				rtTransitionBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
				rtTransitionBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
				rtTransitionBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
				m_CommandList.m_pCommandList->ResourceBarrier(1, &rtTransitionBarrier);

				m_CommandList.m_pCommandList->RSSetViewports(1, &m_ScreenViewport);
				m_CommandList.m_pCommandList->RSSetScissorRects(1, &m_ScissorRect);

				return GReturn::SUCCESS;
			}
			GReturn EndFrame(bool VSync) override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue ||
					!m_CommandList.m_pCommandAllocator ||
					!m_CommandList.m_pCommandList ||
					!m_pSwapChain)
					return GReturn::FAILURE;

				D3D12_RESOURCE_BARRIER rtTransitionBarrier = {};
				rtTransitionBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
				rtTransitionBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
				rtTransitionBarrier.Transition.pResource = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				rtTransitionBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
				rtTransitionBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
				rtTransitionBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
				m_CommandList.m_pCommandList->ResourceBarrier(1, &rtTransitionBarrier);

				ID3D12CommandList* DirectCommandList[] = { m_CommandList.m_pCommandList };
				m_CommandList.m_pCommandList->Close();
				m_CommandQueue.m_pCommandQueue->ExecuteCommandLists(1, DirectCommandList);

				UINT SyncInterval = VSync ? 1u : 0u;
				UINT PresentFlags = 0u;
				DXGI_PRESENT_PARAMETERS PresentParameters = { 0u, NULL, NULL, NULL };
				HRESULT hr = m_pSwapChain->Present1(SyncInterval, PresentFlags, &PresentParameters);
				if (FAILED(hr))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			GReturn Append(const GEvent& _inEvent) override { return m_GEventReceiver.Append(_inEvent); }
			GReturn Waiting(unsigned int& _outCount) const override { return m_GEventReceiver.Waiting(_outCount); }
			GReturn Pop(GEvent& _outEvent) override { return m_GEventReceiver.Pop(_outEvent); }
			GReturn Peek(GEvent& _outEvent) const override { return m_GEventReceiver.Peek(_outEvent); }
			GReturn Missed(unsigned int& _outCount) const override { return m_GEventReceiver.Missed(_outCount); }
			GReturn Clear() override { return m_GEventReceiver.Clear(); }
			GReturn Invoke() const override { return m_GEventReceiver.Invoke(); }
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) { return m_GEventReceiver.Find(_check, _remove); }
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) { return m_GEventReceiver.Find(_check, _remove, _outData); }
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GDirectX12Surface final
			: public I::GProxy<I::GDirectX12SurfaceInterface, I::GDirectX12SurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback {
				init_callback() {
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GW::CORE::GEventReceiver>;
				}
			}init;
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDirectX12Surface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetSwapchain4)
			GATEWARE_CONST_FUNCTION(GetSwapChainBufferIndex)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetCommandList)
			GATEWARE_CONST_FUNCTION(GetCommandAllocator)
			GATEWARE_CONST_FUNCTION(GetCommandQueue)
			GATEWARE_CONST_FUNCTION(GetFence)
			GATEWARE_CONST_FUNCTION(GetCBSRUADescriptorSize)
			GATEWARE_CONST_FUNCTION(GetSamplerDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetRenderTargetDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetDepthStencilDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetCurrentRenderTarget)
			GATEWARE_CONST_FUNCTION(GetDepthStencil)
			GATEWARE_CONST_FUNCTION(GetCurrentRenderTargetView)
			GATEWARE_CONST_FUNCTION(GetDepthStencilView)
			GATEWARE_FUNCTION(StartFrame)
			GATEWARE_FUNCTION(EndFrame)
			
			// reimplemented functions
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDIRECTX12SURFACE_H

/*---------------------------------
|	End of GDirectX12Surface.h
----------------------------------*/


/*---------------------------------
|	Begin of GRasterSurface.h
----------------------------------*/
#ifndef GRASTERSURFACE_H
#define GRASTERSURFACE_H





namespace GW
{
	namespace I
	{
		class GRasterSurfaceInterface : public virtual GEventReceiverInterface
		{
		public:
			virtual GReturn UpdateSurface(const unsigned int *_argbPixels, unsigned int _numPixels) = 0;
			virtual GReturn UpdateSurfaceSubset(const unsigned int *_argbPixels, unsigned int _startIndex, unsigned int _numRows, unsigned int _rowWidth) = 0;
			virtual GReturn SmartUpdateSurface(const unsigned int *_argbPixels, unsigned int _numPixels, unsigned int _rowWidth, unsigned int _presentOptionFlags) = 0;
			virtual GReturn SetBorderColor(unsigned int _argbColor) = 0;
			virtual GReturn LockUpdateBufferWrite(unsigned int **_outMemoryBuffer, unsigned int &_outWidth, unsigned int &_outHeight) = 0;
			virtual GReturn LockUpdateBufferRead(const unsigned int **_outMemoryBuffer, unsigned int &_outWidth, unsigned int &_outHeight) = 0;
			virtual GReturn UnlockUpdateBufferWrite() = 0;
			virtual GReturn UnlockUpdateBufferRead() = 0;
		};
	};
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GRasterSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if defined(GATEWARE_SKIP_CORE) || defined(GATEWARE_SKIP_GRASTERSURFACE) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GRASTERSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW {
	namespace I {

		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			//protected GInterfaceImplementation,
			protected GThreadSharedImplementation
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow)
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn UpdateSurface(const unsigned int *_argbPixels, unsigned int _numPixels) override
			{
				return GReturn::FAILURE;
			}
			GReturn UpdateSurfaceSubset(const unsigned int *_argbPixels, unsigned int _startIndex,
				unsigned int _numRows, unsigned int _rowWidth) override
			{
				return GReturn::FAILURE;
			}
			GReturn SmartUpdateSurface(const unsigned int *_argbPixels, unsigned int _numPixels,
				unsigned int _rowWidth, unsigned int _presentOptionFlags) override
			{
				return GReturn::FAILURE;
			}
			GReturn SetBorderColor(unsigned int _argbColor) override
			{
				return GReturn::FAILURE;
			}
			GReturn LockUpdateBufferWrite(unsigned int **_outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				return GReturn::FAILURE;
			}
			GReturn LockUpdateBufferRead(const unsigned int **_outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				return GReturn::FAILURE;
			}
			GReturn UnlockUpdateBufferWrite() override
			{
				return GReturn::FAILURE;
			}
			GReturn UnlockUpdateBufferRead() override
			{
				return GReturn::FAILURE;
			}

			GReturn Append(const GEvent& _inEvent) override
			{
				return GReturn::FAILURE;
			}

			GReturn Waiting(unsigned int& _outCount) const override
			{
				return GReturn::FAILURE;
			}

			GReturn Pop(GEvent& _outEvent) override
			{
				return GReturn::FAILURE;
			}

			GReturn Peek(GEvent& _outEvent) const override
			{
				return GReturn::FAILURE;
			}

			GReturn Missed(unsigned int& _outCount) const override
			{
				return GReturn::FAILURE;
			}

			GReturn Clear() override
			{
				return GReturn::FAILURE;
			}

			GReturn Invoke() const override
			{
				return GReturn::FAILURE;
			}

			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				return GReturn::FAILURE;
			}

			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				return GReturn::FAILURE;
			}
		};
	}
}


#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif

namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation;
	}
}

#include <stdlib.h>
#include <cstring>
#include <iostream>






//#define DEBUG_PRINTS

namespace internal_gw
{
    // GMacBLITView Interface

    // Data members of GMacBLITView
    G_OBJC_DATA_MEMBERS_STRUCT(GMacBLITView)
    {
        unsigned int* m_data;
        CGContextRef m_context;
        CGImageRef m_image;
        CGColorSpaceRef m_colorspace;

        unsigned int m_width;
        unsigned int m_height;
        unsigned int m_bitsPerComponent;
        unsigned int m_bytesPerRow;
    };

    // Forward declarations of GMacMusic methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GMacBLITView);
    
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, id, initUsingFrame, NSRect _frameRect);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, drawRect, CGRect _rect); // Override of inherited function.
    G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, BOOL, isFlipped); // Override of inherited function.
    G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, void, cleanup);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, update, unsigned int* _pixels, unsigned int _pixelCount);

    // Creates the GMacBLITView class at runtime when G_OBJC_GET_CLASS(GMacBLITView) is called.
    G_OBJC_CLASS_BEGIN(GMacBLITView, NSView)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GMacBLITView);
        
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, initUsingFrame, "@@:{CGRect={CGPoint=dd}{CGSize=dd}}", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, drawRect, "v@:{CGRect={CGPoint=dd}{CGSize=dd}}", :);
        G_OBJC_CLASS_METHOD(GMacBLITView, isFlipped, "c@:");
        G_OBJC_CLASS_METHOD(GMacBLITView, cleanup, "v@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, update, "v@:^II", ::);
    }
    G_OBJC_CLASS_END(GMacBLITView)

    // GMacBLITView Interface End
}

namespace GW {
	namespace I {

		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GThreadSharedImplementation
		{
		private:

//==============================
// ENUMS_STRUCTS_AND_CLASSES
//==============================

			typedef unsigned int Pixel;
			typedef unsigned int Color;
			typedef unsigned char ColorChannel;

//==============================
// ENUMS_STRUCTS_AND_CLASSES
//==============================

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID = -1,		
				INACTIVE = 0,		
				ACTIVE = 1,			
			};

			// class containing data unique to each buffer
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if DEBUG_PRINTS is defined
				void const DebugPrint(const char* _msg) const
				{
#ifdef DEBUG_PRINTS
					std::printf("%s buffer %s", debugName, _msg);
#endif
				}

			public:

				unsigned int*				data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				const char*					debugName = "";

				GReturn Create()
				{
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("lock W\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("lock R\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("unlock W\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("unlock R\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

//==============================
// /ENUMS_STRUCTS_AND_CLASSES
// VARIABLES
//==============================

			// Gateware types are named as:	gVariableName
			// Cocoa types are named as:	cVariableName

			GW::SYSTEM::GWindow						m_gWindow;
			GW::CORE::GEventReceiver				m_gReceiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUWH;
			GW::SYSTEM::GConcurrent					m_gDrawThread;
			unsigned int*							m_cImagePixelData = nullptr;
			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			Pixel*									m_bitmap = nullptr;
			unsigned int							m_bitmapWidth = 0;
			unsigned int							m_bitmapHeight = 0;
			Color									m_borderColor = 0xff000000;
			Buffer									m_backBuffer;
			Buffer									m_frontBuffer;
			unsigned long long						m_frameCount = 0;
            id                                      m_blitView;

//==============================
// /VARIABLES
// PRIVATE_FUNCTIONS
//==============================

			/* Prints a debug message to the console if DEBUG_PRINTS is defined.
			*	Used to assist with debugging, since multi-threading makes debugging tools harder to use.
			*	If an int value is passed as the second argument, it will be inserted into the output if _msg is a format string.
			*/
			void DebugPrint(const char* _msg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg);
#endif
			}
			void DebugPrint(const char* _msg, long long _intArg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg, _intArg);
#endif
			}

			// Inverts the byte order of a color to match the format of an NSImage.
			inline Color ColorARGBtoBGRA(Color _argbColor)
			{
				return (_argbColor & 0xFF000000) >> 24
					| (_argbColor & 0x00FF0000) >> 8
					| (_argbColor & 0x0000FF00) << 8
					| (_argbColor & 0x000000FF) << 24;
			}

			/* Destroys and recreates bitmap with new dimensions.
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint("ResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("ResizeBitmap surface invalid\n");
					DebugPrint("ResizeBitmap return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("ResizeBitmap attempt to lock main, back, front W\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("ResizeBitmap lock main, back, front W\n");
					// store new dimensions
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					DebugPrint("ResizeBitmap store args\n");
					// destroy old Cocoa objects
                    if (m_cImagePixelData)
                    {
                        free(m_cImagePixelData);
                        m_cImagePixelData = nullptr;
                    }
					DebugPrint("ResizeBitmap destroy Cocoa objects\n");
					// destroy old bitmap
					delete[] m_bitmap;
					DebugPrint("ResizeBitmap destroy bitmap\n");
					// allocate and clear new bitmap
					m_bitmap = new unsigned int[m_bitmapWidth * m_bitmapHeight * 2]; // double dimensions due to double buffer
					memset(m_bitmap, 0x00, (m_bitmapWidth * m_bitmapHeight * 2) << 2);
					DebugPrint("ResizeBitmap create and clear bitmap\n");
					// reset buffer positions
					m_backBuffer.data = &m_bitmap[0];
					m_frontBuffer.data = &m_bitmap[m_bitmapWidth * m_bitmapHeight];
					DebugPrint("ResizeBitmap reset buffers\n");
					// recreate Cocoa objects
                    m_cImagePixelData = static_cast<unsigned int*>(calloc(m_bitmapWidth * m_bitmapHeight, sizeof(unsigned int)));
                    if (m_blitView)
                    {
                        [m_blitView removeFromSuperview]; // remove the view from the window.
                        internal_gw::G_OBJC_CALL_METHOD(GMacBLITView, m_blitView, cleanup);
                        [m_blitView release];
                    }
                    NSRect windowRect = NSMakeRect(0, 0, _width, _height);
                    m_blitView = [internal_gw::G_OBJC_GET_CLASS(GMacBLITView) alloc];
                    m_blitView = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacBLITView, m_blitView, initUsingFrame, windowRect);
                    NSWindow* nsWindow = static_cast<NSWindow*>(m_gUWH.window);
                    [[nsWindow contentView] addSubview:m_blitView];
                    [nsWindow makeFirstResponder:m_blitView];
                    DebugPrint("ResizeBitmap create Cocoa objects\n");
					// mark surface as active
					m_surfaceState = SurfaceState::ACTIVE;
					DebugPrint("ResizeBitmap make surface active\n");
					// increment and store frame number in front buffer
					m_frontBuffer.frameNum = ++m_frameCount;
					DebugPrint("ResizeBitmap store frame number\n");
					// unlock and return
					DebugPrint("ResizeBitmap attempt to unlock main, back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint("ResizeBitmap unlock main, back, front W\n");
                        SwapBuffersAndDraw();
                        DebugPrint("ResizeBitmap draw\n");
						DebugPrint("ResizeBitmap return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("ResizeBitmap unexpected result\n");
				DebugPrint("ResizeBitmap return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back buffer to front for drawing and front buffer to back for new data.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint("SwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBackAndFrontBuffers surface invalid\n");
					DebugPrint("SwapBackAndFrontBuffers return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("SwapBackAndFrontBuffers attempt to lock back, front W\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("SwapBackAndFrontBuffers lock back, front W\n");
					GReturn gr;
					DebugPrint("SwapBackAndFrontBuffers compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer has new data\n");
						unsigned int *temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						DebugPrint("SwapBackAndFrontBuffers swap buffers\n");
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint("SwapBackAndFrontBuffers attempt to unlock back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SwapBackAndFrontBuffers unlock back, front W\n");
						DebugPrint("SwapBackAndFrontBuffers return\n");
						return gr;
					}
				}
				DebugPrint("SwapBackAndFrontBuffers unexpected result\n");
				DebugPrint("SwapBackAndFrontBuffers return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Draws data in front buffer to screen.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint("DrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("DrawFrontBufferToScreen surface invalid\n");
					DebugPrint("DrawFrontBufferToScreen return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("DrawFrontBufferToScreen attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("DrawFrontBufferToScreen lock front R\n");
					GReturn gr;
					// validate needed variables
					DebugPrint("DrawFrontBufferToScreen validate vars\n");
					bool gWindowValid = m_gWindow != nullptr; //must exist
                    bool frontBufferDataValid = m_frontBuffer.data != nullptr; //must exist
					bool bitmapValid = m_bitmap != nullptr; // must exist
					if (!gWindowValid
                        || !frontBufferDataValid
                        || !bitmapValid)
					{
						DebugPrint("DrawFrontBufferToScreen vars invalid (");
                        if (!gWindowValid) DebugPrint("m_gWindow [nullptr], ");
                        if (!frontBufferDataValid) DebugPrint("frontBufferDataValid [nullptr], ");
                        if (!bitmapValid) DebugPrint("m_bitmap [nullptr], ");
						// one or more needed variables were invalid
						gr = GReturn::FAILURE;
					}
					else
					{
						DebugPrint("DrawFrontBufferToScreen vars valid\n");
						// transfer data from front buffer to NSImage data buffer
						memcpy(m_cImagePixelData, m_frontBuffer.data, (m_bitmapWidth * m_bitmapHeight) << 2);
						// ensure proper pixel format before draw
                        for (int i = 0; i < m_bitmapWidth * m_bitmapHeight; ++i)
                            m_cImagePixelData[i] = ColorARGBtoBGRA(m_cImagePixelData[i]);
						// draw front buffer to screen
                        internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacBLITView, m_blitView, update, m_cImagePixelData, (m_bitmapWidth * m_bitmapHeight));
                        DebugPrint("DrawFrontBufferToScreen draw\n");
						gr = GReturn::SUCCESS;
					}
					DebugPrint("DrawFrontBufferToScreen attempt to unlock front R\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint("DrawFrontBufferToScreen unlock front R\n");
						DebugPrint("DrawFrontBufferToScreen return\n");
						return gr;
					}
				}
				DebugPrint("DrawFrontBufferToScreen unexpected result\n");
				DebugPrint("DrawFrontBufferToScreen return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back and front buffers, then draws front buffer to screen.
			*	Executes on another thread.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					Drawing failed.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint("SwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBuffersAndDraw surface invalid\n");
					DebugPrint("SwapBuffersAndDraw return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// Converge draw thread to force completion of outstanding tasks
				m_gDrawThread.Converge(0);
				DebugPrint("SwapBuffersAndDraw draw thread converge\n");
				// swap buffers and draw to screen once no tasks are waiting
				m_gDrawThread.BranchSingular([&]() mutable
				{
					if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
						DrawFrontBufferToScreen();
				});
				DebugPrint("SwapBuffersAndDraw draw thread branch singular\n");
				DebugPrint("SwapBuffersAndDraw return\n");
				return GReturn::SUCCESS;
			}

			// Interpolates linearly between two pixel color values.
			inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					(ColorChannel)(_a & 0x000000FF),
					(ColorChannel)((_a & 0x0000FF00) >> 8),
					(ColorChannel)((_a & 0x00FF0000) >> 16),
					(ColorChannel)((_a & 0xFF000000) >> 24)
				};
				ColorChannel b_channels[4] =
				{
					(ColorChannel)(_b & 0x000000FF),
					(ColorChannel)((_b & 0x0000FF00) >> 8),
					(ColorChannel)((_b & 0x00FF0000) >> 16),
					(ColorChannel)((_b & 0xFF000000) >> 24)
				};
				// get inverse of ratio
				float rInv = 1.0f - _r;
				// interpolate results
				ColorChannel result[4] =
				{
					(ColorChannel)((rInv * a_channels[0]) + (_r * b_channels[0])),
					(ColorChannel)((rInv * a_channels[1]) + (_r * b_channels[1])),
					(ColorChannel)((rInv * a_channels[2]) + (_r * b_channels[2])),
					(ColorChannel)((rInv * a_channels[3]) + (_r * b_channels[3])),
				};
				return *(Color*)result;
			}

			// Returns color at truncated integer coordinate; Faster.
			Pixel InterpolatePixelNearest(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				return _argbPixels[(unsigned int)_x + (unsigned int)_y * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			Pixel InterpolatePixelBilinear(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				// offset coordinates to use pixel corners instead of centers
				_x -= 0.5f;
				_x = _x < 0.0f ? 0.0f : _x;
				_y -= 0.5f;
				_y = _y < 0.0f ? 0.0f : _y;
				// get top-left coordinates
				unsigned int x0 = (unsigned int)(_x);
				unsigned int y0 = (unsigned int)(_y);
				// get bottom-right coordinates
				unsigned int x1 = (x0 < _width - 1) ? x0 + 1 : x0;
				unsigned int y1 = (y0 < _height - 1) ? y0 + 1 : y0;
				// calculate interpolation ratios
				float rx = _x - x0;
				float ry = _y - y0;
				// interpolate results
				return LerpColor(
					LerpColor(_argbPixels[x0 + y0 * _width], _argbPixels[x1 + y0 * _width], rx),
					LerpColor(_argbPixels[x0 + y1 * _width], _argbPixels[x1 + y1 * _width], rx),
					ry);
			}

			void Cleanup()
			{
                m_gDrawThread = nullptr; // Need to stop the draw thread before freeing up the variables used with it.
				if (m_cImagePixelData)
                {
                    free(m_cImagePixelData);
					m_cImagePixelData = nullptr;
                }
				if (m_backBuffer.data)
					m_backBuffer.data = nullptr;
				if (m_frontBuffer.data)
					m_frontBuffer.data = nullptr;
				if (m_bitmap)
				{
					delete[] m_bitmap;
					m_bitmap = nullptr;
				}
                if (m_blitView)
                {
                    [m_blitView removeFromSuperview];
                    internal_gw::G_OBJC_CALL_METHOD(GMacBLITView, m_blitView, cleanup);
                    [m_blitView release];
                    m_blitView = nullptr;
                }
			}

//==============================
// /PRIVATE_FUNCTIONS
//==============================

		public:

//==============================
// CREATE_AND_DESTROY_FUNCTIONS
//==============================

			~GRasterSurfaceImplementation()
			{
				DebugPrint("GRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint("Create\n");
				
				// validate arguments
				DebugPrint("Create validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint("m_gWindow was nullptr\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("Create args valid\n");

				// store arguments
				m_gWindow = _gWindow;
				DebugPrint("Create store args\n");

				// initialize buffers
				m_backBuffer.Create();
				m_frontBuffer.Create();
				m_backBuffer.debugName = "back";
				m_frontBuffer.debugName = "front";
				DebugPrint("Create init buffers\n");

				// get universal window handle from GWindow
				m_gWindow.GetWindowHandle(m_gUWH);
                DebugPrint("Create get window device context from gwindow\n");
				// get inner dimensions from window and resize bitmap to fit
				unsigned int newWidth, newHeight;
				m_gWindow.GetClientWidth(newWidth);
				m_gWindow.GetClientHeight(newHeight);
				DebugPrint("Create get client dimensions\n");
				ResizeBitmap(newWidth, newHeight);
				DebugPrint("Create resize\n");

				// create drawing thread object (false = no callbacks)
				m_gDrawThread.Create(false);
				DebugPrint("Create create drawing thread object\n");
				// create GReceiver and set callback function for GWindow to call
				GReturn gr = m_gReceiver.Create(m_gWindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					m_gReceiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					// respond to event
					switch (windowEvent)
					{
						case GW::SYSTEM::GWindow::Events::MINIMIZE:
						{
							DebugPrint("MINIMIZE event received\n");
							// deactivate raster when minimized to prevent updating while window is not visible
							m_surfaceState = SurfaceState::INACTIVE;
						} break;
						case GW::SYSTEM::GWindow::Events::MAXIMIZE:
						{
							DebugPrint("MAXIMIZE event received\n");
						}
						case GW::SYSTEM::GWindow::Events::RESIZE:
						{
							DebugPrint("RESIZE event received\n");
							// get inner dimensions from window and resize bitmap to fit
							ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
						} break;
						case GW::SYSTEM::GWindow::Events::DESTROY:
						{
							DebugPrint("DESTROY event received\n");
							m_surfaceState = SurfaceState::INVALID;
							Cleanup();
						} break;
						default:
						{
							DebugPrint("WARNING: unknown event received\n");
						} break;
					}
				});
				DebugPrint("Create create receiver with callback\n");
				DebugPrint("Create return\n");
				return gr;
			}

//==============================
// /CREATE_AND_DESTROY_FUNCTIONS
// UPDATE_FUNCTIONS
//==============================

			GReturn UpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels) override
			{
				DebugPrint("UpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurface surface invalid\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("UpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than one\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed bitmap pixel count
				if (_numPixels > m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's pixel count\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurface args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurface lock back W\n");
					// BLIT pixel data to internal bitmap
					memcpy(m_backBuffer.data, _argbPixels, _numPixels << 2);
					DebugPrint("UpdateSurface BLIT data\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurface attempt to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurface unlock back W\n");
						SwapBuffersAndDraw();
						DebugPrint("UpdateSurface draw\n");
						DebugPrint("UpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurface unexpected result\n");
				DebugPrint("UpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UpdateSurfaceSubset(const Pixel* _argbPixels, unsigned int _startIndex,
				unsigned int _numRows, unsigned int _rowWidth) override
			{
				DebugPrint("UpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurfaceSubset surface invalid\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("UpdateSurfaceSubset validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure starting index is within bitmap bounds
				if (_startIndex >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_startIndex was greater than surface's bounds\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure horizontal dimensions of subset are within bitmap width (also catches row width greater than bitmap width)
				if ((_startIndex % m_bitmapWidth) + _rowWidth >= m_bitmapWidth)
				{
					DebugPrint("subset width was too large (ie: _startIndex + _rowWidth >= horizontal bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure vertical dimensions of subset are within bitmap height (also catches row count greater than bitmap height)
				if ((_startIndex / m_bitmapWidth) + _numRows >= m_bitmapHeight)
				{
					DebugPrint("subset height was too large (ie: _startIndex + (_numRows * _rowWidth) >= vertical bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurfaceSubset args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurfaceSubset attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurfaceSubset lock back W\n");
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					DebugPrint("UpdateSurfaceSubset store bitmap dimensions\n");
					unsigned int endIndex = _startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					// calculate end index
					DebugPrint("UpdateSurfaceSubset calculate end index\n");
					DebugPrint("UpdateSurfaceSubset attempt to lock front R\n");
					if (+m_frontBuffer.LockAsyncRead())
					{
						DebugPrint("UpdateSurfaceSubset lock front R\n");
						// BLIT front buffer to back buffer (since anything outside the subset should be preserved)
						memcpy(m_backBuffer.data, m_frontBuffer.data, (bitmapWidth * bitmapHeight) << 2);
						DebugPrint("UpdateSurfaceSubset BLIT front buffer to back buffer\n");
						DebugPrint("UpdateSurfaceSubset attempt to unlock front R\n");
						if (+m_frontBuffer.UnlockAsyncRead())
						{
							DebugPrint("UpdateSurfaceSubset unlock front R\n");
						}
					}
					// BLIT rows of subset block to bitmap
					for (unsigned int i = _startIndex; i < endIndex; i += bitmapWidth)
						memcpy(&m_backBuffer.data[i], &_argbPixels[i], _rowWidth << 2);
					DebugPrint("UpdateSurfaceSubset BLIT subset to back buffer\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attemp to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurfaceSubset attemp to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurfaceSubset unlock back W\n");
						SwapBuffersAndDraw();
						DebugPrint("UpdateSurfaceSubset draw\n");
						DebugPrint("UpdateSurfaceSubset return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurfaceSubset unexpected result\n");
				DebugPrint("UpdateSurfaceSubset return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn SmartUpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels,
				unsigned int _rowWidth, unsigned int _presentOptionFlags) override
			{
				DebugPrint("SmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SmartUpdateSurface surface invalid\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("SmartUpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than zero\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is within bitmap bounds
				if (_numPixels >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's bounds\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_rowWidth was less than one\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is within horizontal bounds
				if (_rowWidth >= m_bitmapWidth)
				{
					DebugPrint("_rowWidth was greater than surface's width\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}

				// bit flags are all tested together because of bit isolation macro (returning in the middle would leave it defined)
				// bit masks for isolating bit flags
				const unsigned int bitmaskAlignX =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;

#define ISOLATE_BIT(flags, bit) ((flags >> bit) & 0x1)

				// separate flags into sections and test each section

				unsigned int testFlags = 0;
				// validate x alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignX;
				bool xAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT))
					== 0);
				// validate y alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignY;
				bool yAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM))
					== 0);
				// validate upscaling flags
				testFlags = _presentOptionFlags & bitmaskUpscale;
				bool upscaleValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT))
					== 0);
				// validate interpolation flags
				testFlags = _presentOptionFlags & bitmaskInterpolate;
				bool interpolateValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR))
					== 0);

#undef ISOLATE_BIT

				// ensure x alignment flags are valid
				if (!xAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting x alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure y alignment flags are valid
				if (!yAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting y alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure upscale flags are valid
				if (!upscaleValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting upscaling flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure interpolation flags are valid
				if (!interpolateValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting interpolation flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("SmartUpdateSurface args valid\n");

				// store bitmap dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapHeight = m_bitmapHeight;
				unsigned int bitmapWidth = m_bitmapWidth;
				Color borderColor = m_borderColor;

				// determine data dimensions after processing
				unsigned int dataWidth = _rowWidth;
				unsigned int dataHeight = _numPixels / _rowWidth;
				unsigned int processedWidth = _rowWidth;
				unsigned int processedHeight = _numPixels / _rowWidth;
				DebugPrint("SmartUpdateSurface calculate processed dimensions\n");
				// resize data dimensions
				testFlags = _presentOptionFlags & bitmaskUpscale;
				unsigned int upscale = 1; // default is no upscale
				switch (testFlags)
				{
				case GW::GRAPHICS::UPSCALE_2X:
					upscale = 2;
					break;
				case GW::GRAPHICS::UPSCALE_3X:
					upscale = 3;
					break;
				case GW::GRAPHICS::UPSCALE_4X:
					upscale = 4;
					break;
				case GW::GRAPHICS::UPSCALE_8X:
					upscale = 8;
					break;
				case GW::GRAPHICS::UPSCALE_16X:
					upscale = 16;
					break;
				case GW::GRAPHICS::STRETCH_TO_FIT:
					processedWidth = bitmapWidth;
					processedHeight = bitmapHeight;
					break;
				default:
					break;
				}
				processedWidth *= upscale;
				processedHeight *= upscale;
				DebugPrint("SmartUpdateSurface upscale dimensions\n");

				// calculate pixel coordinate scaling ratios
				float rx = (float)dataWidth / (float)processedWidth;
				float ry = (float)dataHeight / (float)processedHeight;
				DebugPrint("SmartUpdateSurface calculate coordinate scaling ratios\n");

				// determine X alignment
				testFlags = _presentOptionFlags & bitmaskAlignX;
				int offsetX;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_X_LEFT:
					offsetX = 0;
					break;
				case GW::GRAPHICS::ALIGN_X_RIGHT:
					offsetX = (int)(bitmapWidth)-(int)(processedWidth);
					break;
				default:
				case GW::GRAPHICS::ALIGN_X_CENTER:
					offsetX = ((int)(bitmapWidth)-(int)(processedWidth)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine x alignment\n");

				// determine Y alignment
				testFlags = _presentOptionFlags & bitmaskAlignY;
				int offsetY;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_Y_TOP:
					offsetY = 0;
					break;
				case GW::GRAPHICS::ALIGN_Y_BOTTOM:
					offsetY = (int)(bitmapHeight)-(int)(processedHeight);
					break;
				default:
				case GW::GRAPHICS::ALIGN_Y_CENTER:
					offsetY = ((int)(bitmapHeight)-(int)(processedHeight)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine y alignment\n");

				// determine interpolation type
				bool useBilinear = ((_presentOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR);
				DebugPrint("SmartUpdateSurface determine interpolation type\n");

				// lock to prevent read/write conflicts
				DebugPrint("SmartUpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("SmartUpdateSurface lock back W\n");

					// clear back buffer to border color
					for (unsigned int x = 0; x < bitmapWidth; ++x) // set value to each pixel in first row
						m_backBuffer.data[x] = borderColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row
						memcpy(&m_backBuffer.data[y * bitmapWidth], &m_backBuffer.data[0], bitmapWidth << 2);
					DebugPrint("SmartUpdateSurface clear back buffer to border color\n");

					// process and transfer pixel data to back buffer
					int relativeX, relativeY;
					if (useBilinear)
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight)) // skip pixels outside fill area bounds
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelBilinear(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					else
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight)) // skip pixels outside fill area bounds
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelNearest(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					DebugPrint("SmartUpdateSurface process and store pixels\n");

					// lock main to edit variables
					DebugPrint("SmartUpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					DebugPrint("SmartUpdateSurface attempt to unlock back W\n");
					// unlock and return
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SmartUpdateSurface unlock back W\n");
                        SwapBuffersAndDraw();
                        DebugPrint("SmartUpdateSurface draw\n");
						DebugPrint("SmartUpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("SmartUpdateSurface unexpected result\n");
				DebugPrint("SmartUpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

//==============================
// /UPDATE_FUNCTIONS
//==============================

			GReturn SetBorderColor(Color _argbColor) override
			{
				DebugPrint("SetBorderColor\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SetBorderColor surface invalid\n");
					DebugPrint("SetBorderColor return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("SetBorderColor attempt to lock main W\n");
				if (+LockSyncWrite())
				{
					DebugPrint("SetBorderColor lock W\n");
					m_borderColor = _argbColor;
					DebugPrint("SetBorderColor store args\n");
					// unlock and return
					DebugPrint("SetBorderColor attempt to unlock main W\n");
					if (+UnlockSyncWrite())
					{
						DebugPrint("SetBorderColor unlock main W\n");
						DebugPrint("SetBorderColor return\n");
						return GReturn::SUCCESS; // this operation can't reasonably fail
					}
				}
				DebugPrint("SetBorderColor unexpected result\n");
				DebugPrint("SetBorderColor return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

//==============================
// LOCK_AND_UNLOCK_FUNCTIONS
//==============================

			GReturn LockUpdateBufferWrite(Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferWrite surface invalid\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferWrite attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("LockUpdateBufferWrite lock W\n");
					++m_backBuffer.numLocks;
					DebugPrint("%d write locks\n", m_backBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferWrite outputs\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferWrite unexpected result\n");
				DebugPrint("LockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn LockUpdateBufferRead(const Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferRead surface invalid\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferRead attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("LockUpdateBufferRead lock R\n");
					++m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = (const unsigned int*)m_frontBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferRead outputs\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferRead unexpected result\n");
				DebugPrint("LockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint("UnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferWrite surface invalid\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferWrite redundant\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::REDUNDANT;
				}

				if (m_backBuffer.numLocks > 0)
					--m_backBuffer.numLocks;
				DebugPrint("%d write locks\n", m_backBuffer.numLocks);

				// otherwise, unlock and return
				DebugPrint("UnlockUpdateBufferWrite attempt to unlock back W\n");
				if (+m_backBuffer.UnlockSyncWrite())
				{
					DebugPrint("UnlockUpdateBufferWrite unlock W\n");
					// lock main to edit variables
					DebugPrint("UnlockUpdateBufferWrite attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface main lock W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface main unlock W\n");
						}
					}
                    SwapBuffersAndDraw();
                    DebugPrint("UnlockUpdateBufferWrite draw\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferWrite unexpected result\n");
				DebugPrint("UnlockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint("UnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferRead surface invalid\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferRead redundant\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				DebugPrint("UnlockUpdateBufferRead attempt to unlock front R\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint("UnlockUpdateBufferRead unlock R\n");
					if (m_frontBuffer.numLocks > 0)
						--m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferRead unexpected\n");
				DebugPrint("UnlockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

//==============================
// /LOCK_AND_UNLOCK_FUNCTIONS
// GRECEIVER_OVERRIDES
//==============================

			GReturn Append(const GEvent& _inEvent) override
			{
				return m_gReceiver.Append(_inEvent);
			}
			GReturn Waiting(unsigned int& _outCount) const override
			{
				return m_gReceiver.Waiting(_outCount);
			}
			GReturn Pop(GEvent& _outEvent) override
			{
				return m_gReceiver.Pop(_outEvent);
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				return m_gReceiver.Peek(_outEvent);
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				return m_gReceiver.Missed(_outCount);
			}
			GReturn Clear() override
			{
				return m_gReceiver.Clear();
			}
			GReturn Invoke() const override
			{
				return m_gReceiver.Invoke();
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				return m_gReceiver.Find(_check, _remove);
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				return m_gReceiver.Find(_check, _remove, _outData);
			}

//==============================
// /GRECEIVER_OVERRIDES
//==============================
		};
	}
}

namespace internal_gw
{
    // GMacBLITView Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GMacBLITView);

    // Constructor
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, id, initUsingFrame, NSRect _frameRect)
    {
        //NSLog(@"initUsingFrame: %@", self);
        self = [self initWithFrame:_frameRect];
        
        if (self)
        {
            // Retrieve the data members of this instance.
            G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);
            
            selfDM.m_colorspace = CGColorSpaceCreateDeviceRGB();
            selfDM.m_bitsPerComponent = 8;
            selfDM.m_width = _frameRect.size.width;
            selfDM.m_height = _frameRect.size.height;
            selfDM.m_bytesPerRow = selfDM.m_width * sizeof(unsigned int);
            
            selfDM.m_data = static_cast<unsigned int*>(calloc(selfDM.m_width * selfDM.m_height, sizeof(unsigned int)));
            
            // kCGImageAlphaNoneSkipFirst is ARGB format but it skips the alpha channel.
            CGContextRef bitmapContext = CGBitmapContextCreate(selfDM.m_data,
                                                               static_cast<CGFloat>(selfDM.m_width),
                                                               static_cast<CGFloat>(selfDM.m_height),
                                                               selfDM.m_bitsPerComponent,
                                                               selfDM.m_bytesPerRow,
                                                               selfDM.m_colorspace,
                                                               kCGImageAlphaNoneSkipFirst);
            
            selfDM.m_image = CGBitmapContextCreateImage(bitmapContext);
            CGContextRelease(bitmapContext);
        }
        
        return self;
    }

    // Updates the view. Not to be called directly. Must use [self setNeedsDisplay:YES] to trigger call.
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, drawRect, CGRect _rect)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);
        
        // CGContext isn't available prior to calling drawRect
        if (!selfDM.m_context)
            selfDM.m_context = [[NSGraphicsContext currentContext] CGContext];
        
        if (selfDM.m_context && selfDM.m_image)
        {
            CGContextDrawImage(selfDM.m_context, _rect, selfDM.m_image);
            CGImageRelease(selfDM.m_image);
            selfDM.m_image = nil;
        }
    }

    // This override ensures the coordinate system origin is always in the upper-left corner.
    G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, BOOL, isFlipped)
    {
        return NO;
    }

    // Frees dynamic memory used by the object.
    G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, void, cleanup)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);
        
        free(selfDM.m_data);
        selfDM.m_data = nullptr;
        
        if (selfDM.m_image)
        {
            CGImageRelease(selfDM.m_image);
            selfDM.m_image = nil;
        }
    }

    // Creates image to be displayed from given pixels.
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, update, unsigned int* _pixels, unsigned int _pixelCount)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);
        
        if (selfDM.m_image) // If this is true, then there is a frame that hasn't been drawn yet.
            return; // Rather than keep overriding frames, we drop them until the last one has been drawn.
        
        // Copy pixels into the raster data
        memcpy(selfDM.m_data, _pixels, _pixelCount * sizeof(unsigned int));
            
        // bitmapContext and image are immutable, so they need to be recreated every time.
        CGContextRef bitmapContext = CGBitmapContextCreate(selfDM.m_data,
                                                           static_cast<CGFloat>(selfDM.m_width),
                                                           static_cast<CGFloat>(selfDM.m_height),
                                                           selfDM.m_bitsPerComponent,
                                                           selfDM.m_bytesPerRow,
                                                           selfDM.m_colorspace,
                                                           kCGImageAlphaNoneSkipFirst);
        
        selfDM.m_image = CGBitmapContextCreateImage(bitmapContext);
        CGContextRelease(bitmapContext);
        
        // Notify system to redraw view and call drawRect. This must be done on the main thread.
        dispatch_async(dispatch_get_main_queue(), ^ {
            [self setNeedsDisplay:YES];
        });
    }

    // GMacBLITView Implementation End
}


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>





//#define DEBUG_PRINTS

namespace GW {
	namespace I {

		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GThreadSharedImplementation
		{
		private:

#pragma region DEFINES

			typedef unsigned int Pixel;
			typedef unsigned int Color;
			typedef unsigned char ColorChannel;

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID = -1,		
				INACTIVE = 0,		
				ACTIVE = 1,			
			};

			// class containing a pointer to bitmap memory, a GThreadShared lock, and a lock counter
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if DEBUG_PRINTS is defined
				void const DebugPrint(const char* _msg) const
				{
#ifdef DEBUG_PRINTS
					std::printf("%s buffer %s", debugName, _msg);
#endif
				}

			public:

				unsigned int*				data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				const char*					debugName = "";

				GReturn Create()
				{
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("lock W\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("lock R\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("unlock W\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("unlock R\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware types are named as:	gVariableName
			// X11 types are named as:		xVariableName

			GW::SYSTEM::GWindow						m_gWindow;
			GW::CORE::GEventReceiver				m_gReceiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUWH;
			GW::SYSTEM::GConcurrent					m_gDrawThread;
			Display*								m_xDisplay = nullptr;
			int										m_xScreen = -1;
			Window									m_xWindow;
			XImage*									m_xFrontBufferImage = nullptr;
			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			Pixel*									m_bitmap = nullptr;
			unsigned int							m_bitmapWidth = 0;
			unsigned int							m_bitmapHeight = 0;
			Color									m_borderColor = 0xff000000;
			Buffer									m_frontBuffer;
			Buffer									m_backBuffer;
			unsigned long long						m_frameCount = 0;

#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS

			/* Prints a debug message to the console if DEBUG_PRINTS is defined.
			*	Used to assist with debugging, since multi-threading makes debugging tools harder to use.
			*	If an int value is passed as the second argument, it will be inserted into the output if _msg is a format string.
			*/
			void DebugPrint(const char* _msg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg);
#endif
			}
			void DebugPrint(const char* _msg, long long _intArg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg, _intArg);
#endif
			}

			/* Destroys and recreates bitmap with new dimensions.
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint("ResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("ResizeBitmap surface invalid\n");
					DebugPrint("ResizeBitmap return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("ResizeBitmap attempt to lock main, back, front W\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("ResizeBitmap lock main, back, front W\n");
					// store new dimensions
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					DebugPrint("ResizeBitmap store args\n");
					// destroy old XImage
					if (m_xFrontBufferImage)
					{
						m_xFrontBufferImage->data = nullptr;
						XDestroyImage(m_xFrontBufferImage);
						m_xFrontBufferImage = nullptr;
						DebugPrint("ResizeBitmap destroy XImage\n");
					}
					// destroy old bitmap
					delete[] m_bitmap;
					DebugPrint("ResizeBitmap destroy bitmap\n");
					// allocate and clear new bitmap
					m_bitmap = new unsigned int[m_bitmapWidth * m_bitmapHeight * 2]; // double dimensions due to double buffer
					memset(m_bitmap, 0x00, (m_bitmapWidth * m_bitmapHeight * 2) << 2);
					DebugPrint("ResizeBitmap create and clear bitmap\n");
					// reset buffer positions
					m_backBuffer.data = &m_bitmap[0];
					m_frontBuffer.data = &m_bitmap[m_bitmapWidth * m_bitmapHeight];
					DebugPrint("ResizeBitmap reset buffers\n");
					// create new XImage
					m_xFrontBufferImage = XCreateImage(m_xDisplay, // display
						DefaultVisual(m_xDisplay, m_xScreen), // visual
						DefaultDepth(m_xDisplay, m_xScreen), // depth
						ZPixmap, // format
						0, // offset (pixels to ignore at start of scanline)
						(char*)m_frontBuffer.data, // data
						m_bitmapWidth, // image width
						m_bitmapHeight, // image height
						32, // bits per pixel
						0); // bytes per line (0 = auto-calculated)
					DebugPrint("ResizeBitmap create XImage\n");
					// mark surface as active
					m_surfaceState = SurfaceState::ACTIVE;
					DebugPrint("ResizeBitmap make surface active\n");
					// increment and store frame number in front buffer
					m_frontBuffer.frameNum = ++m_frameCount;
					DebugPrint("ResizeBitmap store frame number\n");
					// unlock and return
					DebugPrint("ResizeBitmap attempt to unlock main, back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint("ResizeBitmap unlock main, back, front W\n");
						DebugPrint("ResizeBitmap return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("ResizeBitmap unexpected result\n");
				DebugPrint("ResizeBitmap return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back buffer to front for drawing and front buffer to back for new data.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint("SwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBackAndFrontBuffers surface invalid\n");
					DebugPrint("SwapBackAndFrontBuffers return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("SwapBackAndFrontBuffers attempt to lock back, front W\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("SwapBackAndFrontBuffers lock back, front W\n");
					GReturn gr;
					DebugPrint("SwapBackAndFrontBuffers compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer has new data\n");
						unsigned int *temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						DebugPrint("SwapBackAndFrontBuffers swap buffers\n");
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint("SwapBackAndFrontBuffers attempt to unlock back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SwapBackAndFrontBuffers unlock back, front W\n");
						DebugPrint("SwapBackAndFrontBuffers return\n");
						return gr;
					}
				}
				DebugPrint("SwapBackAndFrontBuffers unexpected result\n");
				DebugPrint("SwapBackAndFrontBuffers return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Draws data in front buffer to screen.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint("DrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("DrawFrontBufferToScreen surface invalid\n");
					DebugPrint("DrawFrontBufferToScreen return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("DrawFrontBufferToScreen attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("DrawFrontBufferToScreen lock front R\n");
					GReturn gr;
					// validate needed variables
					DebugPrint("DrawFrontBufferToScreen validate vars\n");
					bool gWindowValid = m_gWindow != nullptr; // must exist
					bool xDisplayValid = m_xDisplay != nullptr; // must exist
					bool xScreenValid = m_xScreen >= 0; // must be a valid screen index
					bool xImageValid = m_xFrontBufferImage != nullptr; // must exist
					bool bitmapValid = m_bitmap != nullptr; // must exist
					bool imageDataValid = m_xFrontBufferImage->data != nullptr; // must be set
					if (!gWindowValid
						|| !xDisplayValid
						|| !xScreenValid
						|| !xImageValid
						|| !bitmapValid
						|| !imageDataValid
						)
					{
						DebugPrint("DrawFrontBufferToScreen vars invalid (");
						if (!gWindowValid) DebugPrint("m_gWindow [nullptr], ");
						if (!xDisplayValid) DebugPrint("m_xDisplay [nullptr], ");
						if (!xScreenValid) DebugPrint("m_xScreen [< 0], ");
						if (!xImageValid) DebugPrint("xImage [nullptr], ");
						if (!bitmapValid) DebugPrint("m_bitmap [nullptr], ");
						if (!imageDataValid) DebugPrint("m_xFrontBufferImage->data [nullptr], ");
						// one or more needed variables were invalid
						gr = GReturn::FAILURE;
					}
					else
					{
						DebugPrint("DrawFrontBufferToScreen vars valid\n");
						// update image's data pointer
						if (m_xFrontBufferImage)
						{
							m_xFrontBufferImage->data = (char*)m_frontBuffer.data;
							DebugPrint("SwapBackAndFrontBuffers update XImage data pointer\n");
						}
						// draw front buffer to screen
						DebugPrint("XSync");
						int result = XPutImage(m_xDisplay, m_xWindow, DefaultGC(m_xDisplay, m_xScreen), m_xFrontBufferImage,
							0, 0, 0, 0, m_bitmapWidth, m_bitmapHeight);
						DebugPrint("XPutImage [%d]\n", result);
						DebugPrint("DrawFrontBufferToScreen draw\n");
						gr = GReturn::SUCCESS;
					}
					DebugPrint("DrawFrontBufferToScreen attempt to unlock front R\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint("DrawFrontBufferToScreen unlock front R\n");
						DebugPrint("DrawFrontBufferToScreen return\n");
						return gr;
					}
				}
				DebugPrint("DrawFrontBufferToScreen unexpected result\n");
				DebugPrint("DrawFrontBufferToScreen return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back and front buffers, then draws front buffer to screen.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					Drawing failed.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint("SwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBuffersAndDraw surface invalid\n");
					DebugPrint("SwapBuffersAndDraw return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
					DrawFrontBufferToScreen();
				return GReturn::SUCCESS;
			}

			// Interpolates linearly between two pixel color values.
			inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					(ColorChannel)(_a & 0x000000FF),
					(ColorChannel)((_a & 0x0000FF00) >> 8),
					(ColorChannel)((_a & 0x00FF0000) >> 16),
					(ColorChannel)((_a & 0xFF000000) >> 24)
				};
				ColorChannel b_channels[4] =
				{
					(ColorChannel)(_b & 0x000000FF),
					(ColorChannel)((_b & 0x0000FF00) >> 8),
					(ColorChannel)((_b & 0x00FF0000) >> 16),
					(ColorChannel)((_b & 0xFF000000) >> 24)
				};
				// get inverse of ratio
				float rInv = 1.0f - _r;
				// interpolate results
				ColorChannel result[4] =
				{
					(ColorChannel)((rInv * a_channels[0]) + (_r * b_channels[0])),
					(ColorChannel)((rInv * a_channels[1]) + (_r * b_channels[1])),
					(ColorChannel)((rInv * a_channels[2]) + (_r * b_channels[2])),
					(ColorChannel)((rInv * a_channels[3]) + (_r * b_channels[3])),
				};
				return *(Color*)result;
			}

			// Returns color at truncated integer coordinate; Faster.
			Pixel InterpolatePixelNearest(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				return _argbPixels[(unsigned int)_x + (unsigned int)_y * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			Pixel InterpolatePixelBilinear(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				// offset coordinates to use pixel corners instead of centers
				_x -= 0.5f;
				_x = (_x < 0.0f) ? 0.0f : _x;
				_y -= 0.5f;
				_y = (_y < 0.0f) ? 0.0f : _y;
				// get top-left coordinates
				unsigned int x0 = (unsigned int)(_x);
				unsigned int y0 = (unsigned int)(_y);
				// get bottom-right coordinates
				unsigned int x1 = (x0 < _width - 1) ? x0 + 1 : x0;
				unsigned int y1 = (y0 < _height - 1) ? y0 + 1 : y0;
				// calculate interpolation ratios
				float rx = _x - x0;
				float ry = _y - y0;
				// interpolate results
				return LerpColor(
					LerpColor(_argbPixels[x0 + y0 * _width], _argbPixels[x1 + y0 * _width], rx),
					LerpColor(_argbPixels[x0 + y1 * _width], _argbPixels[x1 + y1 * _width], rx),
					ry);
			}

			void Cleanup()
			{
				if (m_xFrontBufferImage)
				{
					m_xFrontBufferImage->data = nullptr;
					XDestroyImage(m_xFrontBufferImage);
					m_xFrontBufferImage = nullptr;
				}
				if (m_xDisplay)
					m_xDisplay = nullptr;
				if (m_backBuffer.data)
					m_backBuffer.data = nullptr;
				if (m_frontBuffer.data)
					m_frontBuffer.data = nullptr;
				if (m_bitmap)
				{
					delete[] m_bitmap;
					m_bitmap = nullptr;
				}
			}

#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GRasterSurfaceImplementation()
			{
				DebugPrint("GRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint("Create\n");

				// validate arguments
				DebugPrint("Create validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint("m_gWindow was nullptr\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("Create args valid\n");

				// store arguments
				m_gWindow = _gWindow;
				DebugPrint("Create store args\n");

				// initialize buffers
				m_backBuffer.Create();
				m_frontBuffer.Create();
				m_backBuffer.debugName = "back";
				m_frontBuffer.debugName = "front";
				DebugPrint("Create init buffers\n");

				// get universal window handle from GWindow
				m_gWindow.GetWindowHandle(m_gUWH);
				// get X11 objects from window handle
				m_xDisplay = (Display*)m_gUWH.display;
				m_xScreen = DefaultScreen(m_xDisplay);
				m_xWindow = *((Window*)m_gUWH.window);
				DebugPrint("Create get X11 objects from gwindow\n");
				// get inner dimensions from window and resize bitmap to fit
				unsigned int newWidth, newHeight;
				m_gWindow.GetClientWidth(newWidth);
				m_gWindow.GetClientHeight(newHeight);
				DebugPrint("Create get client dimensions\n");
				ResizeBitmap(newWidth, newHeight);
				DebugPrint("Create resize\n");

				// create drawing thread object (false = no callbacks)
				m_gDrawThread.Create(false);
				DebugPrint("Create create drawing thread object\n");
				// create GReceiver and set callback function for GWindow to call
				GReturn gr = m_gReceiver.Create(m_gWindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					m_gReceiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					// respond to event
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE:
					{
						DebugPrint("MINIMIZE event received\n");
						// deactivate raster when minimized to prevent updating while window is not visible
						m_surfaceState = SurfaceState::INACTIVE;
					} break;
					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					{
						DebugPrint("MAXIMIZE event received\n");
					} // fallthrough is intentional
					case GW::SYSTEM::GWindow::Events::RESIZE:
					{
						DebugPrint("RESIZE event received\n");
						// get inner dimensions from window and resize bitmap to fit
						ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
					} break;
					case GW::SYSTEM::GWindow::Events::EVENTS_PROCESSED:
					{
						DebugPrint("EVENTS_PROCESSED event received\n");
						SwapBuffersAndDraw(); // draw newest data whenever no window events are queued
						DebugPrint("callback lambda draw\n");
					} break;
					case GW::SYSTEM::GWindow::Events::DESTROY:
					{
						DebugPrint("DESTROY event received\n");
						m_surfaceState = SurfaceState::INVALID;
						Cleanup();
					} break;
					}
				});
				DebugPrint("Create create receiver with callback\n");
				DebugPrint("Create return\n");
				return gr;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region UPDATE_FUNCTIONS

			GReturn UpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels) override
			{
				DebugPrint("UpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurface surface invalid\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				
				// validate arguments
				DebugPrint("UpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than one\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed bitmap pixel count
				if (_numPixels > m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's pixel count\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurface args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurface lock back W\n");
					// BLIT pixel data to internal bitmap
					memcpy(m_backBuffer.data, _argbPixels, _numPixels << 2);
					DebugPrint("UpdateSurface BLIT data\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurface attempt to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurface unlock back W\n");
						DebugPrint("UpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurface unexpected result\n");
				DebugPrint("UpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UpdateSurfaceSubset(const Pixel* _argbPixels, unsigned int _startIndex,
				unsigned int _numRows, unsigned int _rowWidth) override
			{
				DebugPrint("UpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurfaceSubset surface invalid\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("UpdateSurfaceSubset validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure starting index is within bitmap bounds
				if (_startIndex >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_startIndex was greater than surface's bounds\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure horizontal dimensions of subset are within bitmap width (also catches row width greater than bitmap width)
				if ((_startIndex % m_bitmapWidth) + _rowWidth >= m_bitmapWidth)
				{
					DebugPrint("subset width was too large (ie: _startIndex + _rowWidth >= horizontal bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure vertical dimensions of subset are within bitmap height (also catches row count greater than bitmap height)
				if ((_startIndex / m_bitmapWidth) + _numRows >= m_bitmapHeight)
				{
					DebugPrint("subset height was too large (ie: _startIndex + (_numRows * _rowWidth) >= vertical bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurfaceSubset args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurfaceSubset attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurfaceSubset lock back W\n");
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					DebugPrint("UpdateSurfaceSubset store bitmap dimensions\n");
					unsigned int endIndex = _startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					// calculate end index
					DebugPrint("UpdateSurfaceSubset calculate end index\n");
					DebugPrint("UpdateSurfaceSubset attempt to lock front R\n");
					if (+m_frontBuffer.LockAsyncRead())
					{
						DebugPrint("UpdateSurfaceSubset lock front R\n");
						// BLIT front buffer to back buffer (since anything outside the subset should be preserved)
						memcpy(m_backBuffer.data, m_frontBuffer.data, (bitmapWidth * bitmapHeight) << 2);
						DebugPrint("UpdateSurfaceSubset BLIT front buffer to back buffer\n");
						DebugPrint("UpdateSurfaceSubset attempt to unlock front R\n");
						if (+m_frontBuffer.UnlockAsyncRead())
						{
							DebugPrint("UpdateSurfaceSubset unlock front R\n");
						}
					}
					// BLIT rows of subset block to bitmap
					for (unsigned int i = _startIndex; i < endIndex; i += bitmapWidth)
						memcpy(&m_backBuffer.data[i], &_argbPixels[i], _rowWidth << 2);
					DebugPrint("UpdateSurfaceSubset BLIT subset to back buffer\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attemp to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurfaceSubset attemp to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurfaceSubset unlock back W\n");
						DebugPrint("UpdateSurfaceSubset return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurfaceSubset unexpected result\n");
				DebugPrint("UpdateSurfaceSubset return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn SmartUpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels,
				unsigned int _rowWidth, unsigned int _presentOptionFlags) override
			{
				DebugPrint("SmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SmartUpdateSurface surface invalid\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("SmartUpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than zero\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is within bitmap bounds
				if (_numPixels >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's bounds\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_rowWidth was less than one\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is within horizontal bounds
				if (_rowWidth >= m_bitmapWidth)
				{
					DebugPrint("_rowWidth was greater than surface's width\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}

				// bit flags are all tested together because of bit isolation macro (returning in the middle would leave it defined)

				// bit masks for isolating bit flags
				const unsigned int bitmaskAlignX =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;
				
#define ISOLATE_BIT(flags, bit) ((flags >> bit) & 0x1)
				
				// separate flags into sections and test each section
				unsigned int testFlags = 0;
				// validate x alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignX;
				bool xAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT))
					== 0);
				// validate y alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignY;
				bool yAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM))
					== 0);
				// validate upscaling flags
				testFlags = _presentOptionFlags & bitmaskUpscale;
				bool upscaleValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT))
					== 0);
				// validate interpolation flags
				testFlags = _presentOptionFlags & bitmaskInterpolate;
				bool interpolateValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR))
					== 0);

#undef ISOLATE_BIT

				// ensure x alignment flags are valid
				if (!xAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting x alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure y alignment flags are valid
				if (!yAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting y alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure upscale flags are valid
				if (!upscaleValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting upscaling flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure interpolation flags are valid
				if (!interpolateValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting interpolation flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("SmartUpdateSurface args valid\n");

				// store bitmap dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapHeight = m_bitmapHeight;
				unsigned int bitmapWidth = m_bitmapWidth;
				Color borderColor = m_borderColor;

				// determine data dimensions after processing
				unsigned int dataWidth = _rowWidth;
				unsigned int dataHeight = _numPixels / _rowWidth;
				unsigned int processedWidth = _rowWidth;
				unsigned int processedHeight = _numPixels / _rowWidth;
				DebugPrint("SmartUpdateSurface calculate processed dimensions\n");
				// resize data dimensions
				testFlags = _presentOptionFlags & bitmaskUpscale;
				unsigned int upscale = 1; // default is no upscale
				switch (testFlags)
				{
				case GW::GRAPHICS::UPSCALE_2X:
					upscale = 2;
					break;
				case GW::GRAPHICS::UPSCALE_3X:
					upscale = 3;
					break;
				case GW::GRAPHICS::UPSCALE_4X:
					upscale = 4;
					break;
				case GW::GRAPHICS::UPSCALE_8X:
					upscale = 8;
					break;
				case GW::GRAPHICS::UPSCALE_16X:
					upscale = 16;
					break;
				case GW::GRAPHICS::STRETCH_TO_FIT:
					processedWidth = bitmapWidth;
					processedHeight = bitmapHeight;
					break;
				default:
					break;
				}
				processedWidth *= upscale;
				processedHeight *= upscale;
				DebugPrint("SmartUpdateSurface upscale dimensions\n");

				// calculate pixel coordinate scaling ratios
				float rx = (float)dataWidth / (float)processedWidth;
				float ry = (float)dataHeight / (float)processedHeight;
				DebugPrint("SmartUpdateSurface calculate coordinate scaling ratios\n");

				// determine X alignment
				testFlags = _presentOptionFlags & bitmaskAlignX;
				int offsetX;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_X_LEFT:
					offsetX = 0;
					break;
				case GW::GRAPHICS::ALIGN_X_RIGHT:
					offsetX = (int)(bitmapWidth) - (int)(processedWidth);
					break;
				default:
				case GW::GRAPHICS::ALIGN_X_CENTER:
					offsetX = ((int)(bitmapWidth) - (int)(processedWidth)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine x alignment\n");

				// determine Y alignment
				testFlags = _presentOptionFlags & bitmaskAlignY;
				int offsetY;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_Y_TOP:
					offsetY = 0;
					break;
				case GW::GRAPHICS::ALIGN_Y_BOTTOM:
					offsetY = (int)(bitmapHeight)-(int)(processedHeight);
					break;
				default:
				case GW::GRAPHICS::ALIGN_Y_CENTER:
					offsetY = ((int)(bitmapHeight)-(int)(processedHeight)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine y alignment\n");

				// determine interpolation type
				bool useBilinear = ((_presentOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR);
				DebugPrint("SmartUpdateSurface determine interpolation type\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("SmartUpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("SmartUpdateSurface lock back W\n");

					// clear back buffer to border color
					for (unsigned int x = 0; x < bitmapWidth; ++x) // set value to each pixel in first row
						m_backBuffer.data[x] = borderColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row
						memcpy(&m_backBuffer.data[y * bitmapWidth], &m_backBuffer.data[0], bitmapWidth << 2);
					DebugPrint("SmartUpdateSurface clear back buffer to border color\n");

					// process and transfer pixel data to back buffer
					int relativeX, relativeY;
					if (useBilinear)
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight))
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelBilinear(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					else
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight))
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelNearest(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					DebugPrint("SmartUpdateSurface process and store pixels\n");

					// lock main to edit variables
					DebugPrint("SmartUpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					DebugPrint("SmartUpdateSurface attempt to unlock back W\n");
					// unlock and return
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SmartUpdateSurface unlock back W\n");
						DebugPrint("SmartUpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("SmartUpdateSurface unexpected result\n");
				DebugPrint("SmartUpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion UPDATE_FUNCTIONS

			GReturn SetBorderColor(Color _argbColor) override
			{
				DebugPrint("SetBorderColor\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SetBorderColor surface invalid\n");
					DebugPrint("SetBorderColor return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("SetBorderColor attempt to lock main W\n");
				if (+LockSyncWrite())
				{
					DebugPrint("SetBorderColor lock W\n");
					m_borderColor = _argbColor;
					DebugPrint("SetBorderColor store args\n");
					// unlock and return
					DebugPrint("SetBorderColor attempt to unlock main W\n");
					if (+UnlockSyncWrite())
					{
						DebugPrint("SetBorderColor unlock main W\n");
						DebugPrint("SetBorderColor return\n");
						return GReturn::SUCCESS; // this operation can't reasonably fail
					}
				}
				DebugPrint("SetBorderColor unexpected result\n");
				DebugPrint("SetBorderColor return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma region LOCK_AND_UNLOCK_FUNCTIONS

			GReturn LockUpdateBufferWrite(Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferWrite surface invalid\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferWrite attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("LockUpdateBufferWrite lock W\n");
					++m_backBuffer.numLocks;
					DebugPrint("%d write locks\n", m_backBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferWrite outputs\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferWrite unexpected result\n");
				DebugPrint("LockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn LockUpdateBufferRead(const Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferRead surface invalid\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferRead attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("LockUpdateBufferRead lock R\n");
					++m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = (const unsigned int*)m_frontBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferRead outputs\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferRead unexpected result\n");
				DebugPrint("LockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint("UnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferWrite surface invalid\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferWrite redundant\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::REDUNDANT;
				}

				if (m_backBuffer.numLocks > 0)
					--m_backBuffer.numLocks;
				DebugPrint("%d write locks\n", m_backBuffer.numLocks);

				// otherwise, unlock and return
				DebugPrint("UnlockUpdateBufferWrite attempt to unlock back W\n");
				if (+m_backBuffer.UnlockSyncWrite())
				{
					DebugPrint("UnlockUpdateBufferWrite unlock W\n");
					// lock main to edit variables
					DebugPrint("UnlockUpdateBufferWrite attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface main lock W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface main unlock W\n");
						}
					}
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferWrite unexpected result\n");
				DebugPrint("UnlockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint("UnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferRead surface invalid\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferRead redundant\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				DebugPrint("UnlockUpdateBufferRead attempt to unlock front R\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint("UnlockUpdateBufferRead unlock R\n");
					if (m_frontBuffer.numLocks > 0)
						--m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferRead unexpected\n");
				DebugPrint("UnlockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion LOCK_AND_UNLOCK_FUNCTIONS
#pragma region GRECEIVER_OVERRIDES

			GReturn Append(const GEvent& _inEvent) override
			{
				return m_gReceiver.Append(_inEvent);
			}
			GReturn Waiting(unsigned int& _outCount) const override
			{
				return m_gReceiver.Waiting(_outCount);
			}
			GReturn Pop(GEvent& _outEvent) override
			{
				return m_gReceiver.Pop(_outEvent);
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				return m_gReceiver.Peek(_outEvent);
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				return m_gReceiver.Missed(_outCount);
			}
			GReturn Clear() override
			{
				return m_gReceiver.Clear();
			}
			GReturn Invoke() const override
			{
				return m_gReceiver.Invoke();
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				return m_gReceiver.Find(_check, _remove);
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				return m_gReceiver.Find(_check, _remove, _outData);
			}

#pragma endregion GRECEIVER_OVERRIDES
		};
	}
}

#elif defined(_WIN32)
    #define WIN32_LEAN_AND_MEAN
#include <Windows.h>





//ifdef _WIN32
//#ifdef _DEBUG
//#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
//#endif // _DEBUG
//#endif // _WIN32

//#define DEBUG_PRINTS

namespace GW
{
	namespace I
	{

		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GThreadSharedImplementation
		{
		private:

#pragma region DEFINES

			typedef unsigned int Pixel;
			typedef unsigned int Color;
			typedef unsigned char ColorChannel;

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID = -1,		
				INACTIVE = 0,		
				ACTIVE = 1,			
			};

			// class containing data unique to each buffer
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if DEBUG_PRINTS is defined
				void const DebugPrint(const char* _msg) const
				{
#ifdef DEBUG_PRINTS
					std::printf("%s buffer %s", debugName, _msg);
#endif
				}

			public:

				unsigned int*				data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				const char*					debugName = "";

				GReturn Create()
				{
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("lock W\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("lock R\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("unlock W\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("unlock R\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware types are named as:	gVariableName
			// Win32 types are named as:	wVariableName

			GW::SYSTEM::GWindow						m_gWindow;
			GW::CORE::GEventReceiver				m_gReceiver;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUWH = { nullptr, nullptr };
			GW::SYSTEM::GConcurrent					m_gDrawThread;
			HDC										m_wWDC = nullptr; // window device context
			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			Pixel*									m_bitmap = nullptr;
			unsigned int							m_bitmapWidth = 0;
			unsigned int							m_bitmapHeight = 0;
			Color									m_borderColor = 0xff000000;
			Buffer									m_backBuffer;
			Buffer									m_frontBuffer;
			unsigned long long						m_frameCount = 0;

#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS

			/* Prints a debug message to the console if DEBUG_PRINTS is defined.
			*	Used to assist with debugging, since multi-threading makes debugging tools harder to use.
			*	If an int value is passed as the second argument, it will be inserted into the output if _msg is a format string.
			*/
			void DebugPrint(const char* _msg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg);
#endif
			}
			void DebugPrint(const char* _msg, long long _intArg)
			{
#ifdef DEBUG_PRINTS
				std::printf(_msg, _intArg);
#endif
			}

			/* Destroys and recreates bitmap with new dimensions.
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint("ResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("ResizeBitmap surface invalid\n");
					DebugPrint("ResizeBitmap return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("ResizeBitmap attempt to lock main, back, front W\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("ResizeBitmap lock main, back, front W\n");
					// store new dimensions
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					DebugPrint("ResizeBitmap store args\n");
					// destroy old bitmap
					delete[] m_bitmap;
					DebugPrint("ResizeBitmap destroy bitmap\n");
					// allocate and clear new bitmap
					m_bitmap = new unsigned int[static_cast<size_t>(m_bitmapWidth) * m_bitmapHeight * 2]; // double dimensions due to double buffer
					memset(m_bitmap, 0x00, (static_cast<size_t>(m_bitmapWidth) * m_bitmapHeight * 2) << 2);
					DebugPrint("ResizeBitmap create and clear bitmap\n");
					// reset buffer positions
					m_backBuffer.data = &m_bitmap[0];
					m_frontBuffer.data = &m_bitmap[m_bitmapWidth * m_bitmapHeight];
					DebugPrint("ResizeBitmap reset buffers\n");
					// mark surface as active
					m_surfaceState = SurfaceState::ACTIVE;
					DebugPrint("ResizeBitmap make surface active\n");
					// increment and store frame number in front buffer
					m_frontBuffer.frameNum = ++m_frameCount;
					DebugPrint("ResizeBitmap store frame number\n");
					// unlock and return
					DebugPrint("ResizeBitmap attempt to unlock main, back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint("ResizeBitmap unlock main, back, front W\n");
						DrawFrontBufferToScreen();
						DebugPrint("ResizeBitmap draw\n");
						DebugPrint("ResizeBitmap return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("ResizeBitmap unexpected result\n");
				DebugPrint("ResizeBitmap return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back buffer to front for drawing and front buffer to back for new data.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint("SwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBackAndFrontBuffers surface invalid\n");
					DebugPrint("SwapBackAndFrontBuffers return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("SwapBackAndFrontBuffers attempt to lock back, front W\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint("SwapBackAndFrontBuffers lock back, front W\n");
					GReturn gr;
					DebugPrint("SwapBackAndFrontBuffers compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer has new data\n");
						unsigned int* temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						DebugPrint("SwapBackAndFrontBuffers swap buffers\n");
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint("SwapBackAndFrontBuffers back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint("SwapBackAndFrontBuffers attempt to unlock back, front W\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SwapBackAndFrontBuffers unlock back, front W\n");
						DebugPrint("SwapBackAndFrontBuffers return\n");
						return gr;
					}
				}
				DebugPrint("SwapBackAndFrontBuffers unexpected result\n");
				DebugPrint("SwapBackAndFrontBuffers return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Draws data in front buffer to screen.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint("DrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("DrawFrontBufferToScreen surface invalid\n");
					DebugPrint("DrawFrontBufferToScreen return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("DrawFrontBufferToScreen attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("DrawFrontBufferToScreen lock front R\n");
					GReturn gr;
					// validate needed variables
					DebugPrint("DrawFrontBufferToScreen validate vars\n");
					bool gWindowValid = m_gWindow != nullptr; //must exist
					bool WDCValid = m_wWDC != nullptr; // must exist
					bool bitmapValid = m_bitmap != nullptr; // must exist
					if (!gWindowValid
						|| !WDCValid
						|| !bitmapValid)
					{
						DebugPrint("DrawFrontBufferToScreen vars invalid (");
						if (!gWindowValid) DebugPrint("m_gWindow [nullptr], ");
						if (!WDCValid) DebugPrint("m_wWDC [nullptr], ");
						if (!bitmapValid) DebugPrint("m_bitmap [nullptr], ");
						// one or more needed variables were invalid
						gr = GReturn::FAILURE;
					}
					else
					{
						DebugPrint("DrawFrontBufferToScreen vars valid\n");
						// prepare to draw
						BITMAPINFO toDraw;
						ZeroMemory(&toDraw, sizeof(BITMAPINFO));
						toDraw.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
						toDraw.bmiHeader.biWidth = m_bitmapWidth;
						toDraw.bmiHeader.biHeight = -int(m_bitmapHeight); // flip
						toDraw.bmiHeader.biPlanes = 1;
						toDraw.bmiHeader.biBitCount = 32;
						toDraw.bmiHeader.biCompression = BI_RGB;
						DebugPrint("DrawFrontBufferToScreen draw prep\n");
						// draw front buffer to screen
						SetDIBitsToDevice(m_wWDC, 0, 0, m_bitmapWidth, m_bitmapHeight, 0, 0, 0,
							m_bitmapHeight, m_frontBuffer.data, &toDraw, DIB_RGB_COLORS);
						DebugPrint("DrawFrontBufferToScreen draw\n");
						gr = GReturn::SUCCESS;
					}
					DebugPrint("DrawFrontBufferToScreen attempt to unlock front R\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint("DrawFrontBufferToScreen unlock front R\n");
						DebugPrint("DrawFrontBufferToScreen return\n");
						return gr;
					}
				}
				DebugPrint("DrawFrontBufferToScreen unexpected result\n");
				DebugPrint("DrawFrontBufferToScreen return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			/* Swaps back and front buffers, then draws front buffer to screen.
			*	Executes on another thread.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					Drawing failed.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint("SwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SwapBuffersAndDraw surface invalid\n");
					DebugPrint("SwapBuffersAndDraw return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// Converge draw thread to force completion of outstanding tasks
				m_gDrawThread.Converge(0);
				DebugPrint("SwapBuffersAndDraw draw thread converge\n");
				// swap buffers and draw to screen once no tasks are waiting
				m_gDrawThread.BranchSingular([&]() mutable
				{
					if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
						DrawFrontBufferToScreen();
				});
				DebugPrint("SwapBuffersAndDraw draw thread branch singular\n");
				DebugPrint("SwapBuffersAndDraw return\n");
				return GReturn::SUCCESS;
			}

			// Interpolates linearly between two pixel color values.
			static inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					(ColorChannel)(_a & 0x000000FF),
					(ColorChannel)((_a & 0x0000FF00) >> 8),
					(ColorChannel)((_a & 0x00FF0000) >> 16),
					(ColorChannel)((_a & 0xFF000000) >> 24)
				};
				ColorChannel b_channels[4] =
				{
					(ColorChannel)(_b & 0x000000FF),
					(ColorChannel)((_b & 0x0000FF00) >> 8),
					(ColorChannel)((_b & 0x00FF0000) >> 16),
					(ColorChannel)((_b & 0xFF000000) >> 24)
				};
				// get inverse of ratio once and store it to reduce number of calculations performed
				float rInv = 1.0f - _r;
				// interpolate results
				ColorChannel result[4] =
				{
					(ColorChannel)((rInv * a_channels[0]) + (_r * b_channels[0])),
					(ColorChannel)((rInv * a_channels[1]) + (_r * b_channels[1])),
					(ColorChannel)((rInv * a_channels[2]) + (_r * b_channels[2])),
					(ColorChannel)((rInv * a_channels[3]) + (_r * b_channels[3])),
				};
				return *(Color*)result;
			}

			// Returns color at truncated integer coordinate; Faster.
			Pixel InterpolatePixelNearest(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				return _argbPixels[(unsigned int)_x + (unsigned int)_y * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			Pixel InterpolatePixelBilinear(const Pixel* _argbPixels,
				unsigned int _width, unsigned int _height, float _x, float _y)
			{
				// offset coordinates to use pixel corners instead of centers
				_x -= 0.5f;
				_x = _x < 0.0f ? 0.0f : _x;
				_y -= 0.5f;
				_y = _y < 0.0f ? 0.0f : _y;
				// get top-left coordinates
				unsigned int x0 = (unsigned int)(_x);
				unsigned int y0 = (unsigned int)(_y);
				// get bottom-right coordinates
				unsigned int x1 = (x0 < _width - 1) ? x0 + 1 : x0;
				unsigned int y1 = (y0 < _height - 1) ? y0 + 1 : y0;
				// calculate interpolation ratios
				float rx = _x - x0;
				float ry = _y - y0;
				// interpolate results
				return LerpColor(
					LerpColor(_argbPixels[x0 + y0 * _width], _argbPixels[x1 + y0 * _width], rx),
					LerpColor(_argbPixels[x0 + y1 * _width], _argbPixels[x1 + y1 * _width], rx),
					ry);
			}

			void Cleanup()
			{
				if (m_backBuffer.data)
					m_backBuffer.data = nullptr;
				if (m_frontBuffer.data)
					m_frontBuffer.data = nullptr;
				if (m_bitmap)
				{
					delete[] m_bitmap;
					m_bitmap = nullptr;
				}
			}

#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GRasterSurfaceImplementation()
			{
				DebugPrint("GRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint("Create\n");

				// validate arguments
				DebugPrint("Create validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint("m_gWindow was nullptr\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("Create args valid\n");

				// store arguments
				m_gWindow = _gWindow;
				DebugPrint("Create store args\n");

				// initialize buffers
				m_backBuffer.Create();
				m_frontBuffer.Create();
				m_backBuffer.debugName = "back";
				m_frontBuffer.debugName = "front";
				DebugPrint("Create init buffers\n");

				// get universal window handle from GWindow
				m_gWindow.GetWindowHandle(m_gUWH);
				// get device context from window handle
				m_wWDC = GetDC(static_cast<HWND>(m_gUWH.window));
				DebugPrint("Create get window device context from gwindow\n");
				// get inner dimensions from window and resize bitmap to fit
				unsigned int newWidth, newHeight;
				m_gWindow.GetClientWidth(newWidth);
				m_gWindow.GetClientHeight(newHeight);
				DebugPrint("Create get client dimensions\n");
				ResizeBitmap(newWidth, newHeight);
				DebugPrint("Create resize\n");

				// create drawing thread object (false = no callbacks)
				m_gDrawThread.Create(false);
				DebugPrint("Create create drawing thread object\n");
				// create GReceiver and set callback function for GWindow to call
				GReturn gr = m_gReceiver.Create(m_gWindow, [&]()
				{
					GW::GEvent event;
					GW::SYSTEM::GWindow::Events windowEvent;
					m_gReceiver.Pop(event);
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);
					// respond to event
					switch (windowEvent)
					{
					case GW::SYSTEM::GWindow::Events::MINIMIZE:
					{
						DebugPrint("MINIMIZE event received\n");
						// deactivate raster when minimized to prevent updating while window is not visible
						m_surfaceState = SurfaceState::INACTIVE;
					} break;
					case GW::SYSTEM::GWindow::Events::MAXIMIZE:
					{
						DebugPrint("MAXIMIZE event received\n");
					} // fallthrough is intentional
					case GW::SYSTEM::GWindow::Events::RESIZE:
					{
						DebugPrint("RESIZE event received\n");
						// get inner dimensions from window and resize bitmap to fit
						ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
					} break;
					case GW::SYSTEM::GWindow::Events::DESTROY:
					{
						DebugPrint("DESTROY event received\n");
						m_surfaceState = SurfaceState::INVALID;
						Cleanup();
					} break;
					}
				});
				DebugPrint("Create create receiver with callback\n");
				DebugPrint("Create return\n");
				return gr;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region UPDATE_FUNCTIONS

			GReturn UpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels) override
			{
				DebugPrint("UpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurface surface invalid\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("UpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than one\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed bitmap pixel count
				if (_numPixels > m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's pixel count\n");
					DebugPrint("UpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurface args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurface lock back W\n");
					// BLIT pixel data to internal bitmap
					memcpy_s(m_backBuffer.data, static_cast<rsize_t>(_numPixels) << 2, _argbPixels, static_cast<rsize_t>(_numPixels) << 2);
					DebugPrint("UpdateSurface BLIT data\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurface attempt to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurface unlock back W\n");
						SwapBuffersAndDraw();
						DebugPrint("UpdateSurface draw\n");
						DebugPrint("UpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurface unexpected result\n");
				DebugPrint("UpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UpdateSurfaceSubset(const Pixel* _argbPixels, unsigned int _startIndex,
				unsigned int _numRows, unsigned int _rowWidth) override
			{
				DebugPrint("UpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UpdateSurfaceSubset surface invalid\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("UpdateSurfaceSubset validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure starting index is within bitmap bounds
				if (_startIndex >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_startIndex was greater than surface's bounds\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_numRows was less than one\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure horizontal dimensions of subset are within bitmap width (also catches row width greater than bitmap width)
				if ((_startIndex % m_bitmapWidth) + _rowWidth >= m_bitmapWidth)
				{
					DebugPrint("subset width was too large (ie: _startIndex + _rowWidth >= horizontal bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure vertical dimensions of subset are within bitmap height (also catches row count greater than bitmap height)
				if ((_startIndex / m_bitmapWidth) + _numRows >= m_bitmapHeight)
				{
					DebugPrint("subset height was too large (ie: _startIndex + (_numRows * _rowWidth) >= vertical bounds)\n");
					DebugPrint("UpdateSurfaceSubset return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("UpdateSurfaceSubset args valid\n");

				// lock back buffer to prevent read/write conflicts
				DebugPrint("UpdateSurfaceSubset attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("UpdateSurfaceSubset lock back W\n");
					// store dimensions locally
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					DebugPrint("UpdateSurfaceSubset store bitmap dimensions\n");
					// calculate end index
					unsigned int endIndex = _startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					DebugPrint("UpdateSurfaceSubset calculate end index\n");
					DebugPrint("UpdateSurfaceSubset attempt to lock front R\n");
					if (+m_frontBuffer.LockAsyncRead())
					{
						DebugPrint("UpdateSurfaceSubset lock front R\n");
						// BLIT front buffer to back buffer (since anything outside the subset should be preserved)
						memcpy_s(m_backBuffer.data, (static_cast<rsize_t>(bitmapWidth) * static_cast<rsize_t>(bitmapHeight)) << 2, m_frontBuffer.data, (static_cast<rsize_t>(bitmapWidth) * static_cast<rsize_t>(bitmapHeight)) << 2);
						DebugPrint("UpdateSurfaceSubset BLIT front buffer to back buffer\n");
						DebugPrint("UpdateSurfaceSubset attempt to unlock front R\n");
						if (+m_frontBuffer.UnlockAsyncRead())
						{
							DebugPrint("UpdateSurfaceSubset unlock front R\n");
						}
					}
					// BLIT rows of subset block to bitmap
					for (unsigned int i = _startIndex; i < endIndex; i += bitmapWidth)
						memcpy_s(&m_backBuffer.data[i], static_cast<rsize_t>(_rowWidth) << 2, &_argbPixels[i], static_cast<rsize_t>(_rowWidth) << 2);
					DebugPrint("UpdateSurfaceSubset BLIT subset to back buffer\n");
					// lock main to edit variables
					DebugPrint("UpdateSurface attemp to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("UpdateSurfaceSubset attempt to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("UpdateSurfaceSubset unlock back W\n");
						SwapBuffersAndDraw();
						DebugPrint("UpdateSurfaceSubset draw\n");
						DebugPrint("UpdateSurfaceSubset return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("UpdateSurfaceSubset unexpected result\n");
				DebugPrint("UpdateSurfaceSubset return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn SmartUpdateSurface(const Pixel* _argbPixels, unsigned int _numPixels,
				unsigned int _rowWidth, unsigned int _presentOptionFlags) override
			{
				DebugPrint("SmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SmartUpdateSurface surface invalid\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint("SmartUpdateSurface validate args\n");
				// ensure valid pixel array was passed
				if (_argbPixels == nullptr)
				{
					DebugPrint("_argbPixels was nullptr\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint("_numPixels was less than zero\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is within bitmap bounds
				if (_numPixels >= m_bitmapWidth * m_bitmapHeight)
				{
					DebugPrint("_numPixels was greater than surface's bounds\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint("_rowWidth was less than one\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is within horizontal bounds
				if (_rowWidth >= m_bitmapWidth)
				{
					DebugPrint("_rowWidth was greater than surface's width\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}

				// bit flags are all tested together because of bit isolation macro (returning in the middle would leave it defined)
				// bit masks for isolating bit flags
				const unsigned int bitmaskAlignX =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;

#define ISOLATE_BIT(flags, bit) ((flags >> bit) & 0x1)

				// separate flags into sections and test each section
				unsigned int testFlags = 0;

				// validate x alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignX;
				bool xAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT))
					== 0);
				// validate y alignment flags
				testFlags = _presentOptionFlags & bitmaskAlignY;
				bool yAlignValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM))
					== 0);
				// validate upscaling flags
				testFlags = _presentOptionFlags & bitmaskUpscale;
				bool upscaleValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT))
					== 0);
				// validate interpolation flags
				testFlags = _presentOptionFlags & bitmaskInterpolate;
				bool interpolateValid = !(testFlags != 0
					&& (ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
						^ ISOLATE_BIT(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR))
					== 0);

#undef ISOLATE_BIT

				// ensure x alignment flags are valid
				if (!xAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting x alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure y alignment flags are valid
				if (!yAlignValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting y alignment flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure upscale flags are valid
				if (!upscaleValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting upscaling flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure interpolation flags are valid
				if (!interpolateValid)
				{
					DebugPrint("_presentOptionFlags contains conflicting interpolation flags\n");
					DebugPrint("SmartUpdateSurface return\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint("SmartUpdateSurface args valid\n");

				// store bitmap dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapHeight = m_bitmapHeight;
				unsigned int bitmapWidth = m_bitmapWidth;
				Color borderColor = m_borderColor;

				// determine data dimensions after processing
				unsigned int dataWidth = _rowWidth;
				unsigned int dataHeight = _numPixels / _rowWidth;
				unsigned int processedWidth = _rowWidth;
				unsigned int processedHeight = _numPixels / _rowWidth;
				DebugPrint("SmartUpdateSurface calculate processed dimensions\n");
				// resize data dimensions
				testFlags = _presentOptionFlags & bitmaskUpscale;
				unsigned int upscale = 1; // default is no upscale
				switch (testFlags)
				{
				case GW::GRAPHICS::UPSCALE_2X:
					upscale = 2;
					break;
				case GW::GRAPHICS::UPSCALE_3X:
					upscale = 3;
					break;
				case GW::GRAPHICS::UPSCALE_4X:
					upscale = 4;
					break;
				case GW::GRAPHICS::UPSCALE_8X:
					upscale = 8;
					break;
				case GW::GRAPHICS::UPSCALE_16X:
					upscale = 16;
					break;
				case GW::GRAPHICS::STRETCH_TO_FIT:
					processedWidth = bitmapWidth;
					processedHeight = bitmapHeight;
					break;
				default:
					break;
				}
				processedWidth *= upscale;
				processedHeight *= upscale;
				DebugPrint("SmartUpdateSurface upscale dimensions\n");

				// calculate pixel coordinate scaling ratios
				float rx = (float)dataWidth / (float)processedWidth;
				float ry = (float)dataHeight / (float)processedHeight;
				DebugPrint("SmartUpdateSurface calculate coordinate scaling ratios\n");

				// determine X alignment
				testFlags = _presentOptionFlags & bitmaskAlignX;
				int offsetX;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_X_LEFT:
					offsetX = 0;
					break;
				case GW::GRAPHICS::ALIGN_X_RIGHT:
					offsetX = (int)(bitmapWidth)-(int)(processedWidth);
					break;
				default:
				case GW::GRAPHICS::ALIGN_X_CENTER:
					offsetX = ((int)(bitmapWidth)-(int)(processedWidth)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine x alignment\n");

				// determine Y alignment
				testFlags = _presentOptionFlags & bitmaskAlignY;
				int offsetY;
				switch (testFlags)
				{
				case GW::GRAPHICS::ALIGN_Y_TOP:
					offsetY = 0;
					break;
				case GW::GRAPHICS::ALIGN_Y_BOTTOM:
					offsetY = (int)(bitmapHeight) - (int)(processedHeight);
					break;
				default:
				case GW::GRAPHICS::ALIGN_Y_CENTER:
					offsetY = ((int)(bitmapHeight) - (int)(processedHeight)) >> 1;
					break;
				}
				DebugPrint("SmartUpdateSurface determine y alignment\n");

				// determine interpolation type
				bool useBilinear = ((_presentOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR);
				DebugPrint("SmartUpdateSurface determine interpolation type\n");

				// lock to prevent read/write conflicts
				DebugPrint("SmartUpdateSurface attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("SmartUpdateSurface lock back W\n");

					// clear back buffer to border color
					for (unsigned int x = 0; x < bitmapWidth; ++x) // set value to each pixel in first row
						m_backBuffer.data[x] = borderColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row
						memcpy_s(&m_backBuffer.data[y * bitmapWidth], static_cast<rsize_t>(bitmapWidth) << 2, &m_backBuffer.data[0], static_cast<rsize_t>(bitmapWidth) << 2);
					DebugPrint("SmartUpdateSurface clear back buffer to border color\n");

					// process and transfer pixel data to back buffer
					int relativeX, relativeY;
					if (useBilinear)
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight)) // skip pixels outside fill area bounds
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelBilinear(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					else
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							for (unsigned int x = 0; x < bitmapWidth; ++x)
							{
								relativeX = x - offsetX;
								relativeY = y - offsetY;
								if (relativeX >= 0
									&& relativeX < int(processedWidth)
									&& relativeY >= 0
									&& relativeY < int(processedHeight)) // skip pixels outside fill area bounds
								{
									m_backBuffer.data[x + y * bitmapWidth] = InterpolatePixelNearest(
										_argbPixels, dataWidth, dataHeight, (x - offsetX) * rx, (y - offsetY) * ry);
								}
							}
					DebugPrint("SmartUpdateSurface process and store pixels\n");

					//unsigned int(*InterpolatePixel)(const unsigned int*, unsigned int, unsigned int, float, float)
					//	= (useBilinear) ? InterpolatePixelBilinear : InterpolatePixelNearest;
					//for (unsigned int y = 0; y < bitmapHeight; ++y)
					//	for (unsigned int x = 0; x < bitmapWidth; ++x)
					//	{
					//		relativeX = x - offsetX;
					//		relativeY = y - offsetY;
					//		if (relativeX >= 0
					//			&& relativeX < int(processedWidth)
					//			&& relativeY >= 0
					//			&& relativeY < int(processedHeight)) // skip pixels outside fill area bounds
					//			m_backBuffer[x + y * bitmapWidth] = InterpolatePixel(_argbPixels, dataWidth, dataHeight, relativeX * rx, relativeY * ry);
					//	}

					// lock main to edit variables
					DebugPrint("SmartUpdateSurface attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface lock main W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface unlock main W\n");
						}
					}
					// unlock and return
					DebugPrint("SmartUpdateSurface attempt to unlock back W\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint("SmartUpdateSurface unlock back W\n");
						SwapBuffersAndDraw();
						DebugPrint("SmartUpdateSurface draw\n");
						DebugPrint("SmartUpdateSurface return\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint("SmartUpdateSurface unexpected result\n");
				DebugPrint("SmartUpdateSurface return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion UPDATE_FUNCTIONS

			GReturn SetBorderColor(Color _argbColor) override
			{
				DebugPrint("SetBorderColor\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("SetBorderColor surface invalid\n");
					DebugPrint("SetBorderColor return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint("SetBorderColor attempt to lock main W\n");
				if (+LockSyncWrite())
				{
					DebugPrint("SetBorderColor lock W\n");
					m_borderColor = _argbColor;
					DebugPrint("SetBorderColor store args\n");
					// unlock and return
					DebugPrint("SetBorderColor attempt to unlock main W\n");
					if (+UnlockSyncWrite())
					{
						DebugPrint("SetBorderColor unlock main W\n");
						DebugPrint("SetBorderColor return\n");
						return GReturn::SUCCESS; // this operation can't reasonably fail
					}
				}
				DebugPrint("SetBorderColor unexpected result\n");
				DebugPrint("SetBorderColor return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma region LOCK_AND_UNLOCK_FUNCTIONS

			GReturn LockUpdateBufferWrite(Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferWrite surface invalid\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferWrite attempt to lock back W\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint("LockUpdateBufferWrite lock W\n");
					++m_backBuffer.numLocks;
					DebugPrint("%d write locks\n", m_backBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferWrite outputs\n");
					DebugPrint("LockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferWrite unexpected result\n");
				DebugPrint("LockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn LockUpdateBufferRead(const Pixel** _outMemoryBuffer,
				unsigned int &_outWidth, unsigned int &_outHeight) override
			{
				DebugPrint("LockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("LockUpdateBufferRead surface invalid\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint("LockUpdateBufferRead attempt to lock front R\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint("LockUpdateBufferRead lock R\n");
					++m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					// give pointer to bitmap and dimensions to caller
					*_outMemoryBuffer = (const unsigned int*)m_frontBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint("LockUpdateBufferRead outputs\n");
					DebugPrint("LockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("LockUpdateBufferRead unexpected result\n");
				DebugPrint("LockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint("UnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferWrite surface invalid\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferWrite redundant\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::REDUNDANT;
				}

				if (m_backBuffer.numLocks > 0)
					--m_backBuffer.numLocks;
				DebugPrint("%d write locks\n", m_backBuffer.numLocks);

				// otherwise, unlock and return
				DebugPrint("UnlockUpdateBufferWrite attempt to unlock back W\n");
				if (+m_backBuffer.UnlockSyncWrite())
				{
					DebugPrint("UnlockUpdateBufferWrite unlock W\n");
					// lock main to edit variables
					DebugPrint("UnlockUpdateBufferWrite attempt to lock main W\n");
					if (+LockSyncWrite())
					{
						DebugPrint("UpdateSurface main lock W\n");
						// increment and store frame count in buffer
						m_backBuffer.frameNum = ++m_frameCount;
						DebugPrint("UpdateSurface increment and store frame number\n");
						// unlock main
						DebugPrint("UpdateSurface attempt to unlock main W\n");
						if (+UnlockSyncWrite())
						{
							DebugPrint("UpdateSurface main unlock W\n");
						}
					}
					SwapBuffersAndDraw();
					DebugPrint("UnlockUpdateBufferWrite draw\n");
					DebugPrint("UnlockUpdateBufferWrite return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferWrite unexpected result\n");
				DebugPrint("UnlockUpdateBufferWrite return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint("UnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint("UnlockUpdateBufferRead surface invalid\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks == 0)
				{
					DebugPrint("UnlockUpdateBufferRead redundant\n");
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				DebugPrint("UnlockUpdateBufferRead attempt to unlock front R\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint("UnlockUpdateBufferRead unlock R\n");
					if (m_frontBuffer.numLocks > 0)
						--m_frontBuffer.numLocks;
					DebugPrint("%d read locks\n", m_frontBuffer.numLocks);
					DebugPrint("UnlockUpdateBufferRead return\n");
					return GReturn::SUCCESS;
				}
				DebugPrint("UnlockUpdateBufferRead unexpected\n");
				DebugPrint("UnlockUpdateBufferRead return\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion LOCK_AND_UNLOCK_FUNCTIONS
#pragma region GRECEIVER_OVERRIDES

			GReturn Append(const GEvent& _inEvent) override
			{
				return m_gReceiver.Append(_inEvent);
			}
			GReturn Waiting(unsigned int& _outCount) const override
			{
				return m_gReceiver.Waiting(_outCount);
			}
			GReturn Pop(GEvent& _outEvent) override
			{
				return m_gReceiver.Pop(_outEvent);
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				return m_gReceiver.Peek(_outEvent);
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				return m_gReceiver.Missed(_outCount);
			}
			GReturn Clear() override
			{
				return m_gReceiver.Clear();
			}
			GReturn Invoke() const override
			{
				return m_gReceiver.Invoke();
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				return m_gReceiver.Find(_check, _remove);
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				return m_gReceiver.Find(_check, _remove, _outData);
			}

#pragma endregion GRECEIVER_OVERRIDES

		};
	}
}

//#ifdef _WIN32
//#ifdef _DEBUG
//#undef new
//#endif // _DEBUG
//#endif // _WIN32


#endif



namespace GW
{
	namespace GRAPHICS
	{
		class GRasterSurface final
			: public I::GProxy<I::GRasterSurfaceInterface, I::GRasterSurfaceImplementation, GW::SYSTEM::GWindow>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GRasterSurface)
			GATEWARE_FUNCTION(UpdateSurface)
			GATEWARE_FUNCTION(UpdateSurfaceSubset)
			GATEWARE_FUNCTION(SmartUpdateSurface)
			GATEWARE_FUNCTION(SetBorderColor)
			GATEWARE_FUNCTION(LockUpdateBufferWrite)
			GATEWARE_FUNCTION(LockUpdateBufferRead)
			GATEWARE_FUNCTION(UnlockUpdateBufferWrite)
			GATEWARE_FUNCTION(UnlockUpdateBufferRead)

			// reimplemented functions
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
};

#endif // GRASTERSURFACE_H

/*---------------------------------
|	End of GRasterSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GVulkanSurface.h
----------------------------------*/
// Currently there is no method to installing Vulkan in Linux Pipelines,
// enabling CICD feature flag skips this library entirely.
#if !defined(GATEWARE_FEATURE_FLAG_CICD)

#ifndef GVULKANSURFACE_H
#define GVULKANSURFACE_H







namespace GW
{
	namespace I
	{
		class GVulkanSurfaceInterface : public virtual GEventResponderInterface, public virtual GEventGeneratorInterface
		{
		public:
			enum class Events {
				REBUILD_PIPELINE,
				RELEASE_RESOURCES
			};

			struct EVENT_DATA {
				int eventResult;
				unsigned int surfaceExtent[2];
			};

			struct GVulkanSurfaceQueryInfo {
				unsigned long long initializationMask;
				unsigned int instanceLayerCount;
				const char** instanceLayers;
				void*		 instanceLayerProperties;
				unsigned int instanceExtensionCount;
				const char** instanceExtensions;
				void*		 instanceExtensionProperties;
				unsigned int deviceExtensionCount;
				const char** deviceExtensions;
				void*		 deviceExtensionProperties;
				void*		 physicalDeviceFeatures;
			};

			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const = 0;
			virtual GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const = 0;
			virtual GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const = 0;
			virtual GReturn GetGraphicsQueue(void** _outVkQueue) const = 0;
			virtual GReturn GetPresentQueue(void** _outVkQueue) const = 0;
			virtual GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const = 0;
			virtual GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const = 0;
			virtual GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const = 0;

			virtual GReturn GetInstance(void** _outVkInstance) const = 0;
			virtual GReturn GetSurface(void** _outVkSurfaceKHR) const = 0;
			virtual GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const = 0;
			virtual GReturn GetDevice(void** _outVkDevice) const = 0;
			virtual GReturn GetCommandPool(void** _outCommandPool) const = 0;
			virtual GReturn GetSwapchain(void** _outVkSwapchainKHR) const = 0;
			virtual GReturn GetRenderPass(void** _outRenderPass) const = 0;
			virtual GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const = 0;
			virtual GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const = 0;
			virtual GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const = 0;
			virtual GReturn GetRenderFence(const int& _index, void** _outVkFence) const = 0;

			virtual GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) = 0;
			virtual GReturn EndFrame(const bool& _vSync) = 0;
		};
	}
}

// Implementaion for GVulkanSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GVULKANSURFACE) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GVULKANSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    //The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I
	{
		class GVulkanSurfaceImplementation :	public virtual GVulkanSurfaceInterface,
												public GEventGeneratorImplementation
		{
		public:
            //Create
			GReturn Create(SYSTEM::GWindow _gwindow, unsigned long long _initMask) { return GReturn::FEATURE_UNSUPPORTED; }
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask, unsigned int _layerCount, const char** _layers,
				unsigned int _instanceExtensionCount, const char** _instanceExtensions, unsigned int _deviceExtensionCount, const char** _deviceExtensions,
				bool allPhysicalDeviceFeatures) { return GReturn::FEATURE_UNSUPPORTED; }
			GReturn Create(SYSTEM::GWindow _gWindow, GVulkanSurfaceQueryInfo* _queryInfo) { return GReturn::FEATURE_UNSUPPORTED; }

            //GVulkanSurface
			GReturn GetAspectRatio(float& _outRatio) const override              		  { return GReturn::FAILURE; }
            GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const override   { return GReturn::FAILURE; }
			GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const override { return GReturn::FAILURE; }
			GReturn GetGraphicsQueue(void** _outVkQueue) const override         		  { return GReturn::FAILURE; }
			GReturn GetPresentQueue(void** _outVkQueue) const override           		  { return GReturn::FAILURE; }
			GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const override { return GReturn::FAILURE; }
			GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const override								  { return GReturn::FAILURE; }
			GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const override          				  { return GReturn::FAILURE; }
			GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const override 		 		  { return GReturn::FAILURE; }

			GReturn GetInstance(void** _outVkInstance) const override               { return GReturn::FAILURE; }
			GReturn GetSurface(void** _outVkSurfaceKHR) const override              { return GReturn::FAILURE; }
			GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const override   { return GReturn::FAILURE; }
			GReturn GetDevice(void** _outVkDevice) const override                   { return GReturn::FAILURE; }
			GReturn GetCommandPool(void** _outCommandPool) const override           { return GReturn::FAILURE; }
			GReturn GetSwapchain(void** _outVkSwapchainKHR) const override          { return GReturn::FAILURE; }
			GReturn GetRenderPass(void** _outVkRenderPass) const override			{ return GReturn::FAILURE;}
			GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const override         { return GReturn::FAILURE; }
			GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const override { return GReturn::FAILURE; }
			GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const override { return GReturn::FAILURE; }
			GReturn GetRenderFence(const int& _index, void** _outVkFence) const override                 { return GReturn::FAILURE; }

			GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) override { return GReturn::FAILURE; }
			GReturn EndFrame(const bool& _vSync) override { return GReturn::FAILURE; }

            //GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override 						{ return GReturn::FAILURE;}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override 	{ return GReturn::FAILURE;}
			GReturn Invoke() const override													{ return GReturn::FAILURE;}
			GReturn Invoke(const GEvent& _incomingEvent) const override 					{ return GReturn::FAILURE;}
		};
    } // end I namespace
} // end GW namespace

    #define GVULKANSURFACE_DUMMY_INCLUDED
#elif defined(__APPLE__)
    //Get the Core
@import QuartzCore;

#include </usr/local/include/vulkan/vulkan.h>
#include </usr/local/include/vulkan/vulkan_macos.h>

namespace GW
{
    namespace I
    {
		class GVulkanSurfacePlatformFucts {
		public:
			//Get the Surface Extension for Macos
			const char* GetPlatformSurfaceExtension() {
				return VK_MVK_MACOS_SURFACE_EXTENSION_NAME;
			}

			//Get the platform name
			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				__block char* instance_app_name = nullptr;
				//Make sure this is on the main thread
				RUN_ON_UI_THREAD(^ {
					//Get the proper Window Handles
					NSWindow * nsWindow = reinterpret_cast<NSWindow*>(uwh.window);

				//Get the Window Title & Length
				const char* window_title = [nsWindow.title UTF8String];
				int len = strlen(window_title);

				//Create the Window Title
				if (len) {
					instance_app_name = new char[len + 1];
					strcpy(instance_app_name, window_title);
				}

				//If above fails, make a title
				if (!instance_app_name) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					instance_app_name = new char[22];
					strcpy(instance_app_name, "Gateware Application");
				}
					});

				//Return The Window Title
				return instance_app_name;
			}

			//Create the surface
			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				//Create this as a block
				__block VkResult r = VK_ERROR_FEATURE_NOT_PRESENT;

				//Make sure this is on the main thread
				RUN_ON_UI_THREAD(^ {
					//Get NSWindow
					NSWindow * nsWindow = static_cast<NSWindow*>(uwh.window);

				//Get NSView and add a metal layer
				NSView* nsView = nsWindow.contentView;
				nsView.wantsLayer = YES;
				nsView.layer = [CAMetalLayer layer];

				//Setup Create Info
				VkMacOSSurfaceCreateInfoMVK create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
				create_info.pView = nsView;
				create_info.flags = 0;
				create_info.pNext = VK_NULL_HANDLE;

				//Create the Surface
				r = vkCreateMacOSSurfaceMVK(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);

				//Hi
				//FlushOnMacEvents();
					});
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
    }
}

#elif defined(__linux__)
    //Get the Core
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <vulkan/vulkan.h>
#include <vulkan/vulkan_xlib.h>

//The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I
	{
		class GVulkanSurfacePlatformFucts {
		public:
			const char* GetPlatformSurfaceExtension() {
				return VK_KHR_XLIB_SURFACE_EXTENSION_NAME;
			}

			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				//Setup Window and Display
				Display* dpy = static_cast<Display*>(uwh.display);
				Window wnd = *(static_cast<Window*>(uwh.window));

				//Get Window Title
				XTextProperty x11_window_title;
				int status = XGetWMName(dpy, wnd, &x11_window_title);

				//Create a Window Title Separate from X11 (Cause it needs to be Free'd by X11, According to the docs)
				char* window_title = nullptr;
				uint32_t len = strlen((char*)x11_window_title.value);
				if (x11_window_title.value && len)
				{
					window_title = new char[len + 1];
					strcpy(window_title, (char*)x11_window_title.value);
				}

				//If Above Fails (status returned 0, x11 title is nullptr, x11 title is empty), Make a Default
				if (!window_title) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					window_title = new char[22];
					strcpy(window_title, "Gateware Application");
				}

				return window_title;
			}

			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				//Setup Window and Display
				Window wnd = *(static_cast<Window*>(uwh.window));
				Display* dpy = static_cast<Display*>(uwh.display);

				VkXlibSurfaceCreateInfoKHR create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
				create_info.window = wnd;
				create_info.dpy = dpy;
				create_info.flags = 0;
				create_info.pNext = VK_NULL_HANDLE;

				VkResult r = vkCreateXlibSurfaceKHR(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				//CleanupVulkanSurface();
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
	} // I
} //GW

#elif defined(_WIN32)
    #include <Windows.h>
#include <vulkan/vulkan.h>
#include <vulkan/vulkan_win32.h>
#pragma comment(lib, "vulkan-1.lib")

namespace GW
{
	namespace I
	{
		class GVulkanSurfacePlatformFucts {
		public:
			const char* GetPlatformSurfaceExtension() {
				return VK_KHR_WIN32_SURFACE_EXTENSION_NAME;
			}

			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				//Get the proper window handle
				HWND hWnd = static_cast<HWND>(uwh.window);

				//Get Window Title
				char* str = new char[255]; int len;
				len = GetWindowTextA(hWnd, str, 255) + 1;

				//Create a Window Title
				char* window_title = nullptr;
				if (len) {
					window_title = new char[len];
					strcpy_s(window_title, len, str);
				}

				//If Above Fails
				if (!window_title) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					window_title = new char[22];
					strcpy_s(window_title, 22, "Gateware Application");
				}

				delete[] str;
				return window_title;
			}

			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				HWND hWnd = static_cast<HWND>(uwh.window);
				HINSTANCE* hInst = reinterpret_cast<HINSTANCE*>(GetWindowLongPtr(static_cast<HWND>(hWnd), GWLP_HINSTANCE));

				VkWin32SurfaceCreateInfoKHR create_info;
				create_info.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
				create_info.hinstance = (*hInst) ? *hInst : nullptr;
				create_info.hwnd = hWnd;
				create_info.flags = 0;
				create_info.pNext = 0;

				VkResult r = vkCreateWin32SurfaceKHR(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
	}
}



#endif


#if !defined(GVULKANSURFACE_DUMMY_INCLUDED)
    // This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 1
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 2
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'a'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "development"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x6d438ef0d0
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v1.2a"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v1.2a (development) [6d438ef0d0]"

#endif



#ifndef GVULKANHELPER_HPP
#define GVULKANHELPER_HPP

namespace GvkHelper {
	//Extension, Layers and Enumeration Support (RETRUNS: VK_FALSE IS SUCCESS, VK_TRUE IS FAILURE)
	inline VkResult check_instance_extension_name(const char* _extension);
	inline VkResult check_instance_layer_name(const char* _layer);
	inline VkResult check_device_extension_name(const VkPhysicalDevice& _physicalDevice, const char* _extension);
	inline VkResult get_instance_extensions(uint32_t* _outCount, VkExtensionProperties** _outExtensionProperties);
	inline VkResult get_instance_layers(uint32_t* _outCount, VkLayerProperties** _outLayerProperties);
	inline VkResult get_physical_devices(const VkInstance& _instance, uint32_t* _outCount, VkPhysicalDevice** _outPhysicalDevice);
	inline VkResult get_device_extensions(const VkPhysicalDevice& _physicalDevice, uint32_t* _outCount, VkExtensionProperties** _outExtensionProperties);

	//Surface & Swapchain Information
	inline VkResult get_surface_formats(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, uint32_t* _outCount, VkSurfaceFormatKHR** _outSurfaceFormats);
	inline VkResult get_surface_present_modes(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, uint32_t* _outCount, VkPresentModeKHR** _outPresentMode);
	inline VkResult get_best_surface_formats(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkSurfaceFormatKHR* _outSurfaceFormat);
	inline VkResult get_best_surface_present_mode(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkPresentModeKHR* _outPresentMode);
	inline VkResult get_surface_extent(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, const VkExtent2D& _winSize, VkExtent2D* _outExtent3D);
	inline VkResult find_depth_format(const VkPhysicalDevice& _physicalDevice, const VkImageTiling& _tiling, const VkFormatFeatureFlags& _formatFeatureFlags, const VkFormat* _formats, VkFormat* _outDepthFormat);

	//Physical Device Information
	inline VkResult get_best_gpu(const VkSurfaceKHR& _surface, const uint32_t& _totalDevices, VkPhysicalDevice* _allPhysicalDevices, const uint32_t& _totalDeviceExtensions, const char** _deviceExtensions, uint32_t* outIndex);
	inline VkResult get_best_queue_family_indices(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, int** _outIndices, VkBool32* _outCanCompute);
	inline VkResult get_best_msaa_format(const VkPhysicalDevice& _physicalDevice, const VkSampleCountFlagBits& _idealMSAAFlag, VkSampleCountFlagBits* _outMSAAFlag);

	//Command Help
	inline VkResult signal_command_start(const VkDevice& _device, const VkCommandPool& _commandPool, VkCommandBuffer* _outCommandBuffer);
	inline VkResult signal_command_end(const VkDevice& _device, const VkQueue& _graphicsQueue, const VkCommandPool& _commandPool, VkCommandBuffer* _commandBuffer);

	//Images Creation
	inline VkResult create_image(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkExtent3D& _extent, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaBit,
		const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkAllocationCallbacks* _allocator,
		VkImage* _outImage, VkDeviceMemory* _outImageMemory);
	inline VkResult create_image_view(const VkDevice& _device, const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, const uint32_t& _mipLevels, VkAllocationCallbacks* _allocator, VkImageView* _outImageView);
	inline VkResult transition_image_layout(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _graphicsQueue, const uint32_t& _mipLevel, const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout);
	inline VkResult create_image_set(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkCommandPool& _commandPool, const VkExtent3D& _extent, const VkQueue& _graphicsQueue, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaSample, const VkFormat& _format,
		const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkImageAspectFlags& _aspectFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout, VkAllocationCallbacks* _allocator,
		VkImage* _outImage, VkImageView* _outImageView, VkDeviceMemory* _outDeviceMemory);
	inline VkResult copy_buffer_to_image(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkBuffer& buffer, const VkImage& image, const VkExtent3D& extent);
	inline VkResult create_mipmaps(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkImage& texture_image, const uint32_t& texture_width, const uint32_t& texture_height, const uint32_t& mip_levels);

	//Other useful functions
	inline VkResult find_memory_type(const VkPhysicalDevice& _physicalDevice, const uint32_t& _filter, const VkMemoryPropertyFlags& _propertyFlags, uint32_t* _outMemoryType);
	inline VkResult create_shader(const VkDevice& _device, const char* _fileName, const char* _entryPoint, const VkShaderStageFlagBits& _shaderType, VkShaderModule* _outShaderModule, VkPipelineShaderStageCreateInfo* _outStageInfo);

	//Overwite a buffer's data
	inline VkResult write_to_buffer(const VkDevice& device, VkDeviceMemory& memory, const void* data_to_write, unsigned int num_bytes)
	{
		void* data;
		VkResult r = vkMapMemory(device, memory, 0, num_bytes, 0, &data);

		if (r)
			return r;

		memcpy(data, data_to_write, num_bytes);
		vkUnmapMemory(device, memory);

		return r;
	}

	//Buffer Creation
	inline VkResult create_buffer(const VkPhysicalDevice& physical_device, const VkDevice& device, const VkDeviceSize& size, const VkBufferUsageFlags& usage_flags, const VkMemoryPropertyFlags& property_flags, VkBuffer* buffer, VkDeviceMemory* buffer_memory);
	inline VkResult copy_buffer(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _queueGraphics, const VkBuffer& _sourceBuffer, const VkBuffer& _destinationBuffer, const VkDeviceSize& _deviceSize);

	//Shader Creation
	inline VkResult read_shader_file(const char* _fileName, uint64_t* _outShaderSize, char** _outShaderFile);
	inline VkResult create_shader_module(const VkDevice& _device, const uint64_t& _shaderSize, char* _shaderString, VkShaderModule* _outShaderModule);
}
namespace GvkHelper {
//WooWoo! Optional Class!
//This is created to simulate the "optional class" in C++17
template <typename T>
class optional
{
public:
	optional() { m_Value = nullptr; }
	optional(T p_Value) { *this = p_Value; }
	~optional() { reset(); }

	void operator=(T v) { if (!m_Value) m_Value = new T; *m_Value = v; }
	T operator->() { return *m_Value; }
	T operator*() { return *m_Value; }
	const T operator->() const { return *m_Value; }
	const T operator*() const { return *m_Value; }

	const bool has_value()  const { return m_Value; }
	const T value() const { return *m_Value; }

	void reset() { if (m_Value) delete m_Value; }

private:
	T* m_Value;
};

//Internal Helper Functions
template <typename T>
inline T gvk_min(const T &x, const T &y) { return x < y ? x : y; }

inline int64_t gpu_compatibility(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, const uint32_t & _deviceExtensionCount, const char** _deviceExtensions)
{
	//Gather all device extensions
	uint32_t extension_count = 0;
	VkExtensionProperties* all_extensions = VK_NULL_HANDLE;
	VkResult r = get_device_extensions(_physicalDevice, &extension_count, &all_extensions);

	//Setup Checks
	int64_t score = 0;
	bool is_compatible = false;

	//First check the true requirement
	const char* swapchain_ext = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
	for (uint32_t i = 0; i < extension_count; ++i)
		if (!strcmp(all_extensions[i].extensionName, swapchain_ext))
		{
			is_compatible = true;
			break;
		}

	//Check if compatible
	if (!is_compatible)
		return static_cast<int64_t>(0xC000000000000000);

	//Check Swapchain Support (Format Count, Present Mode Count Checks)
	uint32_t format_count;
	r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, &format_count, VK_NULL_HANDLE);
	if (r)
		return static_cast<int64_t>(0xC000000000000000);

	uint32_t present_mode_count;
	r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, &present_mode_count, VK_NULL_HANDLE);
	if (r)
		return static_cast<int64_t>(0xC000000000000000);

	if (!(format_count && present_mode_count))
		return static_cast<int64_t>(0xC000000000000000);

	//Device Queue Compatibility
	int qf[2] = {-1, -1};
	int* pqf = qf;
	VkBool32 can_compute;
	get_best_queue_family_indices(_physicalDevice, _surface, &pqf, &can_compute);

	if (qf[0] == -1 || qf[1] == -1)
		return static_cast<int64_t>(0xC000000000000000);

	//Score if can compute
	score += can_compute ? 100000000 : 0;

	//Check other extensions that was sent.
	for (uint32_t i = 0; i < extension_count; ++i)
		for (uint32_t j = 0; j < _deviceExtensionCount; ++j)
			if (!strcmp(all_extensions[i].extensionName, _deviceExtensions[j]))
			{
				score += 1000000000;
				break;
			}

	//Passes everything. Completely Compatible
	score += static_cast<int64_t>(0x4000000000000000);
	delete[] all_extensions;
	return score;
}
inline int64_t gpu_device_type(const VkPhysicalDevice &_physicalDevice)
{
	//Gather Physical Device Properties
	VkPhysicalDeviceProperties all_properties;
	vkGetPhysicalDeviceProperties(_physicalDevice, &all_properties);
	VkPhysicalDeviceType current_type = all_properties.deviceType;

	//Score up based on Device Type
	int64_t score = 0;
	switch (current_type)
	{
	case VK_PHYSICAL_DEVICE_TYPE_OTHER:
		score += static_cast<int64_t>(0x80000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
		score += static_cast<int64_t>(0xC0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
		score += static_cast<int64_t>(0xF0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
		score += static_cast<int64_t>(0xE0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_CPU:
		break;
	default:
		break;
	}

	//Return Score
	return score;
}
inline int64_t gpu_features(const VkPhysicalDevice &physical_device)
{
	//Get the Device Features
	VkPhysicalDeviceFeatures device_feature;
	vkGetPhysicalDeviceFeatures(physical_device, &device_feature);

	//Score up the features
	int64_t score = 0;
	score += device_feature.tessellationShader * 100000000000;
	score += device_feature.geometryShader * 100000000000;
	score += device_feature.samplerAnisotropy * 50000000000;
	score += device_feature.sampleRateShading * 50000000000;
	score += device_feature.fillModeNonSolid * 10000000000;

	return score;
}
inline int64_t gpu_memory(const VkPhysicalDevice &_physicalDeviceBest, const VkPhysicalDevice &_physicalDeviceCurrent)
{
	//Get Memory Properties for current best GPU
	VkPhysicalDeviceMemoryProperties memory_properties_best = {};
	vkGetPhysicalDeviceMemoryProperties(_physicalDeviceBest, &memory_properties_best);

	//Get Memory Properties for current GPU
	VkPhysicalDeviceMemoryProperties memory_properties_current = {};
	vkGetPhysicalDeviceMemoryProperties(_physicalDeviceCurrent, &memory_properties_current);

	//Get the Memory Size for current best GPU
	uint64_t best_size = 0;
	for (uint32_t i = 0; i < memory_properties_best.memoryHeapCount; ++i)
		if (memory_properties_best.memoryHeaps[i].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
		{
			best_size = memory_properties_best.memoryHeaps[i].size;
			break;
		}

	//Get the Memory Size for current GPU
	uint64_t current_size = 0;
	for (uint32_t i = 0; i < memory_properties_current.memoryHeapCount; ++i)
		if (memory_properties_best.memoryHeaps[i].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
		{
			current_size = memory_properties_current.memoryHeaps[i].size;
			break;
		}

	if (current_size <= best_size)
		return -1;

	return 0;
}

//Extension, Layers and Enumeration Support
VkResult check_instance_extension_name(const char* _extension)
{
	//Gather all the instance extensions
	uint32_t count;
	VkExtensionProperties* available_extensions = VK_NULL_HANDLE;
	if (get_instance_extensions(&count, &available_extensions))
		return VK_NOT_READY;

	//compare all instance extensions with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_extensions[i].extensionName, _extension))
		{
			delete[] available_extensions;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_extensions;
	return VK_ERROR_EXTENSION_NOT_PRESENT;
}
VkResult check_instance_layer_name(const char* _layer)
{
	//Gather all Instance Layers
	uint32_t count;
	VkLayerProperties* available_layers = VK_NULL_HANDLE;
	if (get_instance_layers(&count, &available_layers))
		return VK_NOT_READY;

	//Compare all instance layers with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_layers[i].layerName, _layer))
		{
			delete[] available_layers;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_layers;
	return VK_ERROR_LAYER_NOT_PRESENT;
}
VkResult check_device_extension_name(const VkPhysicalDevice &_physicalDevice, const char* _extension)
{
	//Gather all the device extensions
	uint32_t count;
	VkExtensionProperties* available_extensions = VK_NULL_HANDLE;
	if (get_device_extensions(_physicalDevice, &count, &available_extensions))
		return VK_NOT_READY;

	//compare all device extensions with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_extensions[i].extensionName, _extension))
		{
			delete[] available_extensions;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_extensions;
	return VK_ERROR_EXTENSION_NOT_PRESENT;
}
VkResult get_instance_extensions(uint32_t* _outCount, VkExtensionProperties **_outExtensionProperties)
{
	//Gather All Extensions
	VkExtensionProperties* out;
	VkResult r = vkEnumerateInstanceExtensionProperties(nullptr, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no extensions. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve extensions. Abort.

	//Create a new array to hold all the extensions
	out = new VkExtensionProperties[*_outCount];
	r = vkEnumerateInstanceExtensionProperties(nullptr, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outExtensionProperties = out;

	//Return Result
	return r;
}
VkResult get_instance_layers(uint32_t* _outCount, VkLayerProperties **_outLayerProperties)
{
	//Gather All Layers
	VkLayerProperties* out;
	VkResult r = vkEnumerateInstanceLayerProperties(_outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no Layers. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve Layers. Abort.

	//Create a new array to hold all the Layers
	out = new VkLayerProperties[*_outCount];
	r = vkEnumerateInstanceLayerProperties(_outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to nullptr
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new Layer array to the parameter
	*_outLayerProperties = out;

	//Return Result
	return r;
}
VkResult get_physical_devices(const VkInstance &_instance, uint32_t *_outCount, VkPhysicalDevice **_outPhysicalDevice)
{
	//Gather All Devices
	VkPhysicalDevice* out;
	VkResult r = vkEnumeratePhysicalDevices(_instance, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no devices. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve devices. Abort.

	//Create a new array to hold all the devices
	out = new VkPhysicalDevice[*_outCount];
	r = vkEnumeratePhysicalDevices(_instance, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new device array to the parameter
	*_outPhysicalDevice = out;

	//Return Result
	return r;
}
VkResult get_device_extensions(const VkPhysicalDevice &_physicalDevice, uint32_t *_outCount, VkExtensionProperties **_outExtensionProperties)
{
	//Gather All Extensions
	VkExtensionProperties* out;
	VkResult r = vkEnumerateDeviceExtensionProperties(_physicalDevice, nullptr, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no extensions. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve extensions. Abort.

	//Create a new array to hold all the extensions
	out = new VkExtensionProperties[*_outCount];
	r = vkEnumerateDeviceExtensionProperties(_physicalDevice, nullptr, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outExtensionProperties = out;

	//Return Result
	return r;
}

//Surface & Swapchain Information
VkResult get_surface_formats(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, uint32_t *_outCount, VkSurfaceFormatKHR **_outSurfaceFormats)
{
	//Gather all the surface formats
	VkSurfaceFormatKHR *out = *_outSurfaceFormats;
	VkResult r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no surface formats. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve surface formats. Abort.

	//Create a new array to hold all the surface formats
	out = new VkSurfaceFormatKHR[*_outCount];
	r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outSurfaceFormats = out;

	//Return Result
	return r;
}
VkResult get_surface_present_modes(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, uint32_t *_outCount, VkPresentModeKHR **_outPresentMode)
{
	//Gather all the surface present modes
	VkPresentModeKHR* out = *_outPresentMode;
	VkResult r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, _outCount, nullptr);

	if (*_outCount < 1)
	{
		//There are no surface present modes. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve surface formats. Abort.

	//Create a new array to hold all the surface formats
	out = new VkPresentModeKHR[*_outCount];
	r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outPresentMode = out;

	//Return Result
	return r;
}
VkResult get_best_surface_formats(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, VkSurfaceFormatKHR *_outSurfaceFormat)
{
	//Gather all the surface formats
	uint32_t count;
	VkSurfaceFormatKHR *surface_formats = VK_NULL_HANDLE;
	VkResult r = get_surface_formats(_physicalDevice, _surface, &count, &surface_formats);

	//If Count is 0, then something went wrong
	if (count < 1 || r)
	{
		//Failed to find surface formats. Abort.
		if (surface_formats) delete[] surface_formats;
		return VK_ERROR_FEATURE_NOT_PRESENT;
	}

	//If NOT VK_SUCCESS, then simply return r
	if (r)
	{
		//Failed to find surface formats. Abort.
		if (surface_formats) delete[] surface_formats;
		return r;
	}

	//If the count is 1 and the format is unknown, set a default format as best
	if (count == 1 && surface_formats[0].format == VK_FORMAT_UNDEFINED)
	{
		*_outSurfaceFormat = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
		delete[] surface_formats;
		return r;
	}

	//Loop through all formats and find the best format.
	for (uint32_t i = 0; i < count; ++i)
	{
		if (surface_formats[i].format == VK_FORMAT_B8G8R8A8_UNORM && surface_formats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
		{
			*_outSurfaceFormat = surface_formats[i];
			delete[] surface_formats;
			return r;
		}
	}

	if (surface_formats)
	{
		*_outSurfaceFormat = surface_formats[0];
		delete[] surface_formats;
	}
	return r;
}
VkResult get_best_surface_present_mode(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkPresentModeKHR *_outPresentMode)
{
	//Gather all surface present modes
	uint32_t count;
	VkPresentModeKHR *present_modes = VK_NULL_HANDLE;
	VkResult r = get_surface_present_modes(_physicalDevice, _surface, &count, &present_modes);

	//If Count is 0, then something went wrong
	if (count < 1)
	{
		//Failed to find present modes. Abort.
		if (present_modes) delete[] present_modes;
		return VK_ERROR_FEATURE_NOT_PRESENT;
	}

	//If NOT VK_SUCCESS, then simply return r
	if (r)
	{
		//Failed to find present modes. Abort.
		if (present_modes) delete[] present_modes;
		return r;
	}

	//Find the best mode (best: Mailbox, runner-up: Immediate, Default: FIFO)
	VkPresentModeKHR best_mode = VK_PRESENT_MODE_FIFO_KHR;
	for (uint32_t i = 0; i < count; ++i)
	{
		if (present_modes[i] == VK_PRESENT_MODE_MAILBOX_KHR)
		{
			best_mode = present_modes[i];
			*_outPresentMode = best_mode;
			break;
		}
		else if (present_modes[i] == VK_PRESENT_MODE_IMMEDIATE_KHR)
			best_mode = VK_PRESENT_MODE_IMMEDIATE_KHR;
	}

	if (present_modes)
	{
		delete[] present_modes;
		*_outPresentMode = best_mode;
	}
	return r;
}
VkResult get_surface_extent(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, const VkExtent2D &_winSize, VkExtent2D *_outExtent2D)
{
	//Gather all surface capabilities
	VkSurfaceCapabilitiesKHR surface_capabilities;
	VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(_physicalDevice, _surface, &surface_capabilities);
	if (r)
		return r;

	//If Capabilities's extent is not MAX, Set to those extents
	if (surface_capabilities.currentExtent.width != 0xFFFFFFFF)
		*_outExtent2D = surface_capabilities.currentExtent;
	else //Otherwise set it to window's width and height.
		*_outExtent2D = _winSize;

	return r;
}
VkResult find_depth_format(const VkPhysicalDevice& _physicalDevice, const VkImageTiling& _tiling, const VkFormatFeatureFlags& _formatFeatureFlags, const VkFormat *_formats, VkFormat* _outDepthFormat)
{
	//Setup Formats (Based on either input or default)
	VkFormat depth_formats[3];
	if (_formats)
	{
		depth_formats[0] = _formats[0];
		depth_formats[1] = _formats[1];
		depth_formats[2] = _formats[2];
	}
	else
	{
		depth_formats[0] = VK_FORMAT_D32_SFLOAT;
		depth_formats[1] = VK_FORMAT_D32_SFLOAT_S8_UINT;
		depth_formats[2] = VK_FORMAT_D24_UNORM_S8_UINT;
	}

	//Find the best compatible format for Depth
	for (uint32_t i = 0; i < 3; ++i)
	{
		VkFormatProperties format_properties;
		vkGetPhysicalDeviceFormatProperties(_physicalDevice, depth_formats[i], &format_properties);

		if (_tiling == VK_IMAGE_TILING_LINEAR &&
			(format_properties.linearTilingFeatures & _formatFeatureFlags) == _formatFeatureFlags)
		{
			*_outDepthFormat = depth_formats[i];
			return VK_SUCCESS;
		}
		else if (_tiling == VK_IMAGE_TILING_OPTIMAL &&
			(format_properties.optimalTilingFeatures & _formatFeatureFlags) == _formatFeatureFlags)
		{
			*_outDepthFormat = depth_formats[i];
			return VK_SUCCESS;
		}
	}

	//Format not found. Set to Undefined
	*_outDepthFormat = VK_FORMAT_UNDEFINED;

	//Return Max Enum
	return VK_RESULT_MAX_ENUM;
}

//Physical Device Information
VkResult get_best_gpu(const VkSurfaceKHR & _surface, const uint32_t& _totalDevices, VkPhysicalDevice* _allPhysicalDevices, const uint32_t &_totalDeviceExtensions, const char **_deviceExtensions, uint32_t *outIndex)
{
	/*
	The Idea:
	So, The purpose of this function is ideally to find the best GPU.
	The hard part, is that I cannot find a way to check clock speeds.
	So instead, i will base this on Compatibility, Device Type, Features and Memory.
		- Compatibility has the biggest impact. If its not compatible, then its a negative score.
		- Device Types will have a major impact. Best in order: Discrete GPU -> Virtual GPU -> Integrated GPU -> CPU
		- Features has minor impact. All features combined will have a great impact.
		- Memory will only come into play when scores are the same.
	There is absolutely no guarantee this is the best, but i want to be at least 95% accurate.
	*/

	//Gather Best GPU Index. Default is 0
	uint32_t best_index = 0;
	int64_t best_score = 0;
	for (uint32_t i = 0; i < _totalDevices; ++i)
	{
		int64_t score = 0;
		score += gpu_compatibility(_allPhysicalDevices[i], _surface, _totalDeviceExtensions, _deviceExtensions);
		score += gpu_device_type(_allPhysicalDevices[i]);
		score += gpu_features(_allPhysicalDevices[i]);

		if (score == best_score)
			score += gpu_memory(_allPhysicalDevices[best_index], _allPhysicalDevices[i]);

		if (score >= best_score)
		{
			best_index = i;
			best_score = score;
		}
	}

	*outIndex = best_index;
	return VK_SUCCESS;
}
VkResult get_best_queue_family_indices(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, int **_outIndices, VkBool32 *_outCanCompute)
{
    int* indices = *_outIndices;
    
	//Gather Queue Family Properties
	uint32_t count = 0;
	vkGetPhysicalDeviceQueueFamilyProperties(_physicalDevice, &count, nullptr);
	VkQueueFamilyProperties* queue_family_properties = new VkQueueFamilyProperties[count];
	vkGetPhysicalDeviceQueueFamilyProperties(_physicalDevice, &count, queue_family_properties);

	//Setup the Optional (Graphics and Present) Queue
	optional<int32_t> graphics;
	optional<int32_t> present;

	//Find Absolute Best: With Compute Shader
	for (uint32_t i = 0; i < count; ++i)
	{
		VkQueueFamilyProperties* cur = &queue_family_properties[i];
		if (cur->queueCount > 0 && cur->queueFlags & (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT))
		{
			graphics = i;
			*_outCanCompute = VK_TRUE;

			VkBool32 present_support = VK_FALSE;
			VkResult r = vkGetPhysicalDeviceSurfaceSupportKHR(_physicalDevice, i, _surface, &present_support);
			if (r)
				continue;

			if (present_support)
				present = i;

			if (present.has_value())
			{
				indices[0] = i;
				indices[1] = i;
				delete[] queue_family_properties;
				return r;
			}
		}
	}

	//No Compute Shader!
	_outCanCompute = VK_FALSE;
	for (uint32_t i = 0; i < count; ++i)
	{
		VkQueueFamilyProperties* cur = &queue_family_properties[i];
		if ( (cur->queueCount > 0) && (cur->queueFlags & VK_QUEUE_GRAPHICS_BIT))
		{
			graphics = i;

			VkBool32 present_support = VK_FALSE;
			VkResult r = vkGetPhysicalDeviceSurfaceSupportKHR(_physicalDevice, i, _surface, &present_support);
			if (r)
				continue;

			if (present_support)
				present = i;

			if (present.has_value())
			{
				indices[0] = i;
				indices[1] = i;
				delete[] queue_family_properties;
				return r;
			}
		}
	}

	indices[0] = -1;
	indices[1] = -1;
	delete[] queue_family_properties;
	return VK_RESULT_MAX_ENUM;
}
VkResult get_best_msaa_format(const VkPhysicalDevice& _physicalDevice, const VkSampleCountFlagBits&_idealMSAAFlag, VkSampleCountFlagBits *_outMSAAFlag)
{
	//Gather all physical device
	VkPhysicalDeviceProperties physical_device_properties;
	vkGetPhysicalDeviceProperties(_physicalDevice, &physical_device_properties);

	//Set a flag based on the minimum
	VkSampleCountFlagBits flags = static_cast<VkSampleCountFlagBits>( gvk_min(
		static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
		static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
	) );

	//Find the highest MSAA
	for (VkSampleCountFlagBits bit = VK_SAMPLE_COUNT_64_BIT; bit > VK_SAMPLE_COUNT_1_BIT; bit = static_cast<VkSampleCountFlagBits>(bit >> 1))
	{
		if ((flags & bit))
		{
			*_outMSAAFlag = bit;

			if (bit >= _idealMSAAFlag)
				return VK_SUCCESS;
			else
				return VK_RESULT_MAX_ENUM;
		}
	}

	//Couldn't find MSAA, set default
	*_outMSAAFlag = VK_SAMPLE_COUNT_1_BIT;
	return VK_RESULT_MAX_ENUM;
}

//Command Help
VkResult signal_command_start(const VkDevice &_device, const VkCommandPool &_commandPool, VkCommandBuffer *_outCommandBuffer)
{
	//Command Buffer Allocate Info
	VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
	command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	command_buffer_allocate_info.commandPool = _commandPool;
	command_buffer_allocate_info.commandBufferCount = 1;

	//Create the command buffer and allocate the command buffer with create info
	VkResult r = vkAllocateCommandBuffers(_device, &command_buffer_allocate_info, _outCommandBuffer);
	if (r)
		return r;

	//Start the command buffer's create info
	VkCommandBufferBeginInfo command_buffer_begin_info = {};
	command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
	command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

	//Begin the Command Buffer's recording process
	r = vkBeginCommandBuffer(*_outCommandBuffer, &command_buffer_begin_info);

	//Command Buffer has been successfully started!
	return r;
}
VkResult signal_command_end(const VkDevice& _device, const VkQueue& _graphicsQueue, const VkCommandPool& _commandPool, VkCommandBuffer *_commandBuffer)
{
	//End the Command Buffer's recording Process
	VkResult r = vkEndCommandBuffer(*_commandBuffer);
	if (r)
		throw "VkResult is NOT VK_SUCCESS!";

	//Create the submit info
	VkSubmitInfo submit_info = {};
	submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
	submit_info.commandBufferCount = 1;
	submit_info.pCommandBuffers = _commandBuffer;

	//Submit The Commands Recorded into the Queue. Then wait for the Graphics Queue to be idle
	r = vkQueueSubmit(_graphicsQueue, 1, &submit_info, VK_NULL_HANDLE);
	if (r)
	{
		throw "VkResult is NOT VK_SUCCESS!";
	}

	r = vkQueueWaitIdle(_graphicsQueue);
	if (r)
		throw "VkResult is NOT VK_SUCCESS!";

	//Free the command buffer from memory
	vkFreeCommandBuffers(_device, _commandPool, 1, _commandBuffer);

	//The Command Buffer has ended successfully!
	return r;
}

//Images Creation
VkResult create_image(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkExtent3D& _extent, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaBit,
	const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkAllocationCallbacks* _allocator,
	VkImage *_outImage, VkDeviceMemory *_outImageMemory)
{
	//Create image info
	VkImageCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
	create_info.imageType = VK_IMAGE_TYPE_2D;
	create_info.extent = _extent;
	create_info.mipLevels = _mipLevels;
	create_info.arrayLayers = 1;
	create_info.format = _format;
	create_info.tiling = _tiling;
	create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	create_info.usage = _usageFlags;
	create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	create_info.samples = _msaaBit;
	create_info.flags = 0;

	//Create the image
	VkResult r = vkCreateImage(_device, &create_info, _allocator, _outImage);
	if (r)
	{
		*_outImageMemory = 0u;
		return r;
	}

	//Create the memory required for any the image passed into this function
	VkMemoryRequirements memory_requirements;
	vkGetImageMemoryRequirements(_device, *_outImage, &memory_requirements);

	uint32_t memory_type_index = 0;
	find_memory_type(_physicalDevice, memory_requirements.memoryTypeBits, _memoryPropertyFlags, &memory_type_index);

	//Memory Allocate Info
	VkMemoryAllocateInfo memory_allocate_info = {};
	memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	memory_allocate_info.allocationSize = memory_requirements.size;
	memory_allocate_info.memoryTypeIndex = memory_type_index;

	//Allocate the memory created
	r = vkAllocateMemory(_device, &memory_allocate_info, _allocator, _outImageMemory);
	if (r)
	{
		vkDestroyImage(_device, *_outImage, _allocator);
		*_outImage = VK_NULL_HANDLE;
		_outImageMemory = 0u;
		return r;
	}

	//Bind the memory created
	r = vkBindImageMemory(_device, *_outImage, *_outImageMemory, 0);
	if (r)
	{
		vkDestroyImage(_device, *_outImage, VK_NULL_HANDLE);
		*_outImage = VK_NULL_HANDLE;
		vkFreeMemory(_device, *_outImageMemory, VK_NULL_HANDLE);
		return r;
	}

	//Image Creation has been successful!
	return r;
}
VkResult create_image_view(const VkDevice& _device, const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, const uint32_t& _mipLevels, VkAllocationCallbacks* _allocator, VkImageView *_outImageView)
{
	//Image View Create Info
	VkImageViewCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	create_info.image = _image;
	create_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
	create_info.format = _format;
	create_info.subresourceRange.aspectMask = _imageAspectFlags;
	create_info.subresourceRange.baseMipLevel = 0;
	create_info.subresourceRange.levelCount = _mipLevels;
	create_info.subresourceRange.baseArrayLayer = 0;
	create_info.subresourceRange.layerCount = 1;

	//Create the Surface (With Results) [VK_SUCCESS = 0]
	VkResult r = vkCreateImageView(_device, &create_info, _allocator, _outImageView);

	//Image View has been created successfully, return it
	return r;
}
VkResult transition_image_layout(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _graphicsQueue, const uint32_t& _mipLevel, const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout)
{
	//Start the command buffer
	VkCommandBuffer command_buffer = VK_NULL_HANDLE;
	VkResult r = signal_command_start(_device, _commandPool, &command_buffer);

	//Create the image memory barrier
	VkImageMemoryBarrier image_memory_barrier = {};
	image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	image_memory_barrier.image = _image;
	image_memory_barrier.oldLayout = _previousLayout;
	image_memory_barrier.newLayout = _currentLayout;
	image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	image_memory_barrier.subresourceRange.baseMipLevel = 0;
	image_memory_barrier.subresourceRange.levelCount = _mipLevel;
	image_memory_barrier.subresourceRange.layerCount = 1;
	image_memory_barrier.subresourceRange.baseArrayLayer = 0;

	//Setup the source and destination stage flags. Will be set based on the Old and New Layout set from outside
	VkPipelineStageFlags source_stage = VK_NULL_HANDLE;
	VkPipelineStageFlags destrination_stage = VK_NULL_HANDLE;

	if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
	{
		image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
		if (_format == VK_FORMAT_D24_UNORM_S8_UINT || _format == VK_FORMAT_D32_SFLOAT_S8_UINT)
			image_memory_barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
	}

	if (_previousLayout == VK_IMAGE_LAYOUT_UNDEFINED)
	{
		if (_currentLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
		}
		else if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
		}
		else if (_currentLayout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		}
	}
	else if (_previousLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && _currentLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
	{
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

		source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
		destrination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
	}

	vkCmdPipelineBarrier(command_buffer, source_stage, destrination_stage, 0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

	r = signal_command_end(_device, _graphicsQueue, _commandPool, &command_buffer);
	return r;
}
VkResult copy_buffer_to_image(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkBuffer& buffer, const VkImage& image, const VkExtent3D& extent)
{
	//Start Command Buffer
	VkCommandBuffer command_buffer = VK_NULL_HANDLE;
	VkResult r = signal_command_start(device, command_pool, &command_buffer);

	//Setup The Buffer Image Copy
	VkBufferImageCopy buffer_image_copy = {};
	buffer_image_copy.bufferOffset = 0;
	buffer_image_copy.bufferRowLength = 0;
	buffer_image_copy.bufferImageHeight = 0;
	buffer_image_copy.imageSubresource.layerCount = 1;
	buffer_image_copy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	buffer_image_copy.imageSubresource.mipLevel = 0;
	buffer_image_copy.imageSubresource.baseArrayLayer = 0;
	buffer_image_copy.imageOffset = { 0,0,0 };
	buffer_image_copy.imageExtent = extent;

	//Send Command to Copy Buffer to Image
	vkCmdCopyBufferToImage(command_buffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &buffer_image_copy);

	//End the Command buffer
	r = signal_command_end(device, graphics_queue, command_pool, &command_buffer);

	//Return result
	return r;
}
VkResult create_image_set(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkCommandPool &_commandPool, const VkExtent3D& _extent, const VkQueue &_graphicsQueue, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaSample, const VkFormat& _format,
	const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkImageAspectFlags &_aspectFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, const VkImageLayout &_previousLayout, const VkImageLayout &_currentLayout, VkAllocationCallbacks* _allocator,
	VkImage *_outImage, VkImageView *_outImageView, VkDeviceMemory *_outDeviceMemory)
{
	//Create Image
	VkResult r = create_image(_physicalDevice, _device, _extent, _mipLevels, _msaaSample, _format, _tiling, _usageFlags, _memoryPropertyFlags, _allocator, _outImage, _outDeviceMemory);
	if (r)
		return r;

	//Create Image View
	r = create_image_view(_device, *_outImage, _format, _aspectFlags, _mipLevels, _allocator, _outImageView);
	if (r)
		return r;

	//Bind the image layouts
	r = transition_image_layout(_device, _commandPool, _graphicsQueue, _mipLevels, *_outImage, _format, _previousLayout, _currentLayout);
	return r;
}
VkResult create_mipmaps(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkImage& texture_image, const uint32_t& texture_width, const uint32_t& texture_height, const uint32_t& mip_levels)
{
	//Start the command buffer
	VkCommandBuffer command_buffer;
	VkResult r = signal_command_start(device, command_pool, &command_buffer);

	//Create the Image Memory Barrier for Mipmapping
	VkImageMemoryBarrier image_memory_barrier = {};
	image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	image_memory_barrier.image = texture_image;
	image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	image_memory_barrier.subresourceRange.baseArrayLayer = 0;
	image_memory_barrier.subresourceRange.layerCount = 1;
	image_memory_barrier.subresourceRange.levelCount = 1;

	//Save the texture width and height for Mip levels
	int32_t mip_width = texture_width;
	int32_t mip_height = texture_height;

	//Loop for every Mip levels. NOTE: (i-1) is the current mip level, while (i) is the next mip level
	for (uint32_t i = 1; i < mip_levels; ++i) {
		//Setup the current mip level for blitting the image
		image_memory_barrier.subresourceRange.baseMipLevel = i - 1;
		image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
		image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

		//Transfer the layout and Access Mask Information
		vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
			0, nullptr, 0, nullptr, 1, &image_memory_barrier);

		//Create the Blit Image. Src is (i-1), or current mip level. dst is (i), or next mip level.
		VkImageBlit image_blit = {};
		image_blit.srcSubresource.mipLevel = i - 1;
		image_blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		image_blit.srcSubresource.baseArrayLayer = 0;
		image_blit.srcSubresource.layerCount = 1;
		image_blit.srcOffsets[0] = { 0, 0, 0 };
		image_blit.srcOffsets[1] = { mip_width, mip_height, 1 };

		image_blit.dstSubresource.mipLevel = i;
		image_blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		image_blit.dstSubresource.baseArrayLayer = 0;
		image_blit.dstSubresource.layerCount = 1;
		image_blit.dstOffsets[0] = image_blit.srcOffsets[0];
		image_blit.dstOffsets[1] = { mip_width > 1 ? (mip_width >> 1) : 1 , mip_height > 1 ? (mip_height >> 1) : 1, 1 };

		//Blit the texture
		vkCmdBlitImage(command_buffer, texture_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, texture_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
			1, &image_blit, VK_FILTER_LINEAR);

		//Set the layout and Access Mask (again) for the shader to read
		image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
		image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

		//Transfer the layout and Access Mask Information (Again, based on above values)
		vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
			0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

		//Reduce the Mip level down by 1 level [By cutting width and height in half]
		if (mip_width > 1) { mip_width >>= 1; }
		if (mip_height > 1) { mip_height >>= 1; }
	}

	image_memory_barrier.subresourceRange.baseMipLevel = mip_levels - 1;
	image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
	image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

	vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
		0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

	//End the command
	r = signal_command_end(device, graphics_queue, command_pool, &command_buffer);

	//Mipmapping has been created successfully!
	return r;
}

//Other Important Functions
VkResult find_memory_type(const VkPhysicalDevice& _physicalDevice, const uint32_t& _filter, const VkMemoryPropertyFlags& _propertyFlags, uint32_t* _outMemoryType)
{
	//Get the Memory Properties from the Physical Device
	VkPhysicalDeviceMemoryProperties memory_properties;
	vkGetPhysicalDeviceMemoryProperties(_physicalDevice, &memory_properties);

	//Loop through the memory type count and see if there is a match with both the filter and property flags
	for (uint32_t i = 0; i < memory_properties.memoryTypeCount; ++i)
	{
		if ((_filter & (1 << i)) &&
			(memory_properties.memoryTypes[i].propertyFlags & _propertyFlags) == _propertyFlags)
		{
			*_outMemoryType = i;
			return VK_SUCCESS;
		}
	}

	//Failed to find memory
	*_outMemoryType = 0x7FFFFFFF;
	return VK_RESULT_MAX_ENUM;
}

//Buffer Creation
VkResult create_buffer(const VkPhysicalDevice& physical_device, const VkDevice& device, const VkDeviceSize& size, const VkBufferUsageFlags& usage_flags, const VkMemoryPropertyFlags& property_flags, VkBuffer* buffer, VkDeviceMemory* buffer_memory)
{
	//Create Buffer Create Info
	VkBufferCreateInfo buffer_create_info = {};
	buffer_create_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	buffer_create_info.size = size;
	buffer_create_info.usage = usage_flags;
	buffer_create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	buffer_create_info.pNext = VK_NULL_HANDLE;

	//Create the buffer
	VkResult r = vkCreateBuffer(device, &buffer_create_info, nullptr, buffer);
	if (r)
		return r;

	//Get the memory required to allocate the buffer
	VkMemoryRequirements memory_requirement;
	vkGetBufferMemoryRequirements(device, *buffer, &memory_requirement);

	VkMemoryAllocateInfo memory_allocate_info = {};
	memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	memory_allocate_info.allocationSize = memory_requirement.size;
	memory_allocate_info.pNext = VK_NULL_HANDLE;
	find_memory_type(physical_device, memory_requirement.memoryTypeBits, property_flags, &memory_allocate_info.memoryTypeIndex);

	//Allocate and Bind the buffer
	r = vkAllocateMemory(device, &memory_allocate_info, nullptr, buffer_memory);
	if (r)
		return r;

	r = vkBindBufferMemory(device, *buffer, *buffer_memory, 0);

	//Return the last result of that bind memory
	return r;
}
VkResult copy_buffer(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _queueGraphics, const VkBuffer& _sourceBuffer, const VkBuffer& _destinationBuffer, const VkDeviceSize& _deviceSize)
{
	//Start the command buffer
	VkCommandBuffer command_buffer;
	VkResult r = signal_command_start(_device, _commandPool, &command_buffer);

	//Copy the buffer sent through
	VkBufferCopy buffer_copy = {};
	buffer_copy.srcOffset = 0;
	buffer_copy.dstOffset = 0;
	buffer_copy.size = _deviceSize;
	vkCmdCopyBuffer(command_buffer, _sourceBuffer, _destinationBuffer, 1, &buffer_copy);

	//End the command buffer
	r = signal_command_end(_device, _queueGraphics, _commandPool, &command_buffer);
	return r;
}
VkResult read_shader_file(const char* _fileName, uint64_t* _outShaderSize, char** _outShaderFile)
{
	//Open the File
	FILE* file;
	#ifdef _WIN32
	fopen_s(&file, _fileName, "rb");
	#else
	file = fopen(_fileName, "rb");
	#endif
	if (!file)
		return VK_RESULT_MAX_ENUM; //File Failed to Open

	//Get the size of the file
	fseek(file, 0, SEEK_END);
	uint64_t shaderSize =  *_outShaderSize = ftell(file);

	//Copy all the contents of the file.
	rewind(file);
	char* shaderFile = *_outShaderFile = new char[shaderSize + 1];
	uint64_t readSize = fread(shaderFile, sizeof(char), shaderSize, file);
	shaderFile[shaderSize] = '\0';
	if (readSize != shaderSize)
	{
		delete[] shaderFile;	//Something went wrong with the write...
		shaderFile = nullptr;	//So delete and set to nullptr
	}

	//Close the file and return whether it was successful or not.
	fclose(file);
	return shaderFile ? VK_SUCCESS : VK_RESULT_MAX_ENUM;
}
VkResult create_shader_module(const VkDevice& _device, const uint64_t& _shaderSize, char* _shaderString, VkShaderModule* _outShaderModule)
{
	//Setup create info
	VkShaderModuleCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	create_info.codeSize = _shaderSize;
	create_info.pCode = reinterpret_cast<const uint32_t*>(_shaderString);

	//Create the Shader Module and return the result of it.
	VkResult r = vkCreateShaderModule(_device, &create_info, nullptr, _outShaderModule);
	return r;
}
VkResult create_shader(const VkDevice& _device, const char* _fileName, const char* _entryPoint, const VkShaderStageFlagBits& _shaderType, VkShaderModule* _outShaderModule, VkPipelineShaderStageCreateInfo* _outStageInfo)
{
	//Read Shader
	uint64_t shader_size;
	char* shader_file = nullptr;
	VkResult r = read_shader_file(_fileName, &shader_size, &shader_file);
	if (r)
		return r;

	VkShaderModule shader_module = VK_NULL_HANDLE;
	r = create_shader_module(_device, shader_size, shader_file, &shader_module);
	if (r)
		return r;

	//Setup stage info
	VkPipelineShaderStageCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	create_info.stage = _shaderType;
	create_info.module = shader_module;
	create_info.pName = _entryPoint;

	//Set the out
	*_outStageInfo = create_info;
	*_outShaderModule = shader_module;

	//free memory
	delete[] shader_file;

	//return result
	return r;
}

}
#endif // #endif GVULKANHELPER_HPP

 // included so it will be part of the concatenated header
#include <vector>

#define GATEWARE_VK_FAIL(vkresult, greturn) if (vkresult) return greturn;

//The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I {
		class GVulkanSurfaceImplementation :	public virtual GVulkanSurfaceInterface,
												public GEventGeneratorImplementation
			{
		public:
			//Destructor
			~GVulkanSurfaceImplementation() { CleanupVulkanSurface(); DestroyQueryVariable(); }

            //Create
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask) {
				//Redirect Create. Mainly for convenience if using DX Surface Also.
				return Create(_gWindow, _initMask, 0, nullptr, 0, nullptr, 0, nullptr, true);
			}
		
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask, unsigned int _instanceLayerCount, const char** _instanceLayers, 
				unsigned int _instanceExtensionCount, const char** _instanceExtensions, unsigned int _deviceExtensionCount, const char** _deviceExtensions,
				bool _allPhysicalDeviceFeatures) {
					//Error Check #1: GWindow or surface is nullptr
					if (!_gWindow)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #2: Instance Layer Count and Content Mismatch (Count vs Address)
					if (_instanceLayerCount == 0 && _instanceLayers)
						return GReturn::INVALID_ARGUMENT;
					else if (_instanceLayerCount > 0 && !_instanceLayers)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #2: Instance Extension Count and Content Mismatch. (Count vs Address)
					if (_instanceExtensionCount == 0 && _instanceExtensions)
						return GReturn::INVALID_ARGUMENT;
					else if (_instanceExtensionCount > 0 && !_instanceExtensions)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #4: Device Extension Count and Content Mismatch (Count vs Address)
					if (_deviceExtensionCount == 0 && _deviceExtensions)
						return GReturn::INVALID_ARGUMENT;
					else if (_deviceExtensionCount > 0 && !_deviceExtensions)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #5: Supported Initialization Masks
					unsigned long long allowed = GRAPHICS::DEPTH_BUFFER_SUPPORT | GRAPHICS::DEPTH_STENCIL_SUPPORT | (GRAPHICS::MSAA_64X_SUPPORT - GRAPHICS::MSAA_2X_SUPPORT) | GRAPHICS::MSAA_64X_SUPPORT  | GRAPHICS::TRIPLE_BUFFER;
					if (~allowed & _initMask)
						return GReturn::INVALID_ARGUMENT;
					m_InitMask = _initMask;

					//Set GWindow & All Device Features
					m_GWindow = _gWindow;
					m_AllPhysicalDeviceFeatures = _allPhysicalDeviceFeatures;
					m_VkQueryInfo = nullptr;

					//Initialize all Vulkan Variables
					InitVariables();

					//Set Instance Layers
					m_InstanceLayerCount = _instanceLayerCount;
					m_InstanceLayers = new const char*[m_InstanceLayerCount];
					for (uint32_t i = 0; i < _instanceLayerCount; ++i)
						m_InstanceLayers[i] = _instanceLayers[i];

					//Error Check #6: No Swapchain or Surface Support
					m_InstanceExtensionCount = _instanceExtensionCount;
					m_DeviceExtensionCount = _deviceExtensionCount;
					if (CheckCompatibility(_instanceExtensions, _deviceExtensions)) {
						CleanupVulkanSurface();
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					// temporarily enable VSync so we get enough Swapchain images for all situations.
					m_VSync = true; // on some cards we Get 5 swap images when VSync is ON.
					//Initialize Vulkan Surface
					GReturn toCreate = InitVulkanSurface(); 
					if (G_FAIL(toCreate)) {
						CleanupVulkanSurface();
						return toCreate;
					}
					// disable it by default.(once intialization has completed)
					m_VSync = false;
					return GReturn::SUCCESS;
				}

			GReturn Create(SYSTEM::GWindow _gWindow, GVulkanSurfaceQueryInfo** _queryInfo) {
				//Error Check: Bad Query Info Handle
				if (!_queryInfo)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Bad GWindow Handle
				if (!_gWindow)
					return GReturn::INVALID_ARGUMENT;
					
				//Setup Creation of QueryInfo
				CreateQueryVariable();

				//Setup Variables
				m_GWindow = _gWindow;
				m_VkQueryInfo->initializationMask = 0;
				VkLayerProperties* all_layer_properties = nullptr;
				VkExtensionProperties* all_instance_extensions = nullptr;
				VkExtensionProperties* all_device_extensions = nullptr;

				//Setup Vulkan Environment for Query
				InitVariables();
				CheckInstanceVectors();
				CheckCompatibility(nullptr, nullptr);
				CreateVkInstance();
				m_VulkanHelperOS.CreateVkSurfaceKHR(m_VkInstance, m_WindowHandle, m_VkSurfaceKHR);
				FindVkPhysicalDevice();
				CheckDeviceVector();
				CreateVkDevice();

				//Instance Layer Enumeration:
				vkEnumerateInstanceLayerProperties(&(m_VkQueryInfo->instanceLayerCount), VK_NULL_HANDLE);
				if (m_VkQueryInfo->instanceLayerCount) {
					all_layer_properties = new VkLayerProperties[m_VkQueryInfo->instanceLayerCount];
					vkEnumerateInstanceLayerProperties(&(m_VkQueryInfo->instanceLayerCount), all_layer_properties);

					//Instance Layers Copy
					m_VkQueryInfo->instanceLayers = new const char* [m_VkQueryInfo->instanceLayerCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->instanceLayerCount; ++i)
						m_VkQueryInfo->instanceLayers[i] = all_layer_properties[i].layerName;
				}

				//Instance Extension Enumeration:
				vkEnumerateInstanceExtensionProperties(VK_NULL_HANDLE, &m_VkQueryInfo->instanceExtensionCount, VK_NULL_HANDLE);
				if (m_VkQueryInfo->instanceExtensionCount) {
					all_instance_extensions = new VkExtensionProperties[m_VkQueryInfo->instanceExtensionCount];
					vkEnumerateInstanceExtensionProperties(VK_NULL_HANDLE, &m_VkQueryInfo->instanceExtensionCount, all_instance_extensions);

					//Instance Extension Copy
					m_VkQueryInfo->instanceExtensions = new const char* [m_VkQueryInfo->instanceExtensionCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->instanceExtensionCount; ++i)
						m_VkQueryInfo->instanceExtensions[i] = all_instance_extensions[i].extensionName;
				}

				//Instance Extension Enumeration:
				vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, VK_NULL_HANDLE, &m_VkQueryInfo->deviceExtensionCount, VK_NULL_HANDLE);
				if (m_VkQueryInfo->deviceExtensionCount) {
					all_device_extensions = new VkExtensionProperties[m_VkQueryInfo->deviceExtensionCount];
					vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, VK_NULL_HANDLE, &m_VkQueryInfo->deviceExtensionCount, all_device_extensions);

					//Instance Extension Copy
					m_VkQueryInfo->deviceExtensions = new const char* [m_VkQueryInfo->deviceExtensionCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->deviceExtensionCount; ++i)
						m_VkQueryInfo->deviceExtensions[i] = all_device_extensions[i].extensionName;
				}

				//Physical Device Features Query
				VkPhysicalDeviceFeatures* all_device_features = new VkPhysicalDeviceFeatures;
				vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, all_device_features);
				m_VkQueryInfo->physicalDeviceFeatures = all_device_features;

				//Feature Support
				VkPhysicalDeviceProperties physical_device_properties;
				vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &physical_device_properties);
				VkSampleCountFlagBits flags;
				if (physical_device_properties.limits.framebufferColorSampleCounts < physical_device_properties.limits.framebufferDepthSampleCounts)
					flags = static_cast<VkSampleCountFlagBits>(physical_device_properties.limits.framebufferColorSampleCounts);
				else {
					flags = static_cast<VkSampleCountFlagBits>(G_LARGER(
					static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
					static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
				));
				}

				m_VkQueryInfo->initializationMask |= static_cast<unsigned long long>(static_cast<unsigned long long>(flags) << static_cast<int>(__log2(static_cast<float>(GRAPHICS::MSAA_2X_SUPPORT)) - 1));
				m_VkQueryInfo->initializationMask |= GRAPHICS::DEPTH_BUFFER_SUPPORT | GRAPHICS::DEPTH_STENCIL_SUPPORT | GRAPHICS::TRIPLE_BUFFER;

				//Setting up the properties [When deleted, the const char* stuff gets erased, why not send the properties too?]
				m_VkQueryInfo->instanceLayerProperties		= all_layer_properties;
				m_VkQueryInfo->instanceExtensionProperties = all_instance_extensions;
				m_VkQueryInfo->deviceExtensionProperties	= all_device_extensions;
				CleanupVulkanSurface();

				*_queryInfo = m_VkQueryInfo;
				
				//Return Success
				return GReturn::SUCCESS;
			}

            //GVulkanSurface
			GReturn GetAspectRatio(float& _outRatio) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: GWindow fails to exist
				if (!m_GWindow)
					return GReturn::FAILURE;
				
				//Give out the Aspect Ratio
				_outRatio = m_AspectRatio;

				//Return Success
				return GReturn::SUCCESS;
			}
		
            GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give the Maximum Image Count
				_outImageCount = m_MaxFrameCount;

				//Return Success
				return GReturn::SUCCESS;
			}
		
			GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give the Current Image Index
				_outImageIndex = m_CurrentFrame;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetGraphicsQueue(void** _outVkQueue) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkQueue)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkQueue = m_VkQueueGraphics;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetPresentQueue(void** _outVkQueue) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkQueue)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkQueue = m_VkQueuePresent;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give out the Queue Indices
				_outGraphicsIndex = static_cast<uint32_t>(m_QueueFamilyIndices[0]);
				_outPresentIndex = static_cast<uint32_t>(m_QueueFamilyIndices[1]);

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkImage)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Swapchain or Swapchain Image doesn't exist
				if (!m_VkSwapchainKHR || !m_VkImageSwapchain[0])
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkImage = m_VkImageSwapchain[m_CurrentFrame];
				else
					*_outVkImage = m_VkImageSwapchain[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkImageView)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Swapchain and Swapchain's View Exist
				if (!m_VkSwapchainKHR || !m_VkImageViewSwapchain)
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkImageView = m_VkImageViewSwapchain[m_CurrentFrame];
				else
					*_outVkImageView = m_VkImageViewSwapchain[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkFramebuffer)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: No Swapchain or Framebuffer
				if (!m_VkSwapchainKHR || !m_VkFramebuffer[0])
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkFramebuffer = m_VkFramebuffer[m_CurrentFrame];
				else
					*_outVkFramebuffer = m_VkFramebuffer[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetInstance(void** _outVkInstance) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkInstance)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkInstance = m_VkInstance;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSurface(void** _outVkSurfaceKHR) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkSurfaceKHR)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkSurfaceKHR = m_VkSurfaceKHR;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkPhysicalDevice)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkPhysicalDevice = m_VkPhysicalDevice;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** _outVkDevice) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkDevice)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkDevice = m_VkDevice;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetCommandPool(void** _outCommandPool) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outCommandPool)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outCommandPool = m_VkCommandPool;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain(void** _outVkSwapchainKHR) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkSwapchainKHR)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkSwapchainKHR = m_VkSwapchainKHR;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderPass(void** _outVkRenderPass) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkRenderPass)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkRenderPass = m_VkRenderPass;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outCommandBuffer)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outCommandBuffer = m_VkCommandBuffer[m_CurrentFrame];
				else
					*_outCommandBuffer = m_VkCommandBuffer[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkSemaphore)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkSemaphore = m_VkSemaphoreImageAvailable[m_CurrentFrame];
				else
					*_outVkSemaphore = m_VkSemaphoreImageAvailable[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkSemaphore)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkSemaphore = m_VkSemaphoreRenderFinished[m_CurrentFrame];
				else
					*_outVkSemaphore = m_VkSemaphoreRenderFinished[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderFence(const int& _index, void** _outVkFence) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkFence)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkFence = m_VkFenceRendering[m_CurrentFrame];
				else
					*_outVkFence = m_VkFenceRendering[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) override {
					//Error Check: Deallocated
					if (m_Deallocated)
						return GReturn::PREMATURE_DEALLOCATION;

					//Error Check: Screen is minimized
					if (m_NoDrawing)
						return GReturn::FAILURE;

					//Error Check: Clear Count Bounds (0 - 2)
					if (_clearCount > 2)
						return GReturn::INVALID_ARGUMENT;
					
					//Error Check: Have Clear Count but no Clear Color
					if (_clearCount && !_vkClearValues)
						return GReturn::INVALID_ARGUMENT;

					//Error Check: Clear Count is 0 but have a Clear Value
					if (!_clearCount && _vkClearValues)
						return GReturn::INVALID_ARGUMENT;

					//Check if Frame is locked
					if (m_FrameLocked)
						UnlockSyncWrite();

					//Lock the Thread
					LockSyncWrite();

					//Frame is now Locked
					m_FrameLocked = true;

					//Wait for Queue to be ready
					//if (m_PrevFrame != m_CurrentFrame)
					vkWaitForFences(m_VkDevice, 1, &m_VkFenceRendering[m_CurrentFrame], VK_TRUE, ~(static_cast<uint64_t>(0)));

					//Get the Frame Result
					//m_PrevFrame = m_CurrentFrame;
					//Go to the next frame
					//if (++m_CurrentFrame >= m_MaxFrameCount)
					//	m_CurrentFrame = 0; 

					VkResult frame_result = vkAcquireNextImageKHR(m_VkDevice, m_VkSwapchainKHR, 
						~(0ull), m_VkSemaphoreImageAvailable[m_CurrentFrame], VK_NULL_HANDLE, &m_TargetImage);
					
					//Error Check: VkResult is NOT Successful (1: Swapchain Bad, 2: Unknown)
					if (frame_result == VK_ERROR_OUT_OF_DATE_KHR) {
						//Fix the Swapchain
						GReturn g = ResetSwapchain();

						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame Unlocked
						m_FrameLocked = false;

						//Notify Observers a new swapchain was created
						EVENT_DATA edata = { frame_result, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
						GEvent e;
						e.Write(Events::REBUILD_PIPELINE, edata);
						Push(e);

						//Return Failure [Pipelines must be reset right after this!]
						return G_PASS(g) ? GReturn::FAILURE : GReturn::UNEXPECTED_RESULT;
					}
					else if (frame_result && frame_result != VK_SUBOPTIMAL_KHR) {
						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame Unlocked
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info.
						return GReturn::FAILURE;
					}
					//Create the Command Buffer's Begin Info
					VkCommandBufferBeginInfo command_buffer_begin_info = {};
					command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
					command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
					command_buffer_begin_info.pInheritanceInfo = nullptr;
					vkBeginCommandBuffer(m_VkCommandBuffer[m_CurrentFrame], &command_buffer_begin_info);

					//Setup Clear Color
					VkClearValue clear_value[2];
					uint32_t clear_value_count = _clearCount; 
					if (!clear_value_count) {
						clear_value[0].color = {{ 0.0f, 0.0f, 0.0f, 1.0f }}; ++clear_value_count;
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
							clear_value[1].depthStencil = { 1.0f, 16777216 }; ++clear_value_count;
						}
					}
					else {
						VkClearValue* paramClearValue = reinterpret_cast<VkClearValue*>(_vkClearValues);
						clear_value[0] = paramClearValue[0];
						if (clear_value_count == 2 && m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							clear_value[1] = paramClearValue[1];
					}

					//Setup the Render Pass
					VkRenderPassBeginInfo render_pass_begin_info = {};
					render_pass_begin_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
					render_pass_begin_info.renderPass = m_VkRenderPass;
					render_pass_begin_info.framebuffer = m_VkFramebuffer[m_CurrentFrame];
					render_pass_begin_info.renderArea.extent = {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height};
					render_pass_begin_info.clearValueCount = clear_value_count;
					render_pass_begin_info.pClearValues = clear_value;

					//Begin the Render Pass
					vkCmdBeginRenderPass(m_VkCommandBuffer[m_CurrentFrame], &render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);

					//Return Success
					return GReturn::SUCCESS;
				}

			GReturn EndFrame(const bool& _vSync) override {
					//Error Check: GWindow Deallocated
					if (m_Deallocated) {
						//Check if Frame is Locked. If so Unlock it.
						if (m_FrameLocked) {
							UnlockSyncWrite();
							m_FrameLocked = false;
						}

						//Return Premature Deallocation
						return GReturn::PREMATURE_DEALLOCATION;
					}

					//Error Check: Window is not drawable
					if (m_NoDrawing) {
						//Check if Frame is Locked. If so Unlock it.
						if (m_FrameLocked) {
							UnlockSyncWrite();
							m_FrameLocked = false;
						}

						//Return Failure
						return GReturn::FAILURE;
					}

					//Error Check: Start Frame has not started! (It is supposed to be locked to prevent Swapchain from being rebuilt in between draws)
					if (!m_FrameLocked)
						return GReturn::FAILURE;

					//Stop the Render Pass
					vkCmdEndRenderPass(m_VkCommandBuffer[m_CurrentFrame]);
					vkEndCommandBuffer(m_VkCommandBuffer[m_CurrentFrame]);

					//Setup the Semaphores and Command Buffer to be sent into Queue Submit
					VkSemaphore wait_semaphores[] = { m_VkSemaphoreImageAvailable[m_CurrentFrame] };
					VkPipelineStageFlags wait_stages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
					VkSemaphore signal_semaphore[] = { m_VkSemaphoreRenderFinished[m_CurrentFrame] };
					VkCommandBuffer pCommandBuffer[] = { m_VkCommandBuffer[m_CurrentFrame] };
					
					//Setup the Queue Submit Info
					VkSubmitInfo submit_info = {};
					submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
					submit_info.waitSemaphoreCount = 1;
					submit_info.pWaitSemaphores = wait_semaphores;
					submit_info.pWaitDstStageMask = wait_stages;
					submit_info.commandBufferCount = 1;
					submit_info.pCommandBuffers = pCommandBuffer;
					submit_info.signalSemaphoreCount = 1;
					submit_info.pSignalSemaphores = signal_semaphore;

					//Reset the Fence
					vkResetFences(m_VkDevice, 1, &m_VkFenceRendering[m_CurrentFrame]);

					//Submit Queue <--Something to come back to.
					VkResult r;
					r = vkQueueSubmit(m_VkQueueGraphics, 1, &submit_info, m_VkFenceRendering[m_CurrentFrame]);
					if (r) {
						//Unlock the Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info before reporting.
						return GReturn::FAILURE;
					}

					//Setup the Present Info
					VkSwapchainKHR swapchains[] = { m_VkSwapchainKHR };
					VkPresentInfoKHR present_info = {};
					present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
					present_info.waitSemaphoreCount = 1;
					present_info.pWaitSemaphores = signal_semaphore;
					present_info.swapchainCount = 1;
					present_info.pSwapchains = swapchains;
					present_info.pImageIndices = &m_TargetImage;//&m_CurrentFrame;
					present_info.pResults = nullptr;

					//Present onto the surface
					VkResult frame_result = vkQueuePresentKHR(m_VkQueuePresent, &present_info);

					//Error Check for Swapchain and VSync Changes
					if (frame_result == VK_ERROR_OUT_OF_DATE_KHR || frame_result == VK_SUBOPTIMAL_KHR || _vSync != m_VSync) {
						//Set VSync and its property.
						m_VSync = _vSync;
						
						//Clear the Swapchain
						GReturn g = ResetSwapchain();

						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Notify Observers a new swapchain was created
						EVENT_DATA edata = { frame_result, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
						GEvent e;
						e.Write(Events::REBUILD_PIPELINE, edata);
						Push(e);

						//Return Failure [Pipelines must be reset right after this!]
						return G_PASS(g) ? GReturn::FAILURE : GReturn::UNEXPECTED_RESULT;
					}
					else if (frame_result) {
						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info.
						return GReturn::FAILURE;
					}

					//Go to the next frame
					if (++m_CurrentFrame >= m_MaxFrameCount)
						m_CurrentFrame = 0; 

					//Set Start Frame to false
					m_FrameLocked = false;

					//Unlock Thread
					UnlockSyncWrite();

					//Return Success
					return GReturn::SUCCESS;
			}

            //GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Assign(_newHandler); 
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Assign(_newEventHandler); 
			}
			GReturn Invoke() const override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Invoke(); 
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Invoke(_incomingEvent); 
			}
		private:
			//Init & Create Methods
			GReturn InitVulkanSurface() {
				//Error Check: Instance Layers & Extensions [Invalid Argument]
				GATEWARE_VK_FAIL(CheckInstanceVectors(), GReturn::INVALID_ARGUMENT);

				//Setup #1: VkInstance [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkInstance(), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #2: VkSurfaceKHR [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(m_VulkanHelperOS.CreateVkSurfaceKHR(m_VkInstance, m_WindowHandle, m_VkSurfaceKHR), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #3: VkPhysicalDevice [ Feature Unsupported: MSAA Unsupported, Failure: {Unknown: Need to Investigate} ]
				VkResult r = FindVkPhysicalDevice(); 
				if (r == VK_ERROR_FORMAT_NOT_SUPPORTED) return GReturn::FEATURE_UNSUPPORTED;
				else if (r) return GReturn::FAILURE;

				//Error Check: Device Extension [Invalid Argument]
				GATEWARE_VK_FAIL(CheckDeviceVector(), GReturn::INVALID_ARGUMENT);

				//Setup #4: VkDevice [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkDevice(), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #5: VkCommandPool [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkCommandPool(), GReturn::FAILURE);

				//Setup #6: Swapchain Properties [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(GetSurfaceData(), GReturn::FAILURE);

				//Setup #7: Swapchain [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(-CreateSwapchain(), GReturn::FAILURE);

				//Setup #8: Semaphores and Fences [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateSyncObjects(), GReturn::FAILURE);

				//All Done!
				return GReturn::SUCCESS;
			}

			GReturn InitVariables() {
				//Basic GWindow Setup
				m_GWindow.GetWindowHandle(m_WindowHandle);
				m_GWindow.GetX(m_WindowTopLeft.width);
				m_GWindow.GetY(m_WindowTopLeft.height);
				m_GWindow.GetClientWidth(m_WindowExtent.width);
				m_GWindow.GetClientHeight(m_WindowExtent.height);
				m_WindowName = m_VulkanHelperOS.GetPlatformWindowName(m_WindowHandle);
				m_AspectRatio = m_WindowExtent.width / static_cast<float>(m_WindowExtent.height);
				m_Deallocated = false;
				m_NoDrawing = false;

				//Main Vulkan Objects Setup
				m_VkInstance = {};
				m_VkSurfaceKHR = {};
				m_VkPhysicalDevice = {};
				m_VkDevice = {};
				m_VkCommandPool = {};
				m_VkSwapchainKHR = {};

				//Feature-Based Images
				m_GVkImageMSAA = {};
				m_GVkImageDepth = {};
				m_VSync = false;
				m_MSAAOn = false;

				//Frame-Based Vulkan Objects & Properties
				m_MaxFrameCount = 0;
				m_CurrentFrame = 0;
				memset(m_VkImageSwapchain, 0, sizeof(VkImage) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkImageViewSwapchain, 0, sizeof(VkImageView) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkFramebuffer, 0, sizeof(VkFramebuffer) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkCommandBuffer, 0, sizeof(VkCommandBuffer) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkSemaphoreImageAvailable, 0, sizeof(VkSemaphore) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkSemaphoreRenderFinished, 0, sizeof(VkSemaphore) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkFenceRendering, 0, sizeof(VkFence) * GVK_SWAP_BUFFER_LIMIT); 

				//Vulkan Properties Setup
				m_QueueFamilyIndices[0] = -1;
				m_QueueFamilyIndices[1] = -1;
				m_CanCompute = VK_FALSE;
				m_MSAA = VK_SAMPLE_COUNT_1_BIT;
				m_VkQueueGraphics = {};
				m_VkQueuePresent = {};
				m_VkSurfaceCapabilitiesKHR = {};
				m_VkPresentModeKHRSurface = {};
				m_VkExtent2DSurface = {};
				m_VkFormatSurface = {};
				m_VkFormatDepth = {};
				m_VkRenderPass = {};
				m_FrameLocked = false;

				//Helper Method Setup  
				m_AllInstanceLayerCount = 0;
				m_AllInstanceExtensionCount = 0;
				m_AllDeviceExtensionCount = 0;
				m_AllSurfaceFormatCount = 0;
				m_AllPresentModeCount = 0;
				m_AllPhysicalDevices = nullptr;			m_AllPhysicalDeviceCount = 0;
				m_AllQueueFamilyProperties = nullptr;	m_AllQueueFamilyPropertyCount = 0;

				//Event Setup
				m_EventResponder.Create([&](const GW::GEvent& event) {
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					event.Read(windowEvent, windowEventData);

					switch (windowEvent) {
						case GW::SYSTEM::GWindow::Events::MINIMIZE: {
							m_NoDrawing = true;
						} break;
						case GW::SYSTEM::GWindow::Events::DESTROY: {
							//Notify Observers its time to release any Vulkan resources
							GEvent shutdown;
							EVENT_DATA sdata = { // wasn't actually lost but its about to be
								VK_ERROR_SURFACE_LOST_KHR, { m_VkExtent2DSurface.width, m_VkExtent2DSurface.height }
							};
							shutdown.Write(Events::RELEASE_RESOURCES, sdata);
							Push(shutdown);
							//Cleanup the whole surface
							m_VulkanHelperOS.PlatformDestroyGVulkanSurface([&](){CleanupVulkanSurface();});
						} break;
						case GW::SYSTEM::GWindow::Events::DISPLAY_CLOSED: {
							//Cleanup Instance
							if (m_VkInstance) {
								vkDestroyInstance(m_VkInstance, VK_NULL_HANDLE);
								m_VkInstance = VK_NULL_HANDLE;
							}
						} break;
						case GW::SYSTEM::GWindow::Events::MAXIMIZE:
						case GW::SYSTEM::GWindow::Events::RESIZE: {
							if (windowEventData.width < 1 || windowEventData.height < 1)
								m_NoDrawing = true;
							else {
								//Lock the Thread
								LockSyncWrite();

								//Reset the Swapchain
								GReturn g = ResetSwapchain();

								//Unlock The Thread
								UnlockSyncWrite();

								//Notify Observers a new swapchain was created
								EVENT_DATA edata = { VK_ERROR_OUT_OF_DATE_KHR, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
								GEvent e;
								e.Write(Events::REBUILD_PIPELINE, edata);
								g = Push(e);

								//Reset Minimization
								m_NoDrawing = false;
							}
						} break;
						case GW::SYSTEM::GWindow::Events::MOVE: {
							//Set Window TopLeft
							m_GWindow.GetClientTopLeft(m_WindowTopLeft.width, m_WindowTopLeft.height);
						} break;
						default:
							break;
					}
				});
				return m_GWindow.Register(m_EventResponder);
			}

			VkResult CreateVkInstance() {
				//Application Information (Will come back to this for Gateware Version. Maybe used for RenderDoc)
				VkApplicationInfo app_info = {};
				app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
				app_info.apiVersion = VK_API_VERSION_1_1;
				app_info.pApplicationName = m_WindowName;
				app_info.applicationVersion = 1;
				app_info.pEngineName = "Gateware";
				app_info.engineVersion = VK_MAKE_VERSION(GATEWARE_MAJOR, GATEWARE_MINOR, GATEWARE_PATCH);
				app_info.pNext = nullptr;

				//Application Create Info [Basics]
				VkInstanceCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
				create_info.pApplicationInfo = &app_info;

				//Extensions
				create_info.enabledExtensionCount = m_InstanceExtensionCount;
				create_info.ppEnabledExtensionNames = m_InstanceExtensions;
				create_info.enabledLayerCount = m_InstanceLayerCount;
				create_info.ppEnabledLayerNames = m_InstanceLayers;

				VkResult r = vkCreateInstance(&create_info, nullptr, &m_VkInstance);
				return r;
			}

			VkResult FindVkPhysicalDevice() {
				//Get all GPUs
				VkResult r = GetAllPhysicalDevices();
				if (r) return VK_ERROR_INITIALIZATION_FAILED;

				//Pick Best GPU
				r = GetBestGPU();

				//Get Family Queue
				r = GetQueueFamilyIndices();
				if (r) return VK_ERROR_FEATURE_NOT_PRESENT;

				//Get MSAA
				unsigned long long msaa_init = m_InitMask & ((GRAPHICS::MSAA_64X_SUPPORT - GRAPHICS::MSAA_2X_SUPPORT) | GRAPHICS::MSAA_64X_SUPPORT);
				if (msaa_init) {
					//Turn on MSAA support
					m_MSAAOn = true;

					//Set the flag to the proper one (-1 since i skip MSAA_1X_SUPPORT, since thats default)
					m_MSAA = static_cast<VkSampleCountFlagBits>( msaa_init >> static_cast<int>(__log2(static_cast<float>(GRAPHICS::MSAA_2X_SUPPORT)) - 1) );

					//Find Support
					VkPhysicalDeviceProperties physical_device_properties;
					vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &physical_device_properties);

					//Set a flag based on the minimum
					VkSampleCountFlagBits flags;
					if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
						flags = static_cast<VkSampleCountFlagBits>(G_SMALLER(
						static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
						static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
						));
					}
					else
						flags = static_cast<VkSampleCountFlagBits>(physical_device_properties.limits.framebufferColorSampleCounts);

					//Return if bad
					if (m_MSAA & ~(flags)) return VK_ERROR_FORMAT_NOT_SUPPORTED;
				}
				
				//Cleanup
				return r;
			}

			VkResult CreateVkDevice() {
				//Setup Unique Queue Family
				uint32_t qf_createsize = 0;					
				if (m_QueueFamilyIndices[0] ^ m_QueueFamilyIndices[1])
					qf_createsize = 2;						
				else										
					qf_createsize = 1;						
				VkDeviceQueueCreateInfo* queue_create_info_array = new VkDeviceQueueCreateInfo[qf_createsize];

				//Set up Create Info for all unique queue families
				float priority = 1.0f;
				for (uint32_t i = 0; i < qf_createsize; ++i) {
					VkDeviceQueueCreateInfo create_info = {};

					create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
					create_info.queueFamilyIndex = m_QueueFamilyIndices[i];
					create_info.queueCount = 1;
					create_info.pQueuePriorities = &priority;
					queue_create_info_array[i] = create_info;
				}

				//Get all available device features
				VkPhysicalDeviceFeatures all_device_features;
				vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, &all_device_features);

				//Set the needed (or all) device features
				VkPhysicalDeviceFeatures device_features = {};
				if (m_AllPhysicalDeviceFeatures)
					device_features = all_device_features;
				else {
					if (all_device_features.tessellationShader)	device_features.tessellationShader = VK_TRUE;
					if (all_device_features.geometryShader)		device_features.geometryShader = VK_TRUE;
					if (all_device_features.fillModeNonSolid)	device_features.fillModeNonSolid = VK_TRUE;
					if (m_MSAAOn) {
						if (all_device_features.samplerAnisotropy)	device_features.samplerAnisotropy = VK_TRUE; //MSAA
						if (all_device_features.sampleRateShading)	device_features.sampleRateShading = VK_TRUE; //MSAA
					}
				}
				
				//Setup Logical device create info [*: Two different Queue Indices Check Needed]
				VkDeviceCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
				create_info.pQueueCreateInfos = queue_create_info_array;
				create_info.queueCreateInfoCount = qf_createsize;
				create_info.pEnabledFeatures = &device_features;

				create_info.enabledExtensionCount = m_DeviceExtensionCount;
				create_info.ppEnabledExtensionNames = m_DeviceExtensions;

				//Create the Surface (With Results) [VK_SUCCESS = 0]
				VkResult r = vkCreateDevice(m_VkPhysicalDevice, &create_info, nullptr, &m_VkDevice);

				//If Device has been created, Setup the Device Queue for graphics and present family
				vkGetDeviceQueue(m_VkDevice, m_QueueFamilyIndices[0], 0, &m_VkQueueGraphics);
				vkGetDeviceQueue(m_VkDevice, m_QueueFamilyIndices[1], 0, &m_VkQueuePresent);

				//Device has been created successfully!
				delete[] queue_create_info_array;
				return r;
			}

			VkResult CreateVkCommandPool() {
				//Command Pool's Create Info
				VkCommandPoolCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
				create_info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
				create_info.queueFamilyIndex = m_QueueFamilyIndices[0];

				VkResult r = vkCreateCommandPool(m_VkDevice, &create_info, nullptr, &m_VkCommandPool);
				return r;
			}

			VkResult GetSurfaceData() {
				//Gather The Surface Capabilities
				VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_VkSurfaceCapabilitiesKHR);
				if (r) return r;

				//Get the best Surface Format
				if (m_VkFormatSurface.format == VK_FORMAT_UNDEFINED) {
					r = GetSurfaceFormat();
					if (r) return r;
				}

				//Get the best present mode
				r = GetSurfacePresentMode();
				if (r) return r;

				//Get the surface extent
				r = GetSurfaceExtent();
				if (r) return r;

				if ( (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) && m_VkFormatDepth == VK_FORMAT_UNDEFINED)
					r = GetDepthFormat();

				return r;
			}

			GReturn CreateSwapchain() {
				//Create The Swapchain
				GATEWARE_VK_FAIL(CreateVkSwapchainKHR(), GReturn::FAILURE);

				//Create the RenderPass
				GATEWARE_VK_FAIL(CreateVkRenderPass(), GReturn::FAILURE);

				//Create the MSAA Buffer (If Needed)
				if (m_MSAAOn) GATEWARE_VK_FAIL(CreateMSAABuffer(), GReturn::FAILURE);

				//Create the Depth Buffer (If Needed)
				if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) GATEWARE_VK_FAIL(CreateDepthBuffer(), GReturn::FAILURE);

				//Create the Framebuffer
				GATEWARE_VK_FAIL(CreateVkFramebuffer(), GReturn::FAILURE);

				//Create the Command Buffer
				GATEWARE_VK_FAIL(CreateVkCommandBuffer(), GReturn::FAILURE);

				return GReturn::SUCCESS;
			}

			VkResult CreateSyncObjects() {
				//Semaphore Info Create
				VkSemaphoreCreateInfo semaphore_create_info = {};
				semaphore_create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

				//Fence Info Create
				VkFenceCreateInfo fence_create_info = {};
				fence_create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
				fence_create_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;

				//Create the Semaphores and Fences
				VkResult r{};
				for (unsigned int i = 0; i < m_MaxFrameCount; ++i) {
					r = vkCreateSemaphore(m_VkDevice, &semaphore_create_info, nullptr, &m_VkSemaphoreImageAvailable[i]);
					if (r) {
						return r;
					}
					r = vkCreateSemaphore(m_VkDevice, &semaphore_create_info, nullptr, &m_VkSemaphoreRenderFinished[i]);
					if (r) {
						return r;
					}
					r = vkCreateFence(m_VkDevice, &fence_create_info, nullptr, &m_VkFenceRendering[i]);
					if (r) {
						return r;
					}
				}

				//Semaphores and Fences has been created successfully!
				return r;
			}

			//Create Methods for Swapchain
			VkResult CreateVkSwapchainKHR() {
				//Gather Swapchain Count
				unsigned int newFrameCount = (m_InitMask & GRAPHICS::TRIPLE_BUFFER) ? 3u : 2u;
				if (m_VkSurfaceCapabilitiesKHR.minImageCount > 0 && newFrameCount < m_VkSurfaceCapabilitiesKHR.minImageCount)
					newFrameCount = m_VkSurfaceCapabilitiesKHR.minImageCount;
				if (m_VkSurfaceCapabilitiesKHR.maxImageCount > 0 && newFrameCount > m_VkSurfaceCapabilitiesKHR.maxImageCount)
					newFrameCount = m_VkSurfaceCapabilitiesKHR.maxImageCount;
					
				//Create Info for SwapchainKHR [Part 1]
				VkSwapchainCreateInfoKHR create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
				create_info.surface = m_VkSurfaceKHR;
				create_info.minImageCount = newFrameCount;
				create_info.imageFormat = m_VkFormatSurface.format;
				create_info.imageColorSpace = m_VkFormatSurface.colorSpace;
				create_info.imageExtent = m_VkExtent2DSurface;
				create_info.imageArrayLayers = 1;
				create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
				create_info.preTransform = m_VkSurfaceCapabilitiesKHR.currentTransform;
				create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
				create_info.presentMode = m_VkPresentModeKHRSurface;
				create_info.clipped = VK_TRUE;
				create_info.oldSwapchain = m_VkSwapchainKHR; // supposed to help/optimize transitions

				//Setup Correct Queue Family Indices
				if (m_QueueFamilyIndices[0] ^ m_QueueFamilyIndices[1]) {
					create_info.queueFamilyIndexCount = 2;
					create_info.pQueueFamilyIndices = reinterpret_cast<uint32_t*>(&m_QueueFamilyIndices[0]);
					create_info.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
				}
				else {
					create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
				}

				//Create Swapchain
				VkSwapchainKHR newSwapchain = nullptr;
				VkResult r = vkCreateSwapchainKHR(m_VkDevice, &create_info, nullptr, &newSwapchain);
				if (r >= 0) // on success free the old swapchain and replace with the new one
				{
					//Destroy old Swapchain & sync
					CleanupSwapchain();
					CleanupSyncObjects();
					m_VkSwapchainKHR = newSwapchain;
				}

				//Swapchain Image Setup
				unsigned required_images = 0; 
				r = vkGetSwapchainImagesKHR(m_VkDevice, m_VkSwapchainKHR, &required_images, VK_NULL_HANDLE);
				// possible we may get more Images than requested and we must handle it
				if (required_images > GVK_SWAP_BUFFER_LIMIT)
					return VkResult::VK_ERROR_INITIALIZATION_FAILED;
				if (required_images != m_MaxFrameCount)
					m_MaxFrameCount = required_images; // we must cycle all buffers required
				// **IMPORTANT** Currently the amount of "in-flight" frames is linked to the requested/provided number of images 
				// provided by the swap chain based on our selected modes. However, it is possible to limit this below that number.
				r = vkGetSwapchainImagesKHR(m_VkDevice, m_VkSwapchainKHR, &m_MaxFrameCount, m_VkImageSwapchain);

				//Obtain the Image and Image Views
				for (uint32_t i = 0; i < m_MaxFrameCount; ++i)
					r = CreateImageView(m_VkImageSwapchain[i], m_VkFormatSurface.format, VK_IMAGE_ASPECT_COLOR_BIT, &m_VkImageViewSwapchain[i]);

				//Set Current Frame to 0
				m_CurrentFrame = 0;
				m_TargetImage = 0;
		
				return r;
			}

			VkResult CreateVkRenderPass() {
				//Preliminary Setup
				uint32_t count = 0;
				VkAttachmentDescription* attachments = new VkAttachmentDescription[3];

				//Primary Swapchain Description and Swapchain
				VkAttachmentDescription color_attachment_description = {};
				color_attachment_description.format = m_VkFormatSurface.format;
				color_attachment_description.samples = m_MSAA;
				color_attachment_description.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				color_attachment_description.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				color_attachment_description.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				color_attachment_description.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				color_attachment_description.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				color_attachment_description.finalLayout = (m_MSAAOn) ? VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL : VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

				VkAttachmentReference color_attachment_reference = {};
				color_attachment_reference.attachment = count;
				color_attachment_reference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

				attachments[count++] = color_attachment_description;

				//Depth Swapchain Attachment & Reference
				VkAttachmentDescription depth_attachment_description = {};
				VkAttachmentReference depth_attachment_reference = {};
				if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
					depth_attachment_description.format = m_VkFormatDepth;
					depth_attachment_description.samples = m_MSAA;
					depth_attachment_description.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
					depth_attachment_description.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					depth_attachment_description.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					depth_attachment_description.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					depth_attachment_description.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
					depth_attachment_description.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

					depth_attachment_reference.attachment = count;
					depth_attachment_reference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

					attachments[count++] = depth_attachment_description;
				}

				//Backup Swapchain Attachment & Reference (Need it for MSAA)
				VkAttachmentDescription color_attachment_resolve = {};
				VkAttachmentReference color_attachment_resolve_reference = {};
				if (m_MSAAOn) {
					color_attachment_resolve.format = m_VkFormatSurface.format;
					color_attachment_resolve.samples = VK_SAMPLE_COUNT_1_BIT;
					color_attachment_resolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					color_attachment_resolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
					color_attachment_resolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					color_attachment_resolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					color_attachment_resolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
					color_attachment_resolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

					color_attachment_resolve_reference.attachment = count;
					color_attachment_resolve_reference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

					attachments[count++] = color_attachment_resolve;
				}

				//Setup the Subpass and Dependency
				VkSubpassDescription subpass_description = {};
				subpass_description.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				subpass_description.colorAttachmentCount = 1;
				subpass_description.pColorAttachments = &color_attachment_reference;
				subpass_description.pDepthStencilAttachment = (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) ? &depth_attachment_reference : nullptr;
				subpass_description.pResolveAttachments = (m_MSAAOn) ? &color_attachment_resolve_reference : nullptr;

				VkSubpassDependency subpass_dependency = {};
				subpass_dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
				subpass_dependency.dstSubpass = 0;
				subpass_dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				subpass_dependency.srcAccessMask = 0;
				subpass_dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				subpass_dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

				//Setup and Create the RenderPass
				VkRenderPassCreateInfo render_pass_create_info = {};
				render_pass_create_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
				render_pass_create_info.attachmentCount = count;
				render_pass_create_info.pAttachments = attachments;
				render_pass_create_info.subpassCount = 1;
				render_pass_create_info.pSubpasses = &subpass_description;
				render_pass_create_info.dependencyCount = 1;
				render_pass_create_info.pDependencies = &subpass_dependency;

				VkResult r = vkCreateRenderPass(m_VkDevice, &render_pass_create_info, nullptr, &m_VkRenderPass);

				delete[] attachments;
				return r;
			}

			VkResult CreateMSAABuffer() {
				//Create the image and image view for MSAA
				VkResult r = CreateImage(m_VkFormatSurface.format, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &m_GVkImageMSAA.image, &m_GVkImageMSAA.memory);
				if (r) {
					if (m_GVkImageMSAA.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.image)
						vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					return r;
				}

				r = CreateImageView(m_GVkImageMSAA.image, m_VkFormatSurface.format, VK_IMAGE_ASPECT_COLOR_BIT, &m_GVkImageMSAA.view);
				if (r) {
					if (m_GVkImageMSAA.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.view)
						vkDestroyImageView(m_VkDevice, m_GVkImageMSAA.view, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.image)
						vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					return r;
				}

				//Transition the image layout from Undefined to Color Attachment (Optimal)
				r = TransitionImageLayout(m_GVkImageMSAA.image, m_VkFormatSurface.format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
				return r;
			}

			VkResult CreateDepthBuffer() {
				//Create the image and image view for Depth Buffer
				VkResult r = CreateImage(m_VkFormatDepth, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &m_GVkImageDepth.image, &m_GVkImageDepth.memory);

				if (r) {
					if (m_GVkImageDepth.image)
						vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					if (m_GVkImageDepth.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);

					m_GVkImageDepth.image = VK_NULL_HANDLE;
					m_GVkImageDepth.memory = VK_NULL_HANDLE;
					return r;
				}

				r = CreateImageView(m_GVkImageDepth.image, m_VkFormatDepth, VK_IMAGE_ASPECT_DEPTH_BIT, &m_GVkImageDepth.view);
				if (r) {
					if (m_GVkImageDepth.view)
						vkDestroyImageView(m_VkDevice, m_GVkImageDepth.view, VK_NULL_HANDLE);
					if (m_GVkImageDepth.image)
						vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					if (m_GVkImageDepth.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);

					m_GVkImageDepth.view = VK_NULL_HANDLE;
					m_GVkImageDepth.image = VK_NULL_HANDLE;
					return r;
				}

				//Transition the image layout from Undefined to Color Attachment (Optimal)
				r = TransitionImageLayout(m_GVkImageDepth.image, m_VkFormatDepth, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);

				return r;
			}
		
			VkResult CreateVkFramebuffer() {
				//Setup Variables
				VkResult r{};
				uint32_t count = 0;
				VkImageView image_attachments[GVK_SWAP_BUFFER_LIMIT];

				//Loop through the Swapchain Frame Buffers and set their create info
				for (unsigned int i = 0; i < m_MaxFrameCount; ++i) {
					// Create an array of image attachments for create info (NOTE: There is only 1 Color Image View and Depth Buffer!)
					count = 0;
					if (m_MSAAOn) {
						image_attachments[count++] = m_GVkImageMSAA.view;
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							image_attachments[count++] = m_GVkImageDepth.view;
						image_attachments[count++] = m_VkImageViewSwapchain[i];
					}
					else {
						image_attachments[count++] = m_VkImageViewSwapchain[i];
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							image_attachments[count++] = m_GVkImageDepth.view;
					}

					//Frame Buffer's Create Info
					VkFramebufferCreateInfo frame_buffer_create_info = {};
					frame_buffer_create_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
					frame_buffer_create_info.renderPass = m_VkRenderPass;
					frame_buffer_create_info.attachmentCount = count;
					frame_buffer_create_info.pAttachments = image_attachments;
					frame_buffer_create_info.width = m_VkExtent2DSurface.width;
					frame_buffer_create_info.height = m_VkExtent2DSurface.height;
					frame_buffer_create_info.layers = 1;

					//Create the Surface (With Results) [VK_SUCCESS = 0]
					r = vkCreateFramebuffer(m_VkDevice, &frame_buffer_create_info, nullptr, &m_VkFramebuffer[i]);
				}

				//delete[] image_attachments;
				return r;
			}

			VkResult CreateVkCommandBuffer() {
				//Allocate Command buffer Information
				VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
				command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
				command_buffer_allocate_info.commandPool = m_VkCommandPool;
				command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
				command_buffer_allocate_info.commandBufferCount = m_MaxFrameCount;

				//Create Command Buffer
				VkResult r = vkAllocateCommandBuffers(m_VkDevice, &command_buffer_allocate_info, &m_VkCommandBuffer[0]);

				//Return Result
				return r;
			}

			//Cleanup & Error Check Methods
			GReturn ResetSwapchain() {
				//Wait for Device to finish
				vkDeviceWaitIdle(m_VkDevice);

				//Update Swapchain Surface Data
				m_GWindow.GetClientWidth(m_WindowExtent.width);
				m_GWindow.GetClientHeight(m_WindowExtent.height);
				m_AspectRatio = m_WindowExtent.width / static_cast<float>(m_WindowExtent.height);
				GetSurfaceData();

				//Recreate Swapchain
				return (+CreateSwapchain() && CreateSyncObjects() == VK_SUCCESS)
					? GReturn::SUCCESS : GReturn::UNEXPECTED_RESULT; //How would this fail if it was created before......
			}

			void CleanupSwapchain() {
				//Cleanup Command Buffers
				if (m_VkCommandBuffer[0]) {
					vkFreeCommandBuffers(m_VkDevice, m_VkCommandPool, m_MaxFrameCount, &m_VkCommandBuffer[0]);
					for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i)
						m_VkCommandBuffer[i] = VK_NULL_HANDLE;
				}

				//Cleanup Frame Buffers
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkFramebuffer[i]) {
						vkDestroyFramebuffer(m_VkDevice, m_VkFramebuffer[i], VK_NULL_HANDLE);
					}
					m_VkFramebuffer[i] = VK_NULL_HANDLE;
				}

				//Cleanup Depth Buffer
				if (m_GVkImageDepth.image) {
					vkDestroyImageView(m_VkDevice, m_GVkImageDepth.view, VK_NULL_HANDLE);
					vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);
					m_GVkImageDepth = {};
				}

				//Cleanup MSAA Image
				if (m_GVkImageMSAA.image) {
					vkDestroyImageView(m_VkDevice, m_GVkImageMSAA.view, VK_NULL_HANDLE);
					vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					m_GVkImageMSAA = {};
				}

				//Cleanup Render Pass
				if (m_VkRenderPass) {
					vkDestroyRenderPass(m_VkDevice, m_VkRenderPass, VK_NULL_HANDLE);
					m_VkRenderPass = VK_NULL_HANDLE;
				}

				//Cleanup Swapchain's Image View
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkImageViewSwapchain[i]) {
						vkDestroyImageView(m_VkDevice, m_VkImageViewSwapchain[i], VK_NULL_HANDLE);
					}
					m_VkImageViewSwapchain[i] = VK_NULL_HANDLE;
				}

				//Cleanup Swapchain
				if (m_VkSwapchainKHR) {
					vkDestroySwapchainKHR(m_VkDevice, m_VkSwapchainKHR, VK_NULL_HANDLE);
					m_VkSwapchainKHR = VK_NULL_HANDLE;
				}
			}
			
			void CleanupSyncObjects() {
				//Cleanup Fence (Rendering)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkFenceRendering[i]) {
						vkWaitForFences(m_VkDevice, 1, &m_VkFenceRendering[i], VK_TRUE, ~(static_cast<uint64_t>(0)));
						vkDestroyFence(m_VkDevice, m_VkFenceRendering[i], VK_NULL_HANDLE);
					}
					m_VkFenceRendering[i] = VK_NULL_HANDLE;
				}

				//Cleanup Semaphore (Render Finished)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkSemaphoreRenderFinished[i]) {
						vkDestroySemaphore(m_VkDevice, m_VkSemaphoreRenderFinished[i], VK_NULL_HANDLE);
					}
					m_VkSemaphoreRenderFinished[i] = VK_NULL_HANDLE;
				}

				//Cleanup Semaphore (Image Available)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkSemaphoreImageAvailable[i]) {
						vkDestroySemaphore(m_VkDevice, m_VkSemaphoreImageAvailable[i], VK_NULL_HANDLE);
					}
					m_VkSemaphoreImageAvailable[i] = VK_NULL_HANDLE;
				}
			}

			void CleanupVulkanSurface() {
				//Wait for Device to finish
				if (m_VkDevice)
					vkDeviceWaitIdle(m_VkDevice);

				//Cleanup Sync primitives
				CleanupSyncObjects();

				//Cleanup Swapchain
				CleanupSwapchain();

				//Cleanup Command Pool
				if (m_VkCommandPool) {
					vkDestroyCommandPool(m_VkDevice, m_VkCommandPool, VK_NULL_HANDLE);
					m_VkCommandPool = VK_NULL_HANDLE;
				}

				//Cleanup Device
				if (m_VkDevice) {
					vkDestroyDevice(m_VkDevice, VK_NULL_HANDLE);
					m_VkDevice = VK_NULL_HANDLE;
				}

				//Cleanup Surface
				if (m_VkSurfaceKHR) {
					vkDestroySurfaceKHR(m_VkInstance, m_VkSurfaceKHR, VK_NULL_HANDLE);
					m_VkSurfaceKHR = VK_NULL_HANDLE;
				}

				//Other Allocated Memory 
				if (m_WindowName) {
					delete[] m_WindowName;
					m_WindowName = nullptr;
				}

				if (m_AllPhysicalDevices)		{ delete[] m_AllPhysicalDevices; m_AllPhysicalDevices = nullptr;}
				if (m_AllQueueFamilyProperties) { delete[] m_AllQueueFamilyProperties; m_AllQueueFamilyProperties = nullptr; }
				if (m_DeviceExtensions)			{ delete[] m_DeviceExtensions; m_DeviceExtensions = nullptr; }
				if (m_InstanceExtensions)		{ delete[] m_InstanceExtensions; m_InstanceExtensions = nullptr; }
				if (m_InstanceLayers)			{ delete[] m_InstanceLayers; m_InstanceLayers = nullptr; }

				m_Deallocated = true;
			}

			VkResult CheckCompatibility(const char** _instanceExtensions, const char** _deviceExtensions) {
				//Setup Variables for checks
				const char* use_surface = VK_KHR_SURFACE_EXTENSION_NAME;
				const char* use_swapchain = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
				const char* platform_surface = m_VulkanHelperOS.GetPlatformSurfaceExtension();

				//Check for Compatibility
				if (CheckInstanceExtensionName(use_surface))
					return VK_ERROR_EXTENSION_NOT_PRESENT;
				if (CheckInstanceExtensionName(platform_surface))
					return VK_ERROR_EXTENSION_NOT_PRESENT;

				//Check if the extensions are already in the extensions
				uint32_t gotExtFlag = 7; //Flag Magic Numbers: 1 = Vulkan surface, 2 = platform surface, 4 = swapchain
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i) {
					if (!strcmp(_instanceExtensions[i], use_surface))
						gotExtFlag &= ~(1u);
					if (!strcmp(_instanceExtensions[i], platform_surface))
						gotExtFlag &= ~(2u);
				}

				//And in Device Extension
				for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i)
					if (!strcmp(_deviceExtensions[i], use_swapchain)) {
						gotExtFlag &= ~(4u);
						break;
					}

				//Find the true number you need:
				uint32_t instExtAdded = 0;
				if (gotExtFlag & 1) ++instExtAdded;
				if (gotExtFlag & 2) ++instExtAdded;
				uint32_t devExtAdded = (gotExtFlag & 4) ? 1 : 0;

				//Create the new arrays for the extensions
				m_InstanceExtensions = new const char* [static_cast<size_t>(m_InstanceExtensionCount) + instExtAdded];
				m_DeviceExtensions = new const char* [static_cast<size_t>(m_DeviceExtensionCount) + devExtAdded];
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i)
					m_InstanceExtensions[i] = _instanceExtensions[i];
				for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i)
					m_DeviceExtensions[i] = _deviceExtensions[i];

				//Add in the adds if needed
				if (gotExtFlag & 2) {
					m_InstanceExtensions[m_InstanceExtensionCount + instExtAdded - 1] = platform_surface;
					--instExtAdded;
				}

				if (gotExtFlag & 1) {
					m_InstanceExtensions[m_InstanceExtensionCount + instExtAdded - 1] = use_surface;
					--instExtAdded;
				}

				if (gotExtFlag & 4) {
					m_DeviceExtensions[m_DeviceExtensionCount] = use_swapchain;
					++m_DeviceExtensionCount;
				}

				//Add up the instance extension (since there was more than 1)
				if (gotExtFlag & 1) ++m_InstanceExtensionCount;
				if (gotExtFlag & 2) ++m_InstanceExtensionCount;

				//Return Successful
				return VK_SUCCESS;
			}

			VkResult CheckInstanceVectors() {
				for (uint32_t i = 0; i < m_InstanceLayerCount; ++i)
					if (CheckInstanceLayerName(m_InstanceLayers[i]))
						return VK_ERROR_LAYER_NOT_PRESENT;
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i)
					if (CheckInstanceExtensionName(m_InstanceExtensions[i]))
						return VK_ERROR_EXTENSION_NOT_PRESENT;

				return VK_SUCCESS;
			}

			VkResult CheckDeviceVector() {
				for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i)
					if (CheckDeviceExtensionName(m_DeviceExtensions[i]))
						return VK_ERROR_EXTENSION_NOT_PRESENT;

				return VK_SUCCESS;
			}

			//Error Checking Helper Methods & Variables
			std::vector<VkLayerProperties> m_AllInstanceLayers;			uint32_t m_AllInstanceLayerCount = 0;
			std::vector<VkExtensionProperties> m_AllInstanceExtensions;	uint32_t m_AllInstanceExtensionCount = 0;
			std::vector<VkExtensionProperties>	m_AllDeviceExtensions;	uint32_t m_AllDeviceExtensionCount = 0;
			VkResult CheckInstanceLayerName(const char* _layer) {
				//Check to see if this was already created
				if (m_AllInstanceLayers.empty()) {
					//Get the Size
					VkResult r = vkEnumerateInstanceLayerProperties(&m_AllInstanceLayerCount, VK_NULL_HANDLE);
					if (m_AllInstanceLayerCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllInstanceLayers.resize(m_AllInstanceLayerCount);
					r = vkEnumerateInstanceLayerProperties(&m_AllInstanceLayerCount, m_AllInstanceLayers.data());
					if (r) return r;
				}

				//Compare all instance layers with the parameter
				for (int i = 0; i < m_AllInstanceLayers.size(); i++)
					if (!strcmp(m_AllInstanceLayers[i].layerName, _layer))
						return VK_SUCCESS;

				return VK_ERROR_LAYER_NOT_PRESENT;
			}

			VkResult CheckInstanceExtensionName(const char* _extensions) {
				//Check to see if this was already created
				if (m_AllInstanceExtensions.empty()) {
					//Get the Size
					VkResult r = vkEnumerateInstanceExtensionProperties(nullptr, &m_AllInstanceExtensionCount, VK_NULL_HANDLE);
					if (m_AllInstanceExtensionCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllInstanceExtensions.resize(m_AllInstanceExtensionCount);
					r = vkEnumerateInstanceExtensionProperties(nullptr, &m_AllInstanceExtensionCount, m_AllInstanceExtensions.data());
					if (r) return r;
				}

				//Compare all instance extensions with the parameter
				for (int i = 0; i < m_AllInstanceExtensions.size(); ++i)
					if (!strcmp(m_AllInstanceExtensions[i].extensionName, _extensions))
						return VK_SUCCESS;

				return VK_ERROR_EXTENSION_NOT_PRESENT;
			}

			VkResult CheckDeviceExtensionName(const char* _extensions) {
				//Check to see if this was already created
				if (m_AllDeviceExtensions.empty()) {
					//Get the Size
					VkResult r = vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, nullptr, &m_AllDeviceExtensionCount, VK_NULL_HANDLE);
					if (m_AllDeviceExtensionCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllDeviceExtensions.resize(m_AllDeviceExtensionCount);
					r = vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, nullptr, &m_AllDeviceExtensionCount, m_AllDeviceExtensions.data());
					if (r) return r;
				}

				//Compare all device extensions with the parameter
				for (int i = 0; i < m_AllDeviceExtensions.size(); ++i)
					if (!strcmp(m_AllDeviceExtensions[i].extensionName, _extensions))
						return VK_SUCCESS;

				return VK_ERROR_EXTENSION_NOT_PRESENT;
			}

			//Gathering Helper Methods
			VkPhysicalDevice* m_AllPhysicalDevices = nullptr;				uint32_t m_AllPhysicalDeviceCount = 0;
			VkQueueFamilyProperties* m_AllQueueFamilyProperties = nullptr;	uint32_t m_AllQueueFamilyPropertyCount = 0;
			VkResult GetAllPhysicalDevices() {
				//Check to see if this was already created
				if (!m_AllPhysicalDevices) {
					//Get the Size
					VkResult r = vkEnumeratePhysicalDevices(m_VkInstance, &m_AllPhysicalDeviceCount, VK_NULL_HANDLE);
					if (m_AllPhysicalDeviceCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllPhysicalDevices = new VkPhysicalDevice[m_AllPhysicalDeviceCount];
					r = vkEnumeratePhysicalDevices(m_VkInstance, &m_AllPhysicalDeviceCount, m_AllPhysicalDevices);
					if (r) return r;
				}

				//Return Success
				return VK_SUCCESS;
			}
		
			VkResult GetBestGPU() {
				/* What will determine the best GPU:
				* 1.) Compatibility [DQ] {Swapchain, Queue Family, Device Extensions}
				* 2.) Device Type [^N] (Dedicated, Virtual, Integrated, Other, CPU)
				* 3.) Added Memory [x(N/1024)]
				* 4.) Features [+N * size]
				*/

				//Of course, don't do this if there is only 1 device......
				if (m_AllPhysicalDeviceCount == 1) {
					m_VkPhysicalDevice = m_AllPhysicalDevices[0];
					return VK_SUCCESS;
				}

				//Setup
				uint32_t gpuPow = 0;
				uint64_t gpuMult = 1;
				uint32_t gpuAdd = 0;

				uint64_t BestIndex = 0;
				uint64_t BestScore = 0;

				//Loop through each of the Physical Devices
				for (size_t i = 0; i < m_AllPhysicalDeviceCount; ++i) {
					//Setup: Set Physical Device as if this is the chosen device
					m_VkPhysicalDevice = m_AllPhysicalDevices[i];

					//Compatibility Setup: Device Extension Check: (PS: Swapchain support should be here at this point)
					bool _reset = false;
					for (uint32_t j = 0; j < m_DeviceExtensionCount; ++j)
						if (CheckDeviceExtensionName(m_DeviceExtensions[j])) {
							_reset = true;
							break;
						}
					if (_reset) continue;

					//Compatibility Setup: Queue Family Indices
					m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = -1;
					if (m_AllQueueFamilyProperties) {
						delete[] m_AllQueueFamilyProperties;
						m_AllQueueFamilyProperties = nullptr;
						m_AllQueueFamilyPropertyCount = 0;
					}
					VkResult r = GetQueueFamilyIndices();
					if (r) continue;

					//Device Type: Best Type [Discrete, Virtual, Integrated, CPU/OTHER] in order
					VkPhysicalDeviceProperties pDevProps;
					vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &pDevProps);
					switch (pDevProps.deviceType) {
						case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
							gpuPow = 3;
							break;
						case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
							gpuPow = 2;
							break;
						default:
							gpuPow = 1;
							break;
					}

					//Physical Device Memory
					VkPhysicalDeviceMemoryProperties mem_prop = {};
					vkGetPhysicalDeviceMemoryProperties(m_VkPhysicalDevice, &mem_prop);
					for (uint32_t j = 0; j < mem_prop.memoryHeapCount; ++j)
						if (mem_prop.memoryHeaps[j].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
						{
							gpuMult = mem_prop.memoryHeaps[j].size / 0x40000000;
							break;
						}

					//Lastly: Features
					VkPhysicalDeviceFeatures device_feature;
					vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, &device_feature);
					int32_t pDevFeatSize = sizeof(VkPhysicalDeviceFeatures);
					const VkBool32 IMTRUE = VK_TRUE;
					while (pDevFeatSize > -1) {
						pDevFeatSize -= sizeof(VkBool32);
						if (!memcmp(reinterpret_cast<char*>(&device_feature) + pDevFeatSize, &IMTRUE, sizeof(VkBool32)))
							gpuAdd += 100;
					}

					//Tally up Score:
					uint64_t score = 0;
					score += gpuAdd;
					score *= gpuMult;
					uint64_t cScore = score;
					for (uint32_t j = 0; j < gpuPow; ++j) score *= cScore;

					//Check Best Score
					if (score > BestScore) {
						BestIndex = i;
						BestScore = score;
					}
				}
				m_VkPhysicalDevice = m_AllPhysicalDevices[BestIndex];


				return VK_SUCCESS;
			}

			VkResult GetQueueFamilyIndices() {
				//Check to see if this was already created
				if (!m_AllQueueFamilyProperties) {
					vkGetPhysicalDeviceQueueFamilyProperties(m_VkPhysicalDevice, &m_AllQueueFamilyPropertyCount, VK_NULL_HANDLE);
					if (m_AllQueueFamilyPropertyCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }

					//Resize Vector and Put the contents in it.
					m_AllQueueFamilyProperties = new VkQueueFamilyProperties[m_AllQueueFamilyPropertyCount];
					vkGetPhysicalDeviceQueueFamilyProperties(m_VkPhysicalDevice, &m_AllQueueFamilyPropertyCount, m_AllQueueFamilyProperties);
				}

				//Setup Variable Usage
				VkBool32 presentSupport = VK_FALSE;
				VkResult r = VK_SUCCESS;

				//Loop through each Queue Properties and find a queue that works together. [WITH COMPUTER SHADER]
				for (uint32_t i = 0; i < m_AllQueueFamilyPropertyCount; ++i) {
					//Set current Queue property
					VkQueueFamilyProperties* cur = &m_AllQueueFamilyProperties[i];

					//Check to see if flags meet
					if (cur->queueCount && (cur->queueFlags & (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT))) {
						//Figure out if surface can present with queue index
						r = vkGetPhysicalDeviceSurfaceSupportKHR(m_VkPhysicalDevice, i, m_VkSurfaceKHR, &presentSupport);
						if (r) continue;

						//If found, set the indices
						if (presentSupport) {
							m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = i;
							m_CanCompute = VK_TRUE;
							return r;
						}
					}
				}

				//Loop through each Queue Properties and find a queue that works together. [WITHOUT COMPUTER SHADER]
				for (uint32_t i = 0; i < m_AllQueueFamilyPropertyCount; ++i) {
					//Set current Queue property
					VkQueueFamilyProperties* cur = &m_AllQueueFamilyProperties[i];

					//Check to see if flags meet
					if (cur->queueCount && (cur->queueFlags & VK_QUEUE_GRAPHICS_BIT)) {
						//Figure out if surface can present with queue index
						r = vkGetPhysicalDeviceSurfaceSupportKHR(m_VkPhysicalDevice, i, m_VkSurfaceKHR, &presentSupport);
						if (r) continue;

						//If found, set the indices
						if (presentSupport) {
							m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = i;
							m_CanCompute = VK_FALSE;
							return r;
						}
					}
				}

				//Couldn't find anything.
				m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = -1;
				return VK_ERROR_FEATURE_NOT_PRESENT;
			}

			//Gathering Surface Data
			std::vector<VkSurfaceFormatKHR> m_AllSurfaceFormats;	uint32_t m_AllSurfaceFormatCount = 0;
			std::vector<VkPresentModeKHR> m_AllPresentModes;		uint32_t m_AllPresentModeCount = 0;
			VkResult GetSurfaceFormat() {
				if (m_AllSurfaceFormats.empty()) {
					//Gather all the surface formats
					VkResult r = vkGetPhysicalDeviceSurfaceFormatsKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllSurfaceFormatCount, VK_NULL_HANDLE);
					if (m_AllSurfaceFormatCount < 1) return VK_ERROR_FEATURE_NOT_PRESENT;
					if (r) return r;

					//Resize and fill in surface formats
					m_AllSurfaceFormats.resize(m_AllSurfaceFormatCount);
					r = vkGetPhysicalDeviceSurfaceFormatsKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllSurfaceFormatCount, m_AllSurfaceFormats.data());
					if (r) return r;
				}

				//If Format is undefined, set it to best automatically
				if (m_AllSurfaceFormatCount == 1 && m_AllSurfaceFormats[0].format == VK_FORMAT_UNDEFINED) {
					m_VkFormatSurface = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
					return VK_SUCCESS;
				}

				//Find the best
				for (int i = 0; i < m_AllSurfaceFormats.size(); ++i)
					if (m_AllSurfaceFormats[i].format == VK_FORMAT_B8G8R8A8_UNORM && m_AllSurfaceFormats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
						m_VkFormatSurface = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
						return VK_SUCCESS;
					}

				//Best wasn't found, take [0]
				m_VkFormatSurface = m_AllSurfaceFormats[0];
				return VK_SUCCESS;
			}

			VkResult GetSurfacePresentMode() {
				//Check to see if this was already created
				if (m_AllPresentModes.empty()) {
					//Get the Size
					VkResult r = vkGetPhysicalDeviceSurfacePresentModesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllPresentModeCount, VK_NULL_HANDLE);
					if (m_AllPresentModeCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllPresentModes.resize(m_AllPresentModeCount);
					r = vkGetPhysicalDeviceSurfacePresentModesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllPresentModeCount, m_AllPresentModes.data());
					if (r) return r;
				}

				//Find the best mode (best: Mailbox, runner-up: Immediate, Default: FIFO)
				VkPresentModeKHR VSyncModes[2] = { VK_PRESENT_MODE_IMMEDIATE_KHR , VK_PRESENT_MODE_MAILBOX_KHR };
				VkPresentModeKHR best_mode = VK_PRESENT_MODE_FIFO_KHR;//	//This is best by default. It is because Vulkan requires this to be supported, and not any of others.
				for (uint32_t i = 0; i < m_AllPresentModeCount; ++i) {	//So if any of these fail (Mailbox, Immediate, Shared), FIFO is guaranteed to work!
					if (m_AllPresentModes[i] == VSyncModes[m_VSync]) {
						best_mode = VSyncModes[m_VSync];
						m_VkPresentModeKHRSurface = best_mode;
						break;
					}
					else if (m_AllPresentModes[i] == VSyncModes[!m_VSync])
						m_VkPresentModeKHRSurface = VSyncModes[!m_VSync];
				}

				return VK_SUCCESS;
			}

			VkResult GetSurfaceExtent() {
				//Gather all surface capabilities
				VkSurfaceCapabilitiesKHR surface_capabilities;
				VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &surface_capabilities);
				if (r) return r;

				//If Capabilities's extent is not MAX, Set to those extents
				if (surface_capabilities.currentExtent.width != 0xFFFFFFFF)
					m_VkExtent2DSurface = { surface_capabilities.currentExtent.width, surface_capabilities.currentExtent.height };
				else //Otherwise set it to window's width and height.
					m_VkExtent2DSurface = { m_WindowExtent.width, m_WindowExtent.height };

				return r;
			}

			VkResult GetDepthFormat() {
				//Setup Depth Format
				VkFormat depth_formats[3];

				//Order Formats
				if (m_InitMask & GRAPHICS::DEPTH_STENCIL_SUPPORT) {
					depth_formats[0] = VK_FORMAT_D32_SFLOAT_S8_UINT;
					depth_formats[1] = VK_FORMAT_D24_UNORM_S8_UINT;
					depth_formats[2] = VK_FORMAT_D32_SFLOAT;
				}
				else {
					depth_formats[0] = VK_FORMAT_D32_SFLOAT;
					depth_formats[1] = VK_FORMAT_D32_SFLOAT_S8_UINT;
					depth_formats[2] = VK_FORMAT_D24_UNORM_S8_UINT;
				}

				//Find the best compatible format for Depth
				for (uint32_t i = 0; i < 3; ++i) {
					VkFormatProperties format_properties;
					vkGetPhysicalDeviceFormatProperties(m_VkPhysicalDevice, depth_formats[i], &format_properties);

					if ( (format_properties.linearTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) == VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
						m_VkFormatDepth = depth_formats[i];
						return VK_SUCCESS;
					}
					else if ((format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) == VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
						m_VkFormatDepth = depth_formats[i];
						return VK_SUCCESS;
					}
				}

				//Format not found, set to [0]
				m_VkFormatDepth = depth_formats[0];
				return VK_SUCCESS;
			}

			//Image Creation Helper Methods
			VkResult CreateImage(const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkImage* _outImage, VkDeviceMemory* _outImageMemory) {
				//Create image info
				VkImageCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
				create_info.imageType = VK_IMAGE_TYPE_2D;
				create_info.extent = { m_VkExtent2DSurface.width, m_VkExtent2DSurface.height, 1 };
				create_info.mipLevels = 1;
				create_info.arrayLayers = 1;
				create_info.format = _format;
				create_info.tiling = _tiling;
				create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				create_info.usage = _usageFlags;
				create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
				create_info.samples = m_MSAA;
				create_info.flags = 0;

				//Create the image
				VkResult r = vkCreateImage(m_VkDevice, &create_info, VK_NULL_HANDLE, _outImage);
				if (r) return r;

				//Gather Memory Information from image & Physical Device
				VkMemoryRequirements memory_requirements;
				vkGetImageMemoryRequirements(m_VkDevice, *_outImage, &memory_requirements);
				VkPhysicalDeviceMemoryProperties memory_properties;
				vkGetPhysicalDeviceMemoryProperties(m_VkPhysicalDevice, &memory_properties);

				//Loop through the memory type count and see if there is a match with both the filter and property flags
				int32_t memory_type_index = -1;
				for (uint32_t i = 0; i < memory_properties.memoryTypeCount; ++i) {
					if ((memory_requirements.memoryTypeBits & (1 << i)) &&
						(memory_properties.memoryTypes[i].propertyFlags & _memoryPropertyFlags) == _memoryPropertyFlags) {
						memory_type_index = i;
						break;
					}
				}
				if (memory_type_index == -1)
					return VK_ERROR_NOT_PERMITTED_EXT;


				//Memory Allocate Info
				VkMemoryAllocateInfo memory_allocate_info = {};
				memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
				memory_allocate_info.allocationSize = memory_requirements.size;
				memory_allocate_info.memoryTypeIndex = memory_type_index;

				//Allocate the memory created
				r = vkAllocateMemory(m_VkDevice, &memory_allocate_info, VK_NULL_HANDLE, _outImageMemory);
				if (r) {
					vkDestroyImage(m_VkDevice, *_outImage, VK_NULL_HANDLE);
					return r;
				}

				//Bind the memory created
				r = vkBindImageMemory(m_VkDevice, *_outImage, *_outImageMemory, 0);
				if (r) {
					vkDestroyImage(m_VkDevice, *_outImage, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, *_outImageMemory, VK_NULL_HANDLE);
					return r;
				}

				//Image Creation has been successful!
				return r;
			}

			VkResult CreateImageView(const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, VkImageView* _outImageView) {
				//Image View Create Info
				VkImageViewCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
				create_info.image = _image;
				create_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
				create_info.format = _format;
				create_info.subresourceRange.aspectMask = _imageAspectFlags;
				create_info.subresourceRange.baseMipLevel = 0;
				create_info.subresourceRange.levelCount = 1;
				create_info.subresourceRange.baseArrayLayer = 0;
				create_info.subresourceRange.layerCount = 1;

				//Create the Surface (With Results) [VK_SUCCESS = 0]
				VkResult r = vkCreateImageView(m_VkDevice, &create_info, nullptr, _outImageView);

				//Image View has been created successfully, return it
				return r;
			}

			VkResult TransitionImageLayout(const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout) {
				//Setup the Command Buffer's Allocation Information
				VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
				command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
				command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
				command_buffer_allocate_info.commandPool = m_VkCommandPool;
				command_buffer_allocate_info.commandBufferCount = 1;

				//Allocate the Command Buffer
				VkCommandBuffer command_buffer = VK_NULL_HANDLE;
				VkResult r = vkAllocateCommandBuffers(m_VkDevice, &command_buffer_allocate_info, &command_buffer);
				if (r) return r;

				//Start the command buffer's begin info
				VkCommandBufferBeginInfo command_buffer_begin_info = {};
				command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
				command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

				//Begin the Command Buffer's recording process
				r = vkBeginCommandBuffer(command_buffer, &command_buffer_begin_info);
				if (r) return r;

				//Create the image memory barrier
				VkImageMemoryBarrier image_memory_barrier = {};
				image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				image_memory_barrier.image = _image;
				image_memory_barrier.oldLayout = _previousLayout;
				image_memory_barrier.newLayout = _currentLayout;
				image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
				image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
				image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
				image_memory_barrier.subresourceRange.baseMipLevel = 0;
				image_memory_barrier.subresourceRange.levelCount = 1;
				image_memory_barrier.subresourceRange.layerCount = 1;
				image_memory_barrier.subresourceRange.baseArrayLayer = 0;

				//Setup the source and destination stage flags. Will be set based on the Old and New Layout set from outside
				VkPipelineStageFlags source_stage = VK_NULL_HANDLE;
				VkPipelineStageFlags destrination_stage = VK_NULL_HANDLE;

				if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
				{
					image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
					if (_format == VK_FORMAT_D24_UNORM_S8_UINT || _format == VK_FORMAT_D32_SFLOAT_S8_UINT)
						image_memory_barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
				}

				if (_previousLayout == VK_IMAGE_LAYOUT_UNDEFINED)
				{
					if (_currentLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
					}
					else if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
					}
					else if (_currentLayout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
					}
				}
				else if (_previousLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && _currentLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
				{
					image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
					image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

					source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
					destrination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
				}

				vkCmdPipelineBarrier(command_buffer, source_stage, destrination_stage, 0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

				//End the Command Buffer's recording Process
				r = vkEndCommandBuffer(command_buffer);
				if (r) return r;

				//Create the submit info
				VkSubmitInfo submit_info = {};
				submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
				submit_info.commandBufferCount = 1;
				submit_info.pCommandBuffers = &command_buffer;

				//Submit The Commands Recorded into the Queue. Then wait for the Graphics Queue to be idle
				r = vkQueueSubmit(m_VkQueueGraphics, 1, &submit_info, VK_NULL_HANDLE);
				if (r) return r;

				r = vkQueueWaitIdle(m_VkQueueGraphics);
				if (r) return r;

				//Free the command buffer from memory
				vkFreeCommandBuffers(m_VkDevice, m_VkCommandPool, 1, &command_buffer);

				//The Command Buffer has ended successfully!
				return VK_SUCCESS;
			}

			//Math Helper Function (Credit: https://graphics.stanford.edu/~seander/bithacks.html)
			//Title: Find integer log base 2 of a 32-bit IEEE float
			uint32_t __log2(const float& v) {
				int32_t c; // 32-bit int c gets the result;
				int32_t x;
				memcpy(&x, &v, sizeof(x)); //[OR, not for portability: int x = *(const int *) &v;]
				c = x >> 23;
				c -= 127;
				return c;
			}

			//Destroy Query Info
			void DestroyQueryVariable() {
				if (m_VkQueryInfo) {
				//Delete Const Chars
				if (m_VkQueryInfo->instanceLayers)			 	delete[] m_VkQueryInfo->instanceLayers;
				if (m_VkQueryInfo->instanceExtensions)			delete[] m_VkQueryInfo->instanceExtensions;	
				if (m_VkQueryInfo->deviceExtensions)			delete[] m_VkQueryInfo->deviceExtensions;

				//Delete Void*
				if (m_VkQueryInfo->instanceLayerProperties)		delete static_cast<VkLayerProperties*>(m_VkQueryInfo->instanceLayerProperties);
				if (m_VkQueryInfo->instanceExtensionProperties)	delete static_cast<VkExtensionProperties*>(m_VkQueryInfo->instanceExtensionProperties);
				if (m_VkQueryInfo->deviceExtensionProperties)	delete static_cast<VkExtensionProperties*>(m_VkQueryInfo->deviceExtensionProperties);
				if (m_VkQueryInfo->physicalDeviceFeatures)		delete static_cast<VkPhysicalDeviceFeatures*>(m_VkQueryInfo->physicalDeviceFeatures);

				//Delete Itself
				delete[] m_VkQueryInfo; m_VkQueryInfo = nullptr;
				}
			}

			//Construct Query Info
			void CreateQueryVariable() {
				m_VkQueryInfo = new GVulkanSurfaceQueryInfo();
				memset(m_VkQueryInfo, 0, sizeof(GVulkanSurfaceQueryInfo));
			}

		private:
			//GVulkan Structs
			GVulkanSurfaceQueryInfo* m_VkQueryInfo = nullptr;
			GVulkanSurfacePlatformFucts m_VulkanHelperOS;

			//GWindow Properties
			SYSTEM::GWindow m_GWindow;
			SYSTEM::UNIVERSAL_WINDOW_HANDLE m_WindowHandle = { nullptr, nullptr };
			VkExtent2D m_WindowTopLeft = {0, 0};
			VkExtent2D m_WindowExtent = {0, 0};
			GW::CORE::GEventResponder m_EventResponder;
			char* m_WindowName = nullptr;
			float m_AspectRatio = 0;
			bool m_Deallocated = false;
			bool m_NoDrawing = false;

			//Main Vulkan Objects
			VkInstance m_VkInstance = VK_NULL_HANDLE;
			VkSurfaceKHR m_VkSurfaceKHR = VK_NULL_HANDLE;
			VkPhysicalDevice m_VkPhysicalDevice = VK_NULL_HANDLE;
			VkDevice m_VkDevice = VK_NULL_HANDLE;
			VkCommandPool m_VkCommandPool = VK_NULL_HANDLE;
			VkSwapchainKHR m_VkSwapchainKHR = VK_NULL_HANDLE;

			//Feature-Based Objects & Properties
			struct GVkImage {
				VkImage image = VK_NULL_HANDLE;
				VkImageView view = VK_NULL_HANDLE;
				VkDeviceMemory memory = VK_NULL_HANDLE;
				VkDeviceSize size = VK_NULL_HANDLE;
			};
			GVkImage m_GVkImageMSAA;
			GVkImage m_GVkImageDepth;
			bool m_VSync;
			bool m_MSAAOn;

			//Frame-Based Vulkan Objects & Properties
			uint32_t m_MaxFrameCount = 0;
			uint32_t m_CurrentFrame = 0;
			uint32_t m_TargetImage = 0;
			static constexpr unsigned GVK_SWAP_BUFFER_LIMIT = 8; 
			VkImage m_VkImageSwapchain[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkImageView m_VkImageViewSwapchain[GVK_SWAP_BUFFER_LIMIT]{};
			VkFramebuffer m_VkFramebuffer[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkCommandBuffer m_VkCommandBuffer[GVK_SWAP_BUFFER_LIMIT]{};
			VkSemaphore m_VkSemaphoreImageAvailable[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkSemaphore m_VkSemaphoreRenderFinished[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkFence m_VkFenceRendering[GVK_SWAP_BUFFER_LIMIT]{};
			
			//Other Vulkan Objects/Properties
			const char** m_InstanceLayers = nullptr;		uint32_t m_InstanceLayerCount = 0;
			const char** m_InstanceExtensions = nullptr;	uint32_t m_InstanceExtensionCount = 0;
			const char** m_DeviceExtensions = nullptr;		uint32_t m_DeviceExtensionCount = 0;
			uint64_t m_InitMask = 0;
			bool m_AllPhysicalDeviceFeatures = false;
			int m_QueueFamilyIndices[2] = {-1, -1};
			VkBool32 m_CanCompute = VK_FALSE;
			VkSampleCountFlagBits m_MSAA = VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM;
			VkQueue m_VkQueueGraphics = VK_NULL_HANDLE;
			VkQueue m_VkQueuePresent = VK_NULL_HANDLE;
			VkSurfaceCapabilitiesKHR m_VkSurfaceCapabilitiesKHR = { 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR, VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM };
			VkPresentModeKHR m_VkPresentModeKHRSurface = VK_PRESENT_MODE_MAX_ENUM_KHR;
			VkExtent2D m_VkExtent2DSurface = {0, 0};
			VkSurfaceFormatKHR m_VkFormatSurface = {VK_FORMAT_UNDEFINED, VK_COLOR_SPACE_MAX_ENUM_KHR};
			VkFormat m_VkFormatDepth = VK_FORMAT_UNDEFINED;
			VkRenderPass m_VkRenderPass = VK_NULL_HANDLE;
			bool m_FrameLocked = false;
        };
	} // end I namespace
} // end GW namespace

 // every implementation besides dummy use this
#else
    #undef GVULKANSURFACE_DUMMY_INCLUDED
#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GVulkanSurface final
			: public I::GProxy<I::GVulkanSurfaceInterface, I::GVulkanSurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVulkanSurface)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_TYPEDEF(GVulkanSurfaceQueryInfo)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetSwapchainImageCount)
			GATEWARE_CONST_FUNCTION(GetSwapchainCurrentImage)
			GATEWARE_CONST_FUNCTION(GetQueueFamilyIndices)
			GATEWARE_CONST_FUNCTION(GetGraphicsQueue)
			GATEWARE_CONST_FUNCTION(GetPresentQueue)
			GATEWARE_CONST_FUNCTION(GetSwapchainImage)
			GATEWARE_CONST_FUNCTION(GetSwapchainView)
			GATEWARE_CONST_FUNCTION(GetSwapchainFramebuffer)
			GATEWARE_CONST_FUNCTION(GetInstance)
			GATEWARE_CONST_FUNCTION(GetSurface)
			GATEWARE_CONST_FUNCTION(GetPhysicalDevice)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetCommandPool)
			GATEWARE_CONST_FUNCTION(GetSwapchain)
			GATEWARE_CONST_FUNCTION(GetRenderPass)
			GATEWARE_CONST_FUNCTION(GetCommandBuffer)
			GATEWARE_CONST_FUNCTION(GetImageAvailableSemaphore)
			GATEWARE_CONST_FUNCTION(GetRenderFinishedSemaphore)
			GATEWARE_CONST_FUNCTION(GetRenderFence)
			GATEWARE_FUNCTION(StartFrame)
			GATEWARE_FUNCTION(EndFrame)

			// reimplemented functions
			// from GEventResponderInterface
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// from GEventGeneratorInterface
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVULKANSURFACE_H
#endif // GATEWARE_FEATURE_FLAG_CICD

/*---------------------------------
|	End of GVulkanSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudio.h
----------------------------------*/
#ifndef GAUDIO_H
#define GAUDIO_H




namespace GW
{
	namespace I
	{
		class GAudioInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				DESTROY,
				PLAY_SOUNDS,
				PAUSE_SOUNDS,
				RESUME_SOUNDS,
				STOP_SOUNDS,
				PLAY_MUSIC,
				PAUSE_MUSIC,
				RESUME_MUSIC,
				STOP_MUSIC,
				MASTER_VOLUME_CHANGED,
				SOUNDS_VOLUME_CHANGED,
				MUSIC_VOLUME_CHANGED,
				SOUND_CHANNEL_VOLUMES_CHANGED,
				MUSIC_CHANNEL_VOLUMES_CHANGED
			};

			struct EVENT_DATA
			{
				float channelVolumes[6];
				unsigned int numOfChannels;
			};

			virtual GReturn SetMasterVolume(float _value) = 0;
			virtual GReturn SetGlobalSoundVolume(float _value) = 0;
			virtual GReturn SetGlobalMusicVolume(float _value) = 0;
			virtual GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn PlaySounds() = 0;
			virtual GReturn PauseSounds() = 0;
			virtual GReturn ResumeSounds() = 0;
			virtual GReturn StopSounds() = 0;
			virtual GReturn PlayMusic() = 0;
			virtual GReturn PauseMusic() = 0;
			virtual GReturn ResumeMusic() = 0;
			virtual GReturn StopMusic() = 0;
		};
	}
}

// Implementaion for GAudio.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GAUDIO) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GAUDIO) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GAudioImplementation :    public virtual GAudioInterface,
                                        public GEventGeneratorImplementation
        {
        public:
            // Main class
            GReturn Create()
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetMasterVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetGlobalSoundVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetGlobalMusicVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn PlaySounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn PauseSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn ResumeSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn StopSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn PlayMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn PauseMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn ResumeMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn StopMusic() override
            {
                return GReturn::FAILURE;
            }
        };
    }
}


#elif defined(__APPLE__)
    #ifdef __OBJC__
#import <Foundation/Foundation.h>
#import <Cocoa/Cocoa.h>
#import <AVFoundation/AVFoundation.h>
#import <AVFoundation/AVFAudio.h>
#import <AudioToolbox/AudioToolbox.h>
#endif

#include <atomic>
#include <math.h>
#define G_NUM_OF_OUTPUTS 6

namespace internal_gw
{
    class GMacAudio
    {
    public:
        AVAudioEngine* engine;
        AVAudioPlayerNode* player;
        AVAudioUnit* mainMatrixMixerNode;

        bool Init()
        {
            bool result = false;

            engine = [[AVAudioEngine alloc]init];
            player = [[AVAudioPlayerNode alloc]init];
            [engine attachNode : player] ;

            AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            mainMatrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                mainMatrixMixerNode = mixerUnit;
                [engine attachNode : mainMatrixMixerNode] ;
            }] ;

            while (!mainMatrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));

            // Set the mixer's input format to have the correct number of channels
            UInt32 size;
            AudioStreamBasicDescription mixerFormatIn;
            AudioUnitGetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);

            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            AudioUnitGetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);

            [engine connect : player to : engine.mainMixerNode format : nil] ;
            [engine connect : engine.mainMixerNode to : engine.outputNode format : nil] ;

            [engine startAndReturnError : nil] ;

            return result = engine.isRunning;
        }

        bool Unload()
        {
            // Detaches AVplayer from the AVengine
            [engine disconnectNodeInput : player] ;
            [engine detachNode : player] ;

            [player release] ;
            player = nil;

            // Cleans up memory
            if (engine != nil)
            {
                [engine release] ;
                engine = nil;
            }

            return true;
        }
    };
}

namespace GW
{
    namespace I
    {
        class GAudioImplementation :    public virtual GAudioInterface,
                                        public GEventGeneratorImplementation
        {
        public:
            float masterVolume = 1.0f;
            float soundsVolume = 1.0f;
            float musicVolume = 1.0f;
            float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
            float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
            internal_gw::GMacAudio* mac_audio = nullptr;

            virtual ~GAudioImplementation()
            {
                // Broadcast DESTROY here
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::DESTROY, nullptr_t());
                this->Push(gEvent);

                // Cleanup Objective C data
                mac_audio->Unload();
                delete mac_audio;
                mac_audio = nullptr;
            }

            // Main class
            GReturn Create()
            {
                mac_audio = new internal_gw::GMacAudio();
                bool success = mac_audio->Init();
                if (success == false)
                    return GReturn::HARDWARE_UNAVAILABLE;
                // Initalize GAudio's volumes
                masterVolume = 1.0f;
                soundsVolume = 1.0f;
                musicVolume = 1.0f;

                return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - masterVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                masterVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = masterVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetGlobalSoundVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - soundsVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                soundsVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = soundsVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetGlobalMusicVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - musicVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                musicVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = musicVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (_values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                if (_numChannels == 0 || _numChannels > 6)
                    return GReturn::INVALID_ARGUMENT;

                for (unsigned int i = 0; i < 6; ++i)
                {
                    soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
                }

                GEvent gEvent;
                EVENT_DATA eventData;
                memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
                eventData.numOfChannels = _numChannels;
                gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (_values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                if (_numChannels == 0 || _numChannels > 6)
                    return GReturn::INVALID_ARGUMENT;

                for (unsigned int i = 0; i < 6; ++i)
                {
                    musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
                }

                GEvent gEvent;
                EVENT_DATA eventData;
                memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
                eventData.numOfChannels = _numChannels;
                gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

                return this->Push(gEvent);
            }

            // Sound Events
            GReturn PlaySounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn PauseSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn ResumeSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn StopSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }

            // Music Events
            GReturn PlayMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn PauseMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn ResumeMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn StopMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::STOP_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(__linux__)
    #include <atomic>
#include <math.h>
#include <cfloat>
#include <cstring>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/context.h>

namespace GW
{
    namespace I
    {
        class GAudioImplementation :	public virtual GAudioInterface,
										public GEventGeneratorImplementation
        {
        public:
			float masterVolume = 1.0f;
			float soundsVolume = 1.0f;
			float musicVolume = 1.0f;
			float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };

			virtual ~GAudioImplementation()
			{
				// Broadcast DESTROY here
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::DESTROY, nullptr_t());
				this->Push(gEvent);
			}

            // Main class
            GReturn Create()
            {	
				// check for available hardware
				pa_threaded_mainloop* myMainLoop = pa_threaded_mainloop_new();
				if (myMainLoop == NULL)
					return GReturn::HARDWARE_UNAVAILABLE;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_context* myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "AudioHardware");
					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						pa_threaded_mainloop_free(myMainLoop);
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					if (pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL) < 0)
					{
						pa_context_unref(myContext);
						pa_threaded_mainloop_unlock(myMainLoop);
						pa_threaded_mainloop_free(myMainLoop);
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					
					pa_context_disconnect(myContext);
					pa_context_unref(myContext);
				}
				pa_threaded_mainloop_unlock(myMainLoop);				
				pa_threaded_mainloop_free(myMainLoop);
				
				// Initalize GAudio's volumes
				masterVolume = 1.0f;
				soundsVolume = 1.0f;
				musicVolume = 1.0f;

				return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - masterVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				masterVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = masterVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetGlobalSoundVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - soundsVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				soundsVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = soundsVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

			GReturn SetGlobalMusicVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - musicVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				musicVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = musicVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
			}

			// Sound Events
			GReturn PlaySounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn PauseSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());
				
                return this->Push(gEvent);
            }
			GReturn ResumeSounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn StopSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

				return this->Push(gEvent);
            }

			// Music Events
			GReturn PlayMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn PauseMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn ResumeMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn StopMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
        };
    }// end I
}// end GW

#elif defined(_WIN32)
    #if _MSC_VER >= 1700
	#pragma comment(lib, "xaudio2.lib")
#endif

#include <xaudio2.h>
#include <xaudio2fx.h>
#include <atomic>
#include <math.h>

namespace GW
{
    namespace I
    {
        class GAudioImplementation :	public virtual GAudioInterface,
										public GEventGeneratorImplementation
        {
			struct PlatformAudio
			{
				IXAudio2* myAudio = nullptr;
				IXAudio2MasteringVoice* theMasterVoice = nullptr;
			};
        public:
			float masterVolume = 1.0f;
			float soundsVolume = 1.0f;
			float musicVolume = 1.0f;
			float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			PlatformAudio XAudioData;

			virtual ~GAudioImplementation()
			{
				// Broadcast DESTROY here
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::DESTROY, nullptr_t());
				this->Push(gEvent);

				if (XAudioData.theMasterVoice)
					XAudioData.theMasterVoice->DestroyVoice();

				if (XAudioData.myAudio)
				{
					XAudioData.myAudio->StopEngine();
					XAudioData.myAudio->Release();
				}
			}

            // Main class
            GReturn Create()
            {
				if (XAudioData.myAudio != nullptr)
					return GReturn::FAILURE;

				HRESULT theResult = CoInitialize(NULL);
				if (FAILED(theResult = XAudio2Create(&XAudioData.myAudio)))
					return GReturn::HARDWARE_UNAVAILABLE;

				if (FAILED(theResult = XAudioData.myAudio->CreateMasteringVoice(&XAudioData.theMasterVoice)))
					return GReturn::HARDWARE_UNAVAILABLE;

				// Initalize GAudio's volumes
				masterVolume = 1.0f;
				soundsVolume = 1.0f;
				musicVolume = 1.0f;

				return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - masterVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				masterVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = masterVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetGlobalSoundVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - soundsVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				soundsVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = soundsVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

			GReturn SetGlobalMusicVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - musicVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				musicVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = musicVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
			}

			// Sound Events
			GReturn PlaySounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn PauseSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());
				
                return this->Push(gEvent);
            }
			GReturn ResumeSounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn StopSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

				return this->Push(gEvent);
            }

			// Music Events
			GReturn PlayMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn PauseMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn ResumeMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn StopMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
        };
    }// end I
}// end GW

#endif


namespace GW
{
	namespace AUDIO
	{
		class GAudio final 
			: public I::GProxy<I::GAudioInterface, I::GAudioImplementation>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			GATEWARE_PROXY_CLASS(GAudio)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(SetMasterVolume)
			GATEWARE_FUNCTION(SetGlobalSoundVolume)
			GATEWARE_FUNCTION(SetGlobalMusicVolume)
			GATEWARE_FUNCTION(SetSoundsChannelVolumes)
			GATEWARE_FUNCTION(SetMusicChannelVolumes)
			GATEWARE_FUNCTION(PlaySounds)
			GATEWARE_FUNCTION(PauseSounds)
			GATEWARE_FUNCTION(ResumeSounds)
			GATEWARE_FUNCTION(StopSounds)
			GATEWARE_FUNCTION(PlayMusic)
			GATEWARE_FUNCTION(PauseMusic)
			GATEWARE_FUNCTION(ResumeMusic)
			GATEWARE_FUNCTION(StopMusic)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		}; 
	}
}

#endif // GAUDIO_H

/*---------------------------------
|	End of GAudio.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudio3D.h
----------------------------------*/
#ifndef GAUDIO3D_H
#define GAUDIO3D_H







namespace GW
{
	namespace I
	{
		class GAudio3DInterface : public virtual GAudioInterface
		{
		public:
			enum class Events
			{
				UPDATE_LISTENER,
				UPDATE_TRANSFORM_AND_SPATIALIZE
			};

			struct EVENT_DATA
			{
				GW::MATH::GVECTORF position;
				GW::MATH::GQUATERNIONF quaternion;
			};

			virtual GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) = 0;
		};
	}
}

// Implementaion for GAudio3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GAUDIO3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GAUDIO3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GAudio3DImplementation :	public virtual GAudio3DInterface,
										public GAudioImplementation
		{
		public:
			GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GAudio3DImplementation :	public virtual GAudio3DInterface,
										public GAudioImplementation
		{
		public:
			CORE::GEventGenerator gEventGen;
			GReturn Create()
			{
				GReturn result = gEventGen.Create();
				if (result != GReturn::SUCCESS)
					return result;

				return GAudioImplementation::Create();
			}

			GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) override
			{
				MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
				MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
				MATH::GQUATERNIONF orientation;
				orientation.x = _orientation.x;
				orientation.y = _orientation.y;
				orientation.z = _orientation.z;
				orientation.w = _orientation.w;

				MATH::GMatrix::ConvertQuaternionF(orientation, listener);

				listener.row4.x = _position.x;
				listener.row4.y = _position.y;
				listener.row4.z = _position.z;
				listener.row4.w = 1.0f;

				if (MATH::GMatrix::InverseF(listener, transform) != GReturn::SUCCESS)
					return GReturn::FAILURE;
				
				GEvent gEvent;
				EVENT_DATA eventData;
				eventData.position = listener.row4;
				eventData.quaternion = _orientation;
				gEvent.Write(Events::UPDATE_LISTENER, eventData);
				gEventGen.Push(gEvent);

				eventData.position = transform.row4;
				MATH::GQuaternion::SetByMatrixF(transform, eventData.quaternion);
				gEvent.Write(Events::UPDATE_TRANSFORM_AND_SPATIALIZE, eventData);

				return gEventGen.Push(gEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace AUDIO
	{
		class GAudio3D final 
			: public I::GProxy<I::GAudio3DInterface, I::GAudio3DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GAudio3D)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Update3DListener)

			// reimplemented from base class
			GATEWARE_FUNCTION(SetMasterVolume)
			GATEWARE_FUNCTION(SetGlobalSoundVolume)
			GATEWARE_FUNCTION(SetGlobalMusicVolume)
			GATEWARE_FUNCTION(SetSoundsChannelVolumes)
			GATEWARE_FUNCTION(SetMusicChannelVolumes)
			GATEWARE_FUNCTION(PlaySounds)
			GATEWARE_FUNCTION(PauseSounds)
			GATEWARE_FUNCTION(ResumeSounds)
			GATEWARE_FUNCTION(StopSounds)
			GATEWARE_FUNCTION(PlayMusic)
			GATEWARE_FUNCTION(PauseMusic)
			GATEWARE_FUNCTION(ResumeMusic)
			GATEWARE_FUNCTION(StopMusic)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GAUDIO3D_H

/*---------------------------------
|	End of GAudio3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GSound.h
----------------------------------*/
#ifndef GSOUND_H
#define GSOUND_H






namespace GW
{
    namespace I
    {
        class GSoundInterface : public virtual GInterfaceInterface
        {
        public:
            virtual GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
            virtual GReturn SetVolume(float _newVolume) = 0;
            virtual GReturn Play() = 0;
            virtual GReturn Pause() = 0;
            virtual GReturn Resume() = 0;
            virtual GReturn Stop() = 0;
            virtual GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const = 0;
            virtual GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const = 0;
            virtual GReturn isPlaying(bool& _returnedBool) const = 0;
            //virtual GReturn SetPCMShader(const char* _data) = 0; // not implemented yet
        };
    }
}

// Implementaion for GSound.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GSOUND) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GSOUND) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface
        {
        public:
            // Main class
            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _value)
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetVolume(float _newVolume) override
            {
                return GReturn::FAILURE;
            }
            GReturn Play() override
            {
                return GReturn::FAILURE;
            }
            GReturn Pause() override
            {
                return GReturn::FAILURE;
            }
            GReturn Resume() override
            {
                return GReturn::FAILURE;
            }
            GReturn Stop() override
            {
                return GReturn::FAILURE;
            }
            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn isPlaying(bool& _returnedBool) const override
            {
                return GReturn::FAILURE;
            }
            //// ThreadShared
            //GReturn LockAsyncRead() const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn UnlockAsyncRead() const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn LockSyncWrite() override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn UnlockSyncWrite() override
            //{
            //    return GReturn::FAILURE;
            //}
            //// Events
            //GReturn Append(const GEvent& _inEvent) override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Waiting(unsigned int& _outCount) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Pop(GEvent& _outEvent) override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Peek(GEvent& _outEvent) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Missed(unsigned int& _outCount) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Clear() override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Invoke() const override
            //{
            //    return GReturn::FAILURE;
            //}
        };
    }
}

#elif defined(__APPLE__)
    #define G_NUM_OF_OUTPUTS 6

namespace GW
{
    namespace I
    {
        class GSoundImplementation;
    }
}

namespace internal_gw
{
    class GMacSound
    {
    public:
        GW::I::GSoundImplementation* gSound;
        GMacAudio* audio;

        AVAudioPlayerNode* player;
        AVAudioUnit* matrixMixerNode;

        AVAudioFile* file;
        AVAudioPCMBuffer* buffer;

        std::atomic<bool> isPlaying;
        std::atomic<bool> isPaused;

        GMacSound* initWithPath(NSString* _path)
        {
            NSError* testError;
            // setting up player
            player = [[AVAudioPlayerNode alloc]init];
            [audio->engine attachNode : player] ;

            // setting up buffer
            NSURL* filePath = [[NSURL alloc]initFileURLWithPath:_path];
            file = [[AVAudioFile alloc]initForReading:filePath commonFormat : AVAudioPCMFormatFloat32 interleaved : false error : &testError];
            [filePath release] ;
            buffer = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[file processingFormat] frameCapacity : [file length] ];
            bool success = [file readIntoBuffer : buffer error : &testError];
            if (!success)
                NSCAssert(success, @"could not read file into buffer", [testError localizedDescription]);

                    AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            matrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                matrixMixerNode = mixerUnit;
                [audio->engine attachNode : matrixMixerNode] ;
            }] ;

            while (!matrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));

            // Set the mixer's input format to have the correct number of channels
            UInt32 size;
            AudioStreamBasicDescription mixerFormatIn;
            AudioUnitGetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);

            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            AudioUnitGetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);

            AVAudioFormat* audioFormat;
            if (buffer.format.channelCount == 1) // for mono sounds
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : buffer.format.sampleRate channels : 1 interleaved : false];
            // Attempt to use more than 2 channels instead of default format
            else
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : buffer.format.sampleRate channels : G_NUM_OF_OUTPUTS interleaved : false];

            [audio->engine connect : player to : audio->engine.mainMixerNode format : audioFormat] ;
            [audioFormat release] ;

            isPlaying = false;
            isPaused = false;

            return this;
        }

        unsigned int GetChannels()
        {
            if (!player)
                return 0;
            return[file processingFormat].channelCount;
        }

        bool SetChannelVolumes(float* _volumes, unsigned int _numChannels)
        {
            if (!player)
                return false;

            if (_numChannels > 1)
            {
                float newVal = 0.0f;
                float sumChannels = 0.0f;
                for (int i = 0; i < _numChannels; i++)
                {
                    // total of all channels
                    sumChannels += _volumes[i];
                    // channels 0 and 4 are left channels which have pan of -1
                    if (i == 0 || i == 4)
                        newVal += _volumes[i] * -1.0f;
                    // skip 2 and 3, since center channels have pan of 0
                    else if (i == 1 || i == 5)
                        newVal += _volumes[i];
                }

                // obtain average and set the panning (sum has to be greater than 1 to apply clamping)
                player.pan = (sumChannels > 1.0f) ? (newVal / sumChannels) : newVal;
            }
            else
            {
                player.pan = -1 * _volumes[0];
            }

            return true;
        }

        bool SetVolume(float _newVolume)
        {
            if (!player)
                return false;

            [player setVolume : (_newVolume)] ;
            float check = [player volume];

            if (check == _newVolume)
                return true;

            return false;
        }

        bool Play()
        {
            if (!player)
                return false;

            [player play] ;
            [player scheduleBuffer : buffer atTime : nil options : AVAudioPlayerNodeBufferInterrupts completionHandler :
            ^ {
                isPlaying = false;
                isPaused = false;
            }] ;

            isPlaying = true;
            isPaused = false;

            return[player isPlaying];
        }

        bool Pause()
        {
            if (!player)
                return false;

            [player pause] ;
            isPlaying = false;
            isPaused = true;

            return ![player isPlaying];
        }

        bool Resume()
        {
            if (!player)
                return false;

            [player playAtTime : nil] ;
            isPlaying = true;
            isPaused = false;

            return[player isPlaying];
        }

        bool Stop()
        {
            if (!player)
                return false;

            [player stop] ;
            isPlaying = false;
            isPaused = false;

            return ![player isPlaying];
        }

        bool Unload()
        {
            bool macresult = false;
            if (player != nil)
            {
                [player stop] ;
                [player release] ;
                player = nil;
                macresult = true;
            }

            // Cleans up memory in the autorelease pool
            if (file != nil)
            {
                [file release] ;
                file = nil;
            }

            if (buffer != nil)
            {
                [buffer release] ;
                buffer = nil;
            }

            return macresult;
        }
    };
}

namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface,
            protected GThreadSharedImplementation
        {
            float masterVolume = 1.0f; // global master volume
            float globalSoundsVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            internal_gw::GMacSound* mac_snd = nullptr;
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;

            void Destroy()
            {
                LockSyncWrite();
                if (mac_snd)
                {
                    mac_snd->Unload();
                    delete mac_snd;
                    mac_snd = nullptr;
                }
                UnlockSyncWrite();
            }
        public:
            virtual ~GSoundImplementation()
            {
                // Objective C cleanup
                Destroy();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                mac_snd = new internal_gw::GMacSound();
                mac_snd->gSound = this;
                mac_snd->audio = audioImplementation->mac_audio;
                NSString* nsPath = [[[NSString alloc]initWithUTF8String:_path] autorelease];
                mac_snd->initWithPath(nsPath);

                globalSoundsVolume = audioImplementation->soundsVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

                GReturn result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = SetChannelVolumes(channelVolumes, 6);
                if (result != GReturn::SUCCESS)
                    return result;

                result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                    case GW::AUDIO::GAudio::Events::DESTROY:
                    {
                        //printf("DESTROY RECEIVED IN SOUND\n");
                        // If GAudio is destroyed, the sound is no longer operational
                        Destroy();
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
                    {
                        Play();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND PLAY %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
                    {
                        Pause();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND PAUSE %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
                    {
                        Resume();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND RESUME %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
                    {
                        Stop();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND STOP: %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        masterVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalSoundsVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        globalSoundsVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("GLOBAL SOUND VOLUME: %f | VOLUME: %f\n", globalSoundsVolume, volume * globalSoundsVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                        SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                        //printf("SOUND CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
                        break;
                    }
                    default:
                    {
                        break;
                    }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float resultChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // apply clamping
                    channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
                    // apply master channel volumes
                    resultChannelVolumes[i] = channelVolumes[i] * masterChannelVolumes[i];
                }

                if (!mac_snd->player)
                    return GReturn::FAILURE;

                LockSyncWrite();
                bool result = mac_snd->SetChannelVolumes(resultChannelVolumes, _numChannels);
                UnlockSyncWrite();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

                if (!mac_snd->player)
                    return GReturn::FAILURE;

                // Apply master volume ratios to the sound volume (Doesn't need to be normalized, since result is always < 1.0f)
                LockSyncWrite();
                bool result = mac_snd->SetVolume(volume * globalSoundsVolume * masterVolume);
                UnlockSyncWrite();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Play() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Play();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Pause();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Resume();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Stop() override
            {
                bool result = mac_snd->Stop();

                // Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = mac_snd->GetChannels();
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS;
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = mac_snd->isPlaying;
                return GReturn::SUCCESS;
            }

            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(__linux__)
    #include <pulse/mainloop.h>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/channelmap.h>
#include <pulse/context.h>
#include <pulse/volume.h>
#include <pulse/stream.h>
#include <pulse/error.h>
#include <pulse/scache.h>
#include <pulse/introspect.h>
#include <pulse/subscribe.h>

#include <thread>

#define G_NUM_OF_OUTPUTS 2 // Currently set to forced Stereo



namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface,
            protected GThreadSharedImplementation
        {
			/* this enum is here to prevent compiler warning -Wmultichar
			 * previously, this file used a series of #defines that caused
			 * the warning to occur in a switch statement later on. So instead
			 * of the #defines (initiallizing an int to a series of 4 chars), 
			 * i just declare them here to be the integer they would be 
			 * interpreted as by the compiler internally. */
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};
			
            struct PCM_FORMAT_INFO
            {
                unsigned short mFormatTag = 0;
                unsigned short mNumChannels = 0;
                unsigned int mSamples = 0;
                unsigned int mAvgBytesPerSec = 0;
                unsigned short mBlockAlign = 0;
                unsigned short mBitsPerSample = 0;
                unsigned short mCbSize = 22;
            };

            struct PCM_BUFFER
            {
                uint32_t byteSize = 0;
                uint8_t* bytes = nullptr;
            };

            struct WAVE_FILE
            {
                PCM_FORMAT_INFO myFormat;
                PCM_BUFFER myBuffer;
                bool isSigned = false;
            };

            std::atomic<int> pa_ready;
            std::atomic_bool atomic_isPlaying;
            std::atomic_bool atomic_isPaused;
            std::atomic_bool atomic_isComplete;
            std::atomic_bool atomic_stopFlag;
            float masterVolume = 1.0f; // global master volume
            float globalSoundsVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound
            uint32_t sinkIndex = UINT32_MAX;
            pa_context* myContext = nullptr;
            pa_channel_map* myMap = nullptr;
            pa_stream* myStream = nullptr;
            pa_threaded_mainloop* myMainLoop = nullptr;

            pa_sample_format myPulseFormat;
            pa_cvolume vol;

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;
            GW::SYSTEM::GConcurrent gConcurrent;
            WAVE_FILE myFile;

            void Destroy()
            {
                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				 {
					// Disconnects and decrements/unreferences the stream
					if (myStream)
					{
						pa_stream_disconnect(myStream);
						pa_stream_unref(myStream);
						myStream = nullptr;
					}

					// Disconnects and decrements/unreferences the context
					if (myContext)
					{
						pa_context_kill_sink_input(myContext, sinkIndex, NULL, NULL);
						pa_context_disconnect(myContext);
						pa_context_unref(myContext);
						myContext = nullptr;
					}
				}
                if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                // Stops the mainloop (after the context is disconnected) and releases memory
                if (myMainLoop)
                {
                    pa_threaded_mainloop_stop(myMainLoop);
                    pa_threaded_mainloop_free(myMainLoop);
                    myMainLoop = nullptr;
                }

                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				{
					if (myMap)
					{
						delete myMap;
						myMap = nullptr;
					}
				}
                if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                if (myFile.myBuffer.bytes)
                {
                    delete[] myFile.myBuffer.bytes;
                    myFile.myBuffer.bytes = nullptr;
                }
            }

            GReturn LoadWav(const char* path, WAVE_FILE& returnedWave)
            {
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
                unsigned long dwChunktype = 0;
                unsigned long dwChunkDataSize = 0;
                unsigned long dwRiffDataSize = 0;
                unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
                unsigned long throwAwayValue = 0;
				bool foundAudioData = false;
                
                while (result == GReturn::SUCCESS && foundAudioData == false)
                {
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

                    switch (dwChunktype) {
                        case WaveTag::RIFF:
                        {
                            dwRiffDataSize = dwChunkDataSize;
                            dwChunkDataSize = 4;

                            if (-file.Read(reinterpret_cast<char*>(&dwFileType), dwChunkDataSize)) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::WAVE:
                        {

                            if (-file.Read(reinterpret_cast<char*>(&dwIsWave), dwChunkDataSize)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::FMT:
                        {
                            if (-file.Read(reinterpret_cast<char*>(&returnedWave.myFormat.mFormatTag), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::DATA:
                        {
							returnedWave.myBuffer.bytes = new uint8_t[dwChunkDataSize];
							if (-file.Read(reinterpret_cast<char*>(returnedWave.myBuffer.bytes), dwChunkDataSize)) {
								// could not read the audio data
								result = GReturn::FAILURE;
								break;
							}

							returnedWave.myBuffer.byteSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							foundAudioData = true;
							break;
                        }
						
                        default:
                        {
                            char* pThrowawayDataBuffer = new char[dwChunkDataSize];
							if (-file.Read(pThrowawayDataBuffer, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}

							delete[] pThrowawayDataBuffer;
							break;
                        }
                    }
                }
                file.CloseFile();
				returnedWave.isSigned = (returnedWave.myFormat.mBitsPerSample != 8);
				return result;
            }

            static void OnStateChange(pa_context* c, void* userdata)
            {
                std::atomic<int>* pa_ready = (std::atomic<int>*)userdata;

                switch (pa_context_get_state(c))
                {
                    case PA_CONTEXT_UNCONNECTED:
                    {
                        break;
                    }
                    case PA_CONTEXT_CONNECTING:
                    {
                        break;
                    }
                    case PA_CONTEXT_AUTHORIZING:
                    {
                        break;
                    }
                    case PA_CONTEXT_SETTING_NAME:
                    {
                        break;
                    }
                    case PA_CONTEXT_FAILED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_TERMINATED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_READY:
                    {
                        * pa_ready = 1;
                        break;
                    }
                }
            }

            static void FinishedDrainOp(pa_stream* s, int success, void* userdata)
            {
                GSoundImplementation* impl = reinterpret_cast<GSoundImplementation*>(userdata);
                impl->atomic_isComplete = true;
            }

        public:
            virtual ~GSoundImplementation()
            {
                Stop();
                LockSyncWrite();
                Destroy();
                UnlockSyncWrite();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                GReturn result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                if (-LoadWav(_path, myFile))
                    return GReturn::FILE_NOT_FOUND;

                myMainLoop = pa_threaded_mainloop_new();

                if (myMainLoop == NULL)
                    return GReturn::FAILURE;

				pa_threaded_mainloop_lock(myMainLoop);
				{
					myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "Sound");

					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);					
						return GReturn::FAILURE;
					}

					pa_ready = 0;
					pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL);
					pa_context_set_state_callback(myContext, OnStateChange, &pa_ready);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                pa_threaded_mainloop_start(myMainLoop);

                while (pa_ready == 0)
                    std::this_thread::yield();
                
                if (pa_ready != 1)
                    return GReturn::FAILURE;

				switch (myFile.myFormat.mBitsPerSample)
				{
					case 8:
						myPulseFormat = PA_SAMPLE_U8;
						break;
					case 16:
						myPulseFormat = PA_SAMPLE_S16LE;
						break;
					case 24:
						myPulseFormat = PA_SAMPLE_S24LE;
						break;
					case 32:
						myPulseFormat = (myFile.myFormat.mFormatTag > 1) ? PA_SAMPLE_FLOAT32LE : PA_SAMPLE_S32LE; // Float type for IEEE and Signed 32int for PCM
						break;
					default:
						myPulseFormat = PA_SAMPLE_INVALID;
						return GReturn::FAILURE;
						break;
				}

				pa_sample_spec mySampleSpec;
				mySampleSpec.format = myPulseFormat;
				mySampleSpec.rate = myFile.myFormat.mSamples;
				mySampleSpec.channels = myFile.myFormat.mNumChannels;
			
				if (pa_channels_valid(mySampleSpec.channels) == 0)
					return GReturn::FAILURE;
				
				pa_threaded_mainloop_lock(myMainLoop);
				{
					myMap = new pa_channel_map();
					myMap = pa_channel_map_init_extend(myMap, mySampleSpec.channels, PA_CHANNEL_MAP_WAVEEX);
					if (myMap == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);						
						return GReturn::FAILURE;
					}
					
					myStream = pa_stream_new(myContext, "GSound", &mySampleSpec, myMap);
					if (myStream == nullptr)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					if (pa_stream_connect_playback(myStream, NULL, NULL, (pa_stream_flags_t)0, NULL, NULL) != 0)
					{
						pa_threaded_mainloop_unlock(myMainLoop);						
						return GReturn::FAILURE;
					}
				}
				pa_threaded_mainloop_unlock(myMainLoop);
				
                globalSoundsVolume = audioImplementation->soundsVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

				pa_cvolume_init(&vol);
				
                result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                        case GW::AUDIO::GAudio::Events::DESTROY:
                        {
                            Stop();
                            LockSyncWrite();
                            Destroy();
                            UnlockSyncWrite();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
                        {
                            Play();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
                        {
                            Pause();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
                        {
                            Resume();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
                        {
                            Stop();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            masterVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            globalSoundsVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                            SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float adjustedVolume = volume * masterVolume * globalSoundsVolume;
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // 5.1 to stereo fallback
                    if (_numChannels > G_NUM_OF_OUTPUTS)
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        switch (i)
                        {
                            case 2: // Front Center
                            {
                                channelVolumes[0] += channelVolumes[2] * 0.5f;
                                channelVolumes[1] += channelVolumes[2] * 0.5f;
                                break;
                            }
                            case 3: // LFE
                            {
                                channelVolumes[0] += channelVolumes[3] * 0.3f;
                                channelVolumes[1] += channelVolumes[3] * 0.3f;
                                break;
                            }
                            case 4: // Rear Left
                            {
                                channelVolumes[0] += channelVolumes[4] * 0.7f;
                                break;
                            }
                            case 5: //Rear Right
                            {
                                channelVolumes[1] += channelVolumes[5] * 0.7f;
                                break;
                            }
                        }

                        // clamp stereo to max of 1.0f
                        if (i == _numChannels - 1)
                        {
                            channelVolumes[0] = (channelVolumes[0] > 1.0f) ? 1.0f : channelVolumes[0];
                            channelVolumes[1] = (channelVolumes[1] > 1.0f) ? 1.0f : channelVolumes[1];
							vol.values[0] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[0] * masterChannelVolumes[0]);
							vol.values[1] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[1] * masterChannelVolumes[1]);	
                            break;
                        }
                    }
                    else
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        // apply clamping and master volume multiplier
						vol.values[i] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[i] * masterChannelVolumes[i]);
                    }
                }

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();

				vol.channels = G_NUM_OF_OUTPUTS;
                
				//Set the volume of a sink input stream.
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                _newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
                volume = _newVolume;

                // Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
                _newVolume *= masterVolume * globalSoundsVolume;				
				vol.channels = G_NUM_OF_OUTPUTS;
				for (int i = 0; i < vol.channels; ++i)
					vol.values[i] = pa_sw_volume_from_linear(_newVolume * channelVolumes[i] * masterChannelVolumes[i]);

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();
                
				pa_threaded_mainloop_lock(myMainLoop);
				{					
					//Set the volume of a sink input stream.
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{
						pa_threaded_mainloop_unlock(myMainLoop);					
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn Play() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPlaying || atomic_isComplete)
                {
                    GReturn result = Stop();

                    if (result != GReturn::SUCCESS)
                        return result;
                }

                if (atomic_isPlaying == false)
                {
                    atomic_stopFlag = false;
                    atomic_isPaused = false;
                    atomic_isPlaying = true;
                    gConcurrent.BranchSingular([&]()
                    {
                        unsigned int playBackPt = 0;
                        pa_stream_state_t state;
                        while (true)
                        {
                            if (atomic_stopFlag == true)
                            {
								pa_threaded_mainloop_lock(myMainLoop);
									pa_stream_cancel_write(myStream);
								pa_threaded_mainloop_unlock(myMainLoop);
                                break;
                            }
                            else if (atomic_isPlaying == true)
                            {
                                pa_threaded_mainloop_lock(myMainLoop);
									state = pa_stream_get_state(myStream); // synchronous call, requires locking
                                pa_threaded_mainloop_unlock(myMainLoop);

                                if (state == PA_STREAM_READY)
                                {
									pa_threaded_mainloop_lock(myMainLoop);
										const size_t writeableSize = pa_stream_writable_size(myStream);
									pa_threaded_mainloop_unlock(myMainLoop);
									
                                    const size_t sizeRemain = myFile.myBuffer.byteSize - playBackPt;
                                    const size_t writeSize = (sizeRemain < writeableSize ? sizeRemain : writeableSize);

                                    if (writeSize > 0)
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
											pa_stream_write(myStream, myFile.myBuffer.bytes + playBackPt, writeSize, nullptr, 0, PA_SEEK_RELATIVE);
										pa_threaded_mainloop_unlock(myMainLoop);
										
                                        playBackPt += writeSize;
                                    }
                                    else if (writeableSize > 0 && atomic_isComplete == false)
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
										{											
											pa_operation* o = pa_stream_drain(myStream, FinishedDrainOp, this);

											if (o)
												pa_operation_unref(o);
										}
										pa_threaded_mainloop_unlock(myMainLoop);
                                        break;
                                    }
                                }
                            }
                        }
                    });
                }

                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPaused == false)
                {
                    pa_threaded_mainloop_lock(myMainLoop);
						int value = pa_stream_is_corked(myStream); // 1 = paused, 0 = resumed
                    pa_threaded_mainloop_unlock(myMainLoop);

                    if (value == 0) // if not paused
                    {
						pa_threaded_mainloop_lock(myMainLoop);
						{
							pa_operation* o = pa_stream_cork(myStream, 1, [](pa_stream*, int, void*) {}, NULL);

							if (!o)
							{
								pa_threaded_mainloop_unlock(myMainLoop);
								return GReturn::FAILURE;
							}

							pa_operation_unref(o);
						}
						pa_threaded_mainloop_unlock(myMainLoop);
                    }

                    atomic_isPaused = true;
                    atomic_isPlaying = false;
                }

                return GReturn::SUCCESS;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPaused == true)
                {
                    pa_threaded_mainloop_lock(myMainLoop);
						int value = pa_stream_is_corked(myStream); // 1 = paused, 0 = resumed
                    pa_threaded_mainloop_unlock(myMainLoop);

                    if (value == 1) // if paused
                    {
                        pa_threaded_mainloop_lock(myMainLoop);
						{
							pa_operation* o = pa_stream_cork(myStream, 0, [](pa_stream*, int, void*) {}, NULL);

							if (!o)
							{
								pa_threaded_mainloop_unlock(myMainLoop);
								return GReturn::FAILURE;
							}

							pa_operation_unref(o);							
						}
                        pa_threaded_mainloop_unlock(myMainLoop);
                    }

                    atomic_isPlaying = true;
                    atomic_isPaused = false;
                }
                else
                    return GReturn::REDUNDANT;

                return GReturn::SUCCESS;
            }

            GReturn Stop() override
            {
                atomic_isPlaying = false;
                atomic_isPaused = false;
                atomic_isComplete = false;
                atomic_stopFlag = true;

                gConcurrent.Converge(0);

                // Converge has to run before return
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return GReturn::SUCCESS;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = myFile.myFormat.mNumChannels;
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS; // forced Stereo
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = atomic_isPlaying;
                return GReturn::SUCCESS;
            }

        protected:
            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(_WIN32)
    #define G_NUM_OF_OUTPUTS 6

namespace GW
{
	namespace I
	{
		class GSoundImplementation : public virtual GSoundInterface,
			protected GThreadSharedImplementation,
			protected IXAudio2VoiceCallback
		{
			// This enum exists for parity with Linux. See GMusic_Linux.hpp for more info
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT = 544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};

			GReturn LoadWaveData(const char* path, WAVEFORMATEXTENSIBLE& myWFX, XAUDIO2_BUFFER& _myAudioBuffer)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				// variables for determinning data information
				unsigned long dwChunktype = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long dwRiffDataSize = 0;
				unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), 4) || dwFileType != WaveTag::WAVE) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), 4)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&myWFX), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::DATA:
						{
							BYTE* pDataBuffer = new BYTE[dwChunkDataSize];
							if (-file.Read(reinterpret_cast<char*>(pDataBuffer), dwChunkDataSize)) {
								// could not read the audio data
								result = GReturn::FAILURE;
								delete[] pDataBuffer;
								break;
							}

							_myAudioBuffer.AudioBytes = dwChunkDataSize;	// contains size of the audio buffer in bytes
							_myAudioBuffer.pAudioData = pDataBuffer;		// this buffer contains all audio data
							_myAudioBuffer.Flags = XAUDIO2_END_OF_STREAM;	// tells source this is EOF and should stop
							foundAudioData = true;
							break;
						}

						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
								delete[] pBogusData;
								break;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}

			void STDMETHODCALLTYPE OnStreamEnd()
			{
				// When stream ends, the sound gets flagged as complete
				atomic_isComplete = true;
				atomic_isPaused = false;
				atomic_isPlaying = false;
				SetEvent(hStreamEndEvent);
			}
			// Required studs as IXAudio2VoiceCallback is an abstract class
			void STDMETHODCALLTYPE OnBufferEnd(void*) {}
			void STDMETHODCALLTYPE OnBufferStart(void*) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}
			void STDMETHODCALLTYPE OnVoiceError(void*, HRESULT) {}
			void STDMETHODCALLTYPE OnLoopEnd(void*) {}

			std::atomic_bool atomic_isPlaying = false;
			std::atomic_bool atomic_isPaused = false;
			std::atomic_bool atomic_isComplete = false;
			float masterVolume = 1.0f; // global master volume
			float globalSoundsVolume = 1.0f; // global sounds volume
			float volume = 1.0f; // volume of this sound
			unsigned int numOfChannels = 0;

			IXAudio2SourceVoice* mySourceVoice = nullptr;
			IXAudio2SubmixVoice* mySubmixVoice = nullptr;
			HANDLE hStreamEndEvent;

			float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
			float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
			GW::AUDIO::GAudio gAudio;
			GW::CORE::GEventReceiver gReceiver;
			XAUDIO2_BUFFER myAudioBuffer = { 0 };

		public:
			virtual ~GSoundImplementation()
			{
				Stop();

				// We do not need to check for GAudio proxy here, since those handles would get cleaned up 
				// in the event callback if GAudio gets deleted first
				LockSyncWrite();
				if (mySourceVoice)
					mySourceVoice->DestroyVoice();

				if (mySubmixVoice)
					mySubmixVoice->DestroyVoice();
				UnlockSyncWrite();

				if (myAudioBuffer.pAudioData)
					delete[] myAudioBuffer.pAudioData;

				if (hStreamEndEvent)
					CloseHandle(hStreamEndEvent);
			}

			GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
			{
				if (!_path || !_audio)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				hStreamEndEvent = CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE);
				if (!hStreamEndEvent)
					return GReturn::FAILURE;

				WAVEFORMATEXTENSIBLE wfmx;
				if (-LoadWaveData(_path, wfmx, myAudioBuffer))
					return GReturn::FAILURE;

				//if (wfmx.Format.nChannels > maxChannels)
				//    maxChannels = wfmx.Format.nChannels;

				gAudio = _audio;
				auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

				if (audioImplementation->XAudioData.myAudio->CreateSubmixVoice(&mySubmixVoice, G_NUM_OF_OUTPUTS, wfmx.Format.nSamplesPerSec) != S_OK)
					return GReturn::FAILURE;

				XAUDIO2_SEND_DESCRIPTOR sndSendDcsp = { 0, mySubmixVoice };
				XAUDIO2_VOICE_SENDS sndSendList = { 1, &sndSendDcsp };

				// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. (for non-PCM formats)
				wfmx.Format.cbSize = (wfmx.Format.wFormatTag > 1) ? 22 : 0;
				numOfChannels = static_cast<unsigned int>(wfmx.Format.nChannels);
				if (audioImplementation->XAudioData.myAudio->CreateSourceVoice(&mySourceVoice, &wfmx.Format, 0, XAUDIO2_DEFAULT_FREQ_RATIO, this, &sndSendList) != S_OK)
					return GReturn::FAILURE;

				if (FAILED(mySourceVoice->SubmitSourceBuffer(&myAudioBuffer)))
					return GReturn::FAILURE;

				globalSoundsVolume = audioImplementation->soundsVolume;
				masterVolume = audioImplementation->masterVolume;
				memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

				GReturn result = SetVolume(_volume);
				if (result != GReturn::SUCCESS)
					return result;

				result = SetChannelVolumes(channelVolumes, 6);
				if (result != GReturn::SUCCESS)
					return result;

				result = GThreadSharedImplementation::Create();
				if (result != GReturn::SUCCESS)
					return result;

				return gReceiver.Create(_audio, [&]()
				{
					GW::GEvent gEvent;
					GW::AUDIO::GAudio::Events audioEvent;
					GW::AUDIO::GAudio::EVENT_DATA audioEventData;
					// Process the event message
					gReceiver.Pop(gEvent);
					gEvent.Read(audioEvent);

					switch (audioEvent)
					{
						case GW::AUDIO::GAudio::Events::DESTROY:
						{
							//printf("DESTROY RECEIVED IN SOUND\n");
							Stop();
							// Need to cleanup XAudio handles before GAudio is deleted
							LockSyncWrite();
							if (mySourceVoice)
							{
								mySourceVoice->DestroyVoice();
								mySourceVoice = nullptr;
							}

							if (mySubmixVoice)
							{
								mySubmixVoice->DestroyVoice();
								mySubmixVoice = nullptr;
							}
							UnlockSyncWrite();
							break;
						}
						case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
						{
							Play();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND PLAY %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
						{
							Pause();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND PAUSE %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
						{
							Resume();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND RESUME %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
						{
							Stop();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND STOP: %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							masterVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalSoundsVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							globalSoundsVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("GLOBAL SOUND VOLUME: %f | VOLUME: %f\n", globalSoundsVolume, volume * globalSoundsVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
						{
							gEvent.Read(audioEventData);
							memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
							SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
							//printf("SOUND CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
							break;
						}
						default:
						{
							break;
						}
					}
				});
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < _numChannels; i++)
				{
					if (_values[i] < 0.0f)
						return GReturn::INVALID_ARGUMENT;

					// apply clamping and master volume multiplier
					channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
				}

				// can only support up to 6 outputs
				float matrix[12] = { 0 };
				unsigned int trueIndex = 0;
				for (unsigned int i = 0; i < 12;)
				{
					if (trueIndex < _numChannels)
					{
						float matrixVolume = channelVolumes[trueIndex] * masterChannelVolumes[trueIndex];
						matrix[i] = matrixVolume;
						matrix[i + 1] = matrixVolume;
						trueIndex++;
						i += 2;
					}
					else
					{
						matrix[i] = 0;
						i++;
					}
				}

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetOutputMatrix(mySubmixVoice, numOfChannels, G_NUM_OF_OUTPUTS, matrix)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				// Clip the passed volume to max
				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

				// Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetVolume(volume * globalSoundsVolume * masterVolume)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn Play() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPlaying || atomic_isComplete)
				{
					GReturn result = Stop();

					if (result != GReturn::SUCCESS)
						return result;
				}

				if (atomic_isPlaying == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}

				return GReturn::SUCCESS;
			}

			GReturn Pause() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = false;
					atomic_isPaused = true;
				}

				return GReturn::SUCCESS;
			}

			GReturn Resume() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == true)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}
				else
					return GReturn::REDUNDANT;

				return GReturn::SUCCESS;
			}

			GReturn Stop() override
			{
				atomic_isPlaying = false;
				atomic_isPaused = false;
				atomic_isComplete = false;

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				mySourceVoice->FlushSourceBuffers();
				if (FAILED(mySourceVoice->SubmitSourceBuffer(&myAudioBuffer)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				// Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				return GReturn::SUCCESS;
			}

			GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = numOfChannels;
				return GReturn::SUCCESS;
			}

			GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = G_NUM_OF_OUTPUTS;
				return GReturn::SUCCESS;
			}

			GReturn isPlaying(bool& _returnedBool) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				_returnedBool = atomic_isPlaying;
				return GReturn::SUCCESS;
			}

		protected:
			// ThreadShared
			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	}// end I
}// end GW

#undef G_RIFFcc
#undef G_DATAcc
#undef G_FMTcc 
#undef G_WAVEcc
//#undef G_JUNKcc
//#undef G_XWMAcc
//#undef G_DPDScc
#undef G_NUM_OF_OUTPUTS

#endif



namespace GW
{
    namespace AUDIO
    {
        class GSound final 
			: public I::GProxy<I::GSoundInterface, I::GSoundImplementation, const char*, GAudio, float>
        {
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback
			{
				init_callback()
				{
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<CORE::GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

            // All Gateware API interfaces contain no variables & are pure virtual.
        public:
			GATEWARE_PROXY_CLASS(GSound)
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)
           
            // This area does not contain actual code, it is only for the benefit of documentation generation.
        };
    }
}

#endif // GSOUND_H

/*---------------------------------
|	End of GSound.h
----------------------------------*/


/*---------------------------------
|	Begin of GMusic.h
----------------------------------*/
#ifndef GMUSIC_H
#define GMUSIC_H







namespace GW
{
    namespace I
    {
        class GMusicInterface : public virtual GInterfaceInterface
        {
        public:
			virtual GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn SetVolume(float _newVolume) = 0;
			virtual GReturn Play(bool _loop = false) = 0;
			virtual GReturn Pause() = 0;
			virtual GReturn Resume() = 0;
			virtual GReturn Stop() = 0;
			virtual GReturn GetSourceChannels(unsigned int& returnedChannelNum) const = 0;
			virtual GReturn GetOutputChannels(unsigned int& returnedChannelNum) const = 0;
			virtual GReturn isPlaying(bool& _returnedBool) const = 0;
            //virtual GReturn SetPCMShader(const char* _data) = 0; // not implemented yet
        };
    }
}

// Implementaion for GMusic.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GMUSIC) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GMUSIC) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface
        {
        public:
            // Main class
            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _value)
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetVolume(float _newVolume) override
            {
                return GReturn::FAILURE;
            }
            GReturn Play(bool _loop = false) override
            {
                return GReturn::FAILURE;
            }
            GReturn Pause() override
            {
                return GReturn::FAILURE;
            }
            GReturn Resume() override
            {
                return GReturn::FAILURE;
            }
            GReturn Stop() override
            {
                return GReturn::FAILURE;
            }
            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn isPlaying(bool& _returnedBool) const override
            {
                return GReturn::FAILURE;
            }
        };
    }
}

#elif defined(__APPLE__)
    #define G_NUM_OF_OUTPUTS 6
#define G_STREAMING_BUFFER_SIZE 63553
#define G_MAX_BUFFER_COUNT 3



namespace GW
{
    namespace I
    {
        class GMusicImplementation;
    }
}

namespace internal_gw
{
    // GMacMusic Interface

    // Data members of GMacMusic
    G_OBJC_DATA_MEMBERS_STRUCT(GMacMusic)
    {
        int currentBufferIndex;
        int index;

        std::atomic<int> buffersQueued;
        std::atomic<bool> stopFlag;
        std::atomic<bool> loops;
        std::atomic<bool> isPlaying;
        std::atomic<bool> isPaused;

        AVAudioFrameCount CurrentPosition;
        AVAudioFrameCount MaxPosition;

        GW::I::GMusicImplementation* gMusic;
        GMacAudio* audio;

        AVAudioPlayerNode* player;

        AVAudioUnit* matrixMixerNode;
        AVAudioFormat* audioFormat;

        AVAudioFile* file;
        AVAudioPCMBuffer* buffers[G_MAX_BUFFER_COUNT];
        NSThread* scheduler;
        NSCondition* bufferCondition;
    };

    // Forward declarations of GMacMusic methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GMacMusic);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, id, initWithPath, NSString* _path);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, unsigned int, GetChannels);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetChannelVolumes, float* _volumes, unsigned int _numChannels);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetVolume, float _newVolume);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, Play, bool _loops);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Pause);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Resume);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Stop);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, void, Stream);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Unload);

    // Creates the GMacMusic class at runtime when G_OBJC_GET_CLASS(GMacMusic) is called.
    G_OBJC_CLASS_BEGIN(GMacMusic, NSObject)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GMacMusic);

        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, initWithPath, "@@:@", :);
        G_OBJC_CLASS_METHOD(GMacMusic, GetChannels, "I@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, SetChannelVolumes, "B@:@I", ::);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, SetVolume, "B@:f", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, Play, "B@:B", :);
        G_OBJC_CLASS_METHOD(GMacMusic, Pause, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Resume, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Stop, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Stream, "v@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Unload, "B@:");
    }
    G_OBJC_CLASS_END(GMacMusic)

    // GMacMusic Interface End
}

namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface,
            protected GThreadSharedImplementation
        {
            float masterVolume = 1.0f; // global master volume
            float globalMusicVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            id mac_msc = nullptr;
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;

            void Destroy()
            {
                LockSyncWrite();
                if (mac_msc)
                {
                    internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Unload);
                    mac_msc = nullptr;
                }
                UnlockSyncWrite();
            }
        public:
            GW::SYSTEM::GConcurrent gConcurrent;
            virtual ~GMusicImplementation()
            {
                // Objective C cleanup
                Destroy();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                mac_msc = [internal_gw::G_OBJC_GET_CLASS(GMacMusic) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                mac_mscDataMembers.gMusic = this;
                mac_mscDataMembers.audio = audioImplementation->mac_audio;

                NSString* nsPath = [[[NSString alloc]initWithUTF8String:_path] autorelease];
                internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, initWithPath, nsPath);

                globalMusicVolume = audioImplementation->musicVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

                GReturn result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = SetChannelVolumes(channelVolumes, 6);
                if (result != GReturn::SUCCESS)
                    return result;

                result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                    case GW::AUDIO::GAudio::Events::DESTROY:
                    {
                        //printf("DESTROY RECEIVED IN MUSIC\n");
                        // If GAudio is destroyed, the sound is no longer operational
                        Destroy();
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
                    {
                        Play();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC PLAY %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
                    {
                        Pause();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC PAUSE %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
                    {
                        Resume();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC RESUME %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::STOP_MUSIC:
                    {
                        Stop();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC STOP: %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        masterVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalMusicVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        globalMusicVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("GLOBAL MUSIC VOLUME: %f | VOLUME: %f\n", globalMusicVolume, volume * globalMusicVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                        SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                        //printf("MUSIC CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
                        break;
                    }
                    default:
                    {
                        break;
                    }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float resultChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // apply clamping
                    channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
                    // apply master channel volumes
                    resultChannelVolumes[i] = channelVolumes[i] * masterChannelVolumes[i];
                }

                bool result = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, SetChannelVolumes, resultChannelVolumes, _numChannels);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

                // Apply master volume ratios to the music volume (Doesn't need to be normalized, since result is always < 1.0f)
                bool result = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, SetVolume, volume * globalMusicVolume * masterVolume);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Play(bool _loop = false) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                if (mac_mscDataMembers.isPlaying == true)
                {
                    if (-Stop())
                        return GReturn::FAILURE;
                }

                if (internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, Play, _loop) == false)
                    return GReturn::FAILURE;


                gConcurrent.BranchSingular([&]()
                {
                    if (mac_msc)
                        internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Stream);
                    else return;
                });

                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Pause);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Resume);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Stop() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Stop);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, GetChannels);
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS;
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                _returnedBool = mac_mscDataMembers.isPlaying;
                return GReturn::SUCCESS;
            }

            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

namespace internal_gw
{
    // GMacMusic Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GMacMusic);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, id, initWithPath, NSString* _path)
    {
        self = [self init];

        if (self)
        {
            G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);
            selfDataMembers.player = [[AVAudioPlayerNode alloc]init];
            [selfDataMembers.audio->engine attachNode : selfDataMembers.player] ;

            NSURL* filePath = [[NSURL alloc]initFileURLWithPath:_path];
            selfDataMembers.file = [[AVAudioFile alloc]initForReading:filePath commonFormat : AVAudioPCMFormatFloat32 interleaved : false error : nil];
            [filePath release] ;
            selfDataMembers.buffers[0] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];
            selfDataMembers.buffers[1] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];
            selfDataMembers.buffers[2] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];

            AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            selfDataMembers.matrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                selfDataMembers.matrixMixerNode = mixerUnit;
                [selfDataMembers.audio->engine attachNode : selfDataMembers.matrixMixerNode] ;
            }] ;

            while (!selfDataMembers.matrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));

            // Set the mixer's input format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatIn;
            UInt32 size;
            AudioUnitGetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);

            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            AudioUnitGetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);

            AVAudioFormat* audioFormat;
            if (selfDataMembers.buffers[0].format.channelCount == 1) // for mono sounds
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : selfDataMembers.buffers[0].format.sampleRate channels : 1 interleaved : false];
            // Attempt to use more than 2 channels instead of default format
            else
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : selfDataMembers.buffers[0].format.sampleRate channels : G_NUM_OF_OUTPUTS interleaved : false];

            [selfDataMembers.audio->engine connect : selfDataMembers.player to : selfDataMembers.audio->engine.mainMixerNode format : audioFormat] ;
            [audioFormat release] ;

            selfDataMembers.bufferCondition = [[NSCondition alloc]init];
            selfDataMembers.CurrentPosition = 0;
            selfDataMembers.MaxPosition = 0;
            selfDataMembers.currentBufferIndex = 0;
            selfDataMembers.index = 0;
            selfDataMembers.buffersQueued = 0;
            selfDataMembers.stopFlag = false;
            selfDataMembers.loops = false;
            selfDataMembers.isPlaying = false;
            selfDataMembers.isPaused = false;
            selfDataMembers.MaxPosition = selfDataMembers.file.length;
        }

        return self;
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, unsigned int, GetChannels)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return 0;

        return[selfDataMembers.file processingFormat].channelCount;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetChannelVolumes, float* _volumes, unsigned int _numChannels)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        if (_numChannels > 1)
        {
            float newVal = 0.0f;
            float sumChannels = 0.0f;
            for (int i = 0; i < _numChannels; i++)
            {
                // total of all channels
                sumChannels += _volumes[i];
                // channels 0 and 4 are left channels which have pan of -1
                if (i == 0 || i == 4)
                    newVal += _volumes[i] * -1.0f;
                // skip 2 and 3, since center channels have pan of 0
                else if (i == 1 || i == 5)
                    newVal += _volumes[i];
            }
            selfDataMembers.gMusic->LockSyncWrite();
            // obtain average and set the panning (sum has to be greater than 1 to apply clamping)
            selfDataMembers.player.pan = (sumChannels > 1.0f) ? (newVal / sumChannels) : newVal;
            selfDataMembers.gMusic->UnlockSyncWrite();
        }
        else
        {
            selfDataMembers.gMusic->LockSyncWrite();
            selfDataMembers.player.pan = -1 * _volumes[0];
            selfDataMembers.gMusic->UnlockSyncWrite();
        }

        return true;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetVolume, float _newVolume)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.gMusic->LockSyncWrite();
        [selfDataMembers.player setVolume : (_newVolume)] ;
        float check = [selfDataMembers.player volume];
        selfDataMembers.gMusic->UnlockSyncWrite();

        if (check == _newVolume)
            return true;

        return false;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, Play, bool _loops)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.loops = _loops;
        if (selfDataMembers.isPlaying == false)
        {
            selfDataMembers.CurrentPosition = 0;
            selfDataMembers.file.framePosition = 0;
            [selfDataMembers.player playAtTime : 0] ;
        }

        selfDataMembers.isPlaying = true;
        selfDataMembers.isPaused = false;
        selfDataMembers.stopFlag = false;

        return[selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Pause)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        [selfDataMembers.player pause] ;
        selfDataMembers.isPlaying = false;
        selfDataMembers.isPaused = true;

        return ![selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Resume)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        if (selfDataMembers.isPaused == true)
            [selfDataMembers.player play];

        selfDataMembers.isPlaying = true;
        selfDataMembers.isPaused = false;

        return[selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Stop)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.stopFlag = true;
        [selfDataMembers.player stop] ;
        [selfDataMembers.player prepareWithFrameCount : G_STREAMING_BUFFER_SIZE] ;
        // Reset to the start of the sample
        selfDataMembers.CurrentPosition = 0;
        selfDataMembers.buffersQueued = 0;

        selfDataMembers.isPlaying = false;
        selfDataMembers.isPaused = false;

        selfDataMembers.gMusic->gConcurrent.Converge(0);
        return ![selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, void, Stream)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        while (selfDataMembers.stopFlag == false)
        {
            NSError* testError = nil;
            AVAudioFrameCount valid = MIN(G_STREAMING_BUFFER_SIZE, selfDataMembers.MaxPosition - selfDataMembers.CurrentPosition > 0 ? selfDataMembers.MaxPosition - selfDataMembers.CurrentPosition : selfDataMembers.CurrentPosition);
            selfDataMembers.CurrentPosition += valid;

            AVAudioPCMBuffer* currentBuffer = selfDataMembers.buffers[selfDataMembers.currentBufferIndex];
            [selfDataMembers.file readIntoBuffer : currentBuffer frameCount : valid error : &testError] ;

            [selfDataMembers.bufferCondition lock] ;
            while (selfDataMembers.stopFlag == false && selfDataMembers.buffersQueued >= 2)
            {
                //sleep(1); // slows down the thread during waiting time
                [selfDataMembers.bufferCondition wait] ;
            }
            ++selfDataMembers.buffersQueued;
            [selfDataMembers.bufferCondition unlock] ;


            [selfDataMembers.player scheduleBuffer : currentBuffer completionHandler : ^ {
                [selfDataMembers.bufferCondition lock] ;
                --selfDataMembers.buffersQueued;
                if (selfDataMembers.stopFlag == true || selfDataMembers.buffersQueued < 2)
                    [selfDataMembers.bufferCondition signal];
                [selfDataMembers.bufferCondition unlock] ;
            }] ;

            if (++selfDataMembers.currentBufferIndex >= G_MAX_BUFFER_COUNT)
                selfDataMembers.currentBufferIndex = 0;

            //This following code is similar to needed code down below in an attempt to stop
            if (valid != G_STREAMING_BUFFER_SIZE)
            {
                if (selfDataMembers.loops)
                {
                    selfDataMembers.CurrentPosition = 0;
                    selfDataMembers.file.framePosition = 0;
                }
            }

            //checks if we are at end of the song
            if (selfDataMembers.CurrentPosition >= selfDataMembers.MaxPosition)
            {
                //if looping reset file pointer and our current position
                if (selfDataMembers.loops)
                {
                    selfDataMembers.CurrentPosition = 0;
                    selfDataMembers.file.framePosition = 0;
                }
                else if (selfDataMembers.buffersQueued == 0 && selfDataMembers.stopFlag == false)
                {
                    G_OBJC_CALL_METHOD(GMacMusic, self, Stop);
                    return;
                }
            }
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Unload)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        bool macresult = false;
        if (selfDataMembers.player != nil)
        {
            G_OBJC_CALL_METHOD(GMacMusic, self, Stop);
            [selfDataMembers.player release] ;
            selfDataMembers.player = nil;
            macresult = true;
        }

        // Cleans up memory in the autorelease pool
        [self autorelease] ;
        return macresult;
    }

    // GMacMusic Implementation End
}

#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT


#elif defined(__linux__)
    #include <pulse/mainloop.h>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/channelmap.h>
#include <pulse/context.h>
#include <pulse/volume.h>
#include <pulse/stream.h>
#include <pulse/error.h>
#include <pulse/scache.h>
#include <pulse/introspect.h>

#include <thread>

#define G_NUM_OF_OUTPUTS 2 // Currently set to forced Stereo
#define G_STREAMING_BUFFER_SIZE 65536
#define G_MAX_BUFFER_COUNT 3

namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface,
            protected GThreadSharedImplementation
        {
			/* this enum is here to prevent compiler warning -Wmultichar
			 * previously, this file used a series of #defines that caused
			 * the warning to occur in a switch statement later on. So instead
			 * of the #defines (initiallizing an int to a series of 4 chars), 
			 * i just declare them here to be the integer they would be 
			 * interpreted as by the compiler internally. */
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};
			
            struct PCM_FORMAT_INFO
            {
                unsigned short mFormatTag = 0;
                unsigned short mNumChannels = 0;
                unsigned int mSamples = 0;
                unsigned int mAvgBytesPerSec = 0;
                unsigned short mBlockAlign = 0;
                unsigned short mBitsPerSample = 0;
                unsigned short mCbSize = 22;
            };

            std::atomic_bool atomic_isPlaying;
            std::atomic_bool atomic_isPaused;
            std::atomic_bool atomic_isComplete;
            std::atomic_bool atomic_stopFlag;
            std::atomic_bool atomic_loops;
            std::atomic<int> pa_ready;
            float masterVolume = 1.0f; // global master volume
            float globalMusicVolume = 1.0f; // global music volume
            float volume = 1.0f; // volume of this music
            uint32_t sinkIndex = UINT32_MAX;
            unsigned int numOfChannels = 0;
            unsigned long fileSize = 0;
			unsigned long audioDataOffset = 0;

            pa_channel_map* myMap = nullptr;
            pa_stream* myStream = nullptr;
            pa_threaded_mainloop* myMainLoop = nullptr;
            pa_context* myContext = nullptr;
            pa_sample_format myPulseFormat;
            pa_cvolume vol;

            char* filePath = nullptr;
            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;
            GW::SYSTEM::GConcurrent gConcurrent;
            PCM_FORMAT_INFO myPCMFormat;
            char buffers[G_MAX_BUFFER_COUNT][G_STREAMING_BUFFER_SIZE];

            void Destroy()
            {
                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				{
					// Disconnects and decrements/unreferences the stream
					if (myStream)
					{
						pa_stream_disconnect(myStream);
						pa_stream_unref(myStream);
						myStream = nullptr;
					}
					
					// Disconnects and decrements/unreferences the context
					if (myContext)
					{
						pa_context_disconnect(myContext);
						pa_context_unref(myContext);
						myContext = nullptr;
					}					
				}
				if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                // Stops the mainloop (after the context is disconnected) and releases memory
                if (myMainLoop)
                {
                    pa_threaded_mainloop_stop(myMainLoop);
                    pa_threaded_mainloop_free(myMainLoop);
                    myMainLoop = nullptr;
                }

                if (filePath)
                {
                    delete[] filePath;
                    filePath = nullptr;
                }
            }

            GReturn LoadOnlyWaveHeaderData(const char* path, PCM_FORMAT_INFO& returnedInfo)
            {
				// default the return value
				GReturn result = GReturn::SUCCESS;
				
				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
                unsigned long dwChunktype = 0;
                unsigned long dwChunkDataSize = 0;
                unsigned long dwRiffDataSize = 0;
                unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
                unsigned long throwAwayValue = 0;
				bool foundAudioData = false;

                while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), dwChunkDataSize)) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), dwChunkDataSize)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&returnedInfo.mFormatTag), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::DATA:
						{
							foundAudioData = true; // audio data is the last part of the file. stop looping
							break;
						}
						
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}
			
			GReturn FindStreamData(const char* path, unsigned long& outDataChunkSize, unsigned long& outOffset)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				unsigned long dwChunkType = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long bytesRead = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false) {
					if (-file.Read(reinterpret_cast<char*>(&dwChunkType), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					switch (dwChunkType) {
						case WaveTag::DATA:
						{
							outDataChunkSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							outOffset = bytesRead;				// Sets the offset to where we are
							foundAudioData = true;				// We found the data, now exit the function
							break;
						}
						
						case WaveTag::RIFF:
							dwChunkDataSize = 4;
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// could not read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							bytesRead += dwChunkDataSize;
							break;
						}
					}
				}

				file.CloseFile();
				return result;
			}


            // PA Callbacks
            static void OnStateChange(pa_context* _c, void* _data)
            {
                pa_context_state_t state;
                std::atomic<int>* pa_ready = (std::atomic<int>*)_data;
				
                state = pa_context_get_state(_c);

                switch (state)
                {
                    case PA_CONTEXT_UNCONNECTED:
                    {
                        break;
                    }
                    case PA_CONTEXT_CONNECTING:
                    {
                        break;
                    }
                    case PA_CONTEXT_AUTHORIZING:
                    {
                        break;
                    }
                    case PA_CONTEXT_SETTING_NAME:
                    {
                        break;
                    }
                    case PA_CONTEXT_FAILED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_TERMINATED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_READY:
                    {
                        *pa_ready = 1;
                        break;
                    }
                }
            }

            static void FinishedDrainOp(pa_stream* s, int success, void* userdata)
            {
                GMusicImplementation* impl = reinterpret_cast<GMusicImplementation*>(userdata);
                impl->atomic_isComplete = true;
            }
			
			char* CreateFilePath(const char* _constCharArray)
			{
				int size = 0;
				for (; size < 1024; ++size)
				{
					if (_constCharArray[size] == '\0')
					{
						++size;
						break;
					}
				}

				if (size >= 1024)
					return nullptr;

				char* charArray = new char[size];
				memcpy(charArray, _constCharArray, size); // char is 1 byte

				return charArray;
			}

        public:
            virtual ~GMusicImplementation()
            {
                Stop();
                LockSyncWrite();
                Destroy();
                UnlockSyncWrite();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;
					
				filePath = CreateFilePath(_path);
				// if _path is > 1024 chars
				if (filePath == nullptr)
					return GReturn::INVALID_ARGUMENT;

                GReturn result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                if (-LoadOnlyWaveHeaderData(_path, myPCMFormat))
                    return GReturn::FAILURE;

                int len = strlen(_path) + 1;
                filePath = new char[len];
                strncpy(filePath, _path, len);

                myMainLoop = pa_threaded_mainloop_new();

                if (myMainLoop == NULL)
                    return GReturn::FAILURE;

				pa_threaded_mainloop_lock(myMainLoop);
				{
					myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "Sound");

					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}
					
					pa_ready = 0;
					pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL);
					pa_context_set_state_callback(myContext, OnStateChange, &pa_ready);				
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                pa_threaded_mainloop_start(myMainLoop);

                while (pa_ready == 0)
                    std::this_thread::yield();

                if (pa_ready != 1)
                    return GReturn::FAILURE;

				switch (myPCMFormat.mBitsPerSample)
				{
					case 8:
						myPulseFormat = PA_SAMPLE_U8;
						break;
					case 16:
						myPulseFormat = PA_SAMPLE_S16LE;
						break;
					case 24:
						myPulseFormat = PA_SAMPLE_S24LE;
						break;
					case 32:
						myPulseFormat = (myPCMFormat.mFormatTag > 1) ? PA_SAMPLE_FLOAT32LE : PA_SAMPLE_S32LE; // Float type for IEEE and Signed 32int for PCM
						break;
					default:
						myPulseFormat = PA_SAMPLE_INVALID;
						return GReturn::FAILURE;
						break;
				}

				pa_sample_spec mySampleSpec;
				mySampleSpec.format = myPulseFormat;
				mySampleSpec.rate = myPCMFormat.mSamples;
				mySampleSpec.channels = myPCMFormat.mNumChannels;;
				if (pa_channels_valid(mySampleSpec.channels) == 0)				
					return GReturn::FAILURE;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					myMap = new pa_channel_map();
					myMap = pa_channel_map_init_extend(myMap, mySampleSpec.channels, PA_CHANNEL_MAP_WAVEEX);
					if (myMap == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}
					
					myStream = pa_stream_new(myContext, "GMusic", &mySampleSpec, myMap); //myMap
					if (myStream == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					if (pa_stream_connect_playback(myStream, NULL, NULL, (pa_stream_flags_t)0, NULL, NULL) != 0)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}					
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                globalMusicVolume = audioImplementation->musicVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

				pa_cvolume_init(&vol);
				
                result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                atomic_isComplete = false;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                        case GW::AUDIO::GAudio::Events::DESTROY:
                        {
                            Stop();
                            LockSyncWrite();
                            Destroy();
                            UnlockSyncWrite();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
                        {
                            Play();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
                        {
                            Pause();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
                        {
                            Resume();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::STOP_MUSIC:
                        {
                            Stop();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            masterVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            globalMusicVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                            SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float adjustedVolume = volume * masterVolume * globalMusicVolume;
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // 5.1 to stereo fallback
                    if (_numChannels > G_NUM_OF_OUTPUTS)
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        switch (i)
                        {
                            case 2: // Front Center
                            {
                                channelVolumes[0] += channelVolumes[2] * 0.5f;
                                channelVolumes[1] += channelVolumes[2] * 0.5f;
                                break;
                            }
                            case 3: // LFE
                            {
                                channelVolumes[0] += channelVolumes[3] * 0.3f;
                                channelVolumes[1] += channelVolumes[3] * 0.3f;
                                break;
                            }
                            case 4: // Rear Left
                            {
                                channelVolumes[0] += channelVolumes[4] * 0.7f;
                                break;
                            }
                            case 5: //Rear Right
                            {
                                channelVolumes[1] += channelVolumes[5] * 0.7f;
                                break;
                            }
                        }

                        // clamp stereo to max of 1.0f
                        if (i == _numChannels - 1)
                        {
                            channelVolumes[0] = (channelVolumes[0] > 1.0f) ? 1.0f : channelVolumes[0];
                            channelVolumes[1] = (channelVolumes[1] > 1.0f) ? 1.0f : channelVolumes[1];
							vol.values[0] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[0] * masterChannelVolumes[0]);
							vol.values[1] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[1] * masterChannelVolumes[1]);
                            break;
                        }
                    }
                    else
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        // apply clamping and master volume multiplier
						vol.values[i] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[i] * masterChannelVolumes[i]);
                    }
                }

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with	
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();

				vol.channels = G_NUM_OF_OUTPUTS;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					//Set the volume of a sink input stream.
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                _newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
                volume = _newVolume;

                // Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
                _newVolume *= masterVolume * globalMusicVolume;			
				vol.channels = G_NUM_OF_OUTPUTS;
				for (int i = 0; i < vol.channels; ++i)
					vol.values[i] = pa_sw_volume_from_linear(_newVolume * channelVolumes[i] * masterChannelVolumes[i]);

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}					
                UnlockSyncWrite();
                
                //Set the volume of a sink input stream.
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn Play(bool _loop = false) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;
                    
                atomic_loops = _loop;

                if (atomic_isPlaying || atomic_isComplete)
                {
                    GReturn result = Stop();

                    if (result != GReturn::SUCCESS)
                        return result;
                }

                if (atomic_isPlaying == false)
                {
                    atomic_stopFlag = false;
                    atomic_isPaused = false;
                    atomic_isPlaying = true;
					
                    gConcurrent.BranchSingular([&]() {
                        unsigned short CurrentDiskReadBuffer = 0;
						unsigned long CurrentPosition = 0;

						if (-FindStreamData(filePath, fileSize, audioDataOffset))
							return GReturn::FAILURE;
						
                        // probably safer to do this after the call to FindStreamData because that function creates its own GFile from the same path
						GW::SYSTEM::GFile gfile;
						gfile.Create();
						
						if (-gfile.OpenBinaryRead(filePath)) {
							// file could not be opened
							return GReturn::FAILURE;
						}

						// seek to the start of the audio stream data
						unsigned int unusedPosition; // unused variable but needed for the next function
						gfile.Seek(0, audioDataOffset, unusedPosition);
						
                        pa_stream_state_t state;
						
                        while (CurrentPosition < fileSize) {
                            if (atomic_stopFlag == true) {
								pa_threaded_mainloop_lock(myMainLoop);
									pa_stream_cancel_write(myStream);
								pa_threaded_mainloop_unlock(myMainLoop);
                                break;
                            }
                            else {
                                pa_threaded_mainloop_lock(myMainLoop);
									state = pa_stream_get_state(myStream);
                                pa_threaded_mainloop_unlock(myMainLoop);

                                if (state == PA_STREAM_READY)
                                {
									unsigned long cbValid = (G_STREAMING_BUFFER_SIZE < (fileSize - CurrentPosition))
										? G_STREAMING_BUFFER_SIZE // if less
										: (fileSize - CurrentPosition); // if greater or equal
										
									// should already be at the correct offset. just have to read the data in now
									if (-gfile.Read(buffers[CurrentDiskReadBuffer], cbValid))
										continue;
									
									CurrentPosition += cbValid;
									
									if (CurrentPosition >= fileSize)
                                    {
										if (atomic_loops)
										{
											pa_threaded_mainloop_lock(myMainLoop);
												pa_stream_write(myStream, buffers[CurrentDiskReadBuffer], cbValid, nullptr, 0, PA_SEEK_RELATIVE);
											pa_threaded_mainloop_unlock(myMainLoop);
											
											++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
											CurrentPosition = 0;
											
											// read until we get to the start of the audio stream data
											gfile.Seek(0, audioDataOffset, unusedPosition);
											
											continue;
										}
										else
										{
											pa_threaded_mainloop_lock(myMainLoop);
											{
												pa_operation* o = pa_stream_drain(myStream, FinishedDrainOp, this);

												if (o)
													pa_operation_unref(o);												
											}
											pa_threaded_mainloop_unlock(myMainLoop);
											break;
										}
                                    }
                                    else
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
											pa_stream_write(myStream, buffers[CurrentDiskReadBuffer], cbValid, nullptr, 0, PA_SEEK_RELATIVE);
										pa_threaded_mainloop_unlock(myMainLoop);
										
										++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
                                    }
                                }
                            }
                        }
                        gfile.CloseFile();

                        // This needs to be reset so it doesn't remember where it left off playing
                        audioDataOffset = 0;

                        // Updates information about playback state
                        atomic_isPlaying = false;
                        atomic_isPaused = false;
                        atomic_isComplete = true;

                        return GReturn::SUCCESS;
                    });
                }
                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                atomic_isPaused = true;
                atomic_isPlaying = false;

                return GReturn::SUCCESS;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                atomic_isPaused = false;
                atomic_isPlaying = true;

                return GReturn::SUCCESS;
            }

            GReturn Stop() override
            {
                atomic_isPlaying = false;
                atomic_isPaused = false;
                atomic_isComplete = false;
                atomic_stopFlag = true;

                gConcurrent.Converge(0);

                // Converge has to run before return
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return GReturn::SUCCESS;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = myPCMFormat.mNumChannels;
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS; // forced Stereo
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = atomic_isPlaying;
                return GReturn::SUCCESS;
            }

        protected:
            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    };// end I
}// end GW

#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT

#elif defined(_WIN32)
    #define G_NUM_OF_OUTPUTS 6
#define G_STREAMING_BUFFER_SIZE 65536
#define G_MAX_BUFFER_COUNT 3

namespace GW
{
	namespace I
	{
		class GMusicImplementation : public virtual GMusicInterface,
			protected GThreadSharedImplementation,
			protected IXAudio2VoiceCallback
		{
			// This enum exists for parity with Linux. See GMusic_Linux.hpp for more info
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};

			GReturn LoadOnlyWaveHeaderData(const char* path, WAVEFORMATEXTENSIBLE& myWFX)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
				unsigned long dwChunktype = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long dwRiffDataSize = 0;
				unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), 4) || dwFileType != WaveTag::WAVE) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), 4)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&myWFX), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::DATA:
						{
							foundAudioData = true; // audio data is the last part of the file. stop looping
							break;
						}

						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}

			GReturn FindStreamData(const char* path, unsigned long& outDataChunkSize, OVERLAPPED& overlap)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				unsigned long dwChunkType = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long bytesRead = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false) {
					if (-file.Read(reinterpret_cast<char*>(&dwChunkType), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					switch (dwChunkType) {
						case WaveTag::DATA:
						{
							outDataChunkSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							overlap.Offset = bytesRead;			// Sets the offset to where we are
							foundAudioData = true;				// We found the data, now exit the function
							break;
						}

						case WaveTag::RIFF:
							dwChunkDataSize = 4;
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// could not read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							bytesRead += dwChunkDataSize;
							break;
						}
					}
				}

				file.CloseFile();
				return result;
			}

			void STDMETHODCALLTYPE OnBufferStart(void*) { ResetEvent(hBufferEndEvent); }
			void STDMETHODCALLTYPE OnBufferEnd(void*) { SetEvent(hBufferEndEvent); }
			// Required studs as IXAudio2VoiceCallback is an abstract class
			void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}
			void STDMETHODCALLTYPE OnVoiceError(void*, HRESULT) {}
			void STDMETHODCALLTYPE OnStreamEnd() {}
			void STDMETHODCALLTYPE OnLoopEnd(void*) {}

			std::atomic_bool atomic_isPlaying = false;
			std::atomic_bool atomic_isPaused = false;
			std::atomic_bool atomic_isComplete = false;
			std::atomic_bool atomic_isLooping = false;
			std::atomic_bool atomic_stopFlag = false;
			float masterVolume = 1.0f; // global master volume
			float globalMusicVolume = 1.0f; // global music volume
			float volume = 1.0f; // volume of this sound
			unsigned int numOfChannels = 0;
			unsigned long fileSize = 0;
			OVERLAPPED overlap = { 0 };

			IXAudio2SourceVoice* mySourceVoice = nullptr;
			IXAudio2SubmixVoice* mySubmixVoice = nullptr;
			char* filePath;
			HANDLE hBufferEndEvent;

			float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
			float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
			GW::AUDIO::GAudio gAudio;
			GW::CORE::GEventReceiver gReceiver;
			GW::SYSTEM::GConcurrent gConcurrent;
			BYTE buffers[G_MAX_BUFFER_COUNT][G_STREAMING_BUFFER_SIZE];

			char* CreateFilePath(const char* _constCharArray)
			{
				int size = 0;
				for (; size < 1024; ++size)
				{
					if (_constCharArray[size] == '\0')
					{
						++size;
						break;
					}
				}

				if (size >= 1024)
					return nullptr;

				char* charArray = new char[size];
				memcpy(charArray, _constCharArray, size); // char is 1 byte

				return charArray;
			}

		public:
			virtual ~GMusicImplementation()
			{
				Stop();

				// We do not need to check for GAudio proxy here, since those handles would get cleaned up 
				// in the event callback if GAudio gets deleted first
				LockSyncWrite();
				if (mySourceVoice)
					mySourceVoice->DestroyVoice();

				if (mySubmixVoice)
					mySubmixVoice->DestroyVoice();
				UnlockSyncWrite();

				if (filePath)
					delete[] filePath;

				if (hBufferEndEvent)
					CloseHandle(hBufferEndEvent);
			}

			GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
			{
				if (!_path || !_audio)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				filePath = CreateFilePath(_path);
				// if _path is > 1024 chars
				if (filePath == nullptr)
					return GReturn::INVALID_ARGUMENT;

				gAudio = _audio;
				auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);
				hBufferEndEvent = CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE);
				if (!hBufferEndEvent)
					return GReturn::FAILURE;

				WAVEFORMATEXTENSIBLE wfmx;
				if (-LoadOnlyWaveHeaderData(filePath, wfmx))
					return GReturn::FAILURE;

				// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. (for non-PCM formats)
				wfmx.Format.cbSize = (wfmx.Format.wFormatTag > 1) ? 22 : 0;
				numOfChannels = static_cast<unsigned int>(wfmx.Format.nChannels);
				if (audioImplementation->XAudioData.myAudio->CreateSubmixVoice(&mySubmixVoice, G_NUM_OF_OUTPUTS, wfmx.Format.nSamplesPerSec) != S_OK)
					return GReturn::FAILURE;

				XAUDIO2_SEND_DESCRIPTOR mscSendDcsp = { 0, mySubmixVoice };
				XAUDIO2_VOICE_SENDS mscSendList = { 1, &mscSendDcsp };

				if (audioImplementation->XAudioData.myAudio->CreateSourceVoice(&mySourceVoice, &wfmx.Format, 0, XAUDIO2_DEFAULT_FREQ_RATIO, this, &mscSendList) != S_OK)
					return GReturn::FAILURE;

				globalMusicVolume = audioImplementation->musicVolume;
				masterVolume = audioImplementation->masterVolume;
				memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

				GReturn result = SetVolume(_volume);
				if (result != GReturn::SUCCESS)
					return result;

				result = SetChannelVolumes(channelVolumes, 6);
				if (result != GReturn::SUCCESS)
					return result;

				result = GThreadSharedImplementation::Create();
				if (result != GReturn::SUCCESS)
					return result;

				result = gConcurrent.Create(true);
				if (result != GReturn::SUCCESS) // Events are suppressed
					return result;

				overlap.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

				return gReceiver.Create(_audio, [&]()
				{
					GW::GEvent gEvent;
					GW::AUDIO::GAudio::Events audioEvent;
					GW::AUDIO::GAudio::EVENT_DATA audioEventData;
					// Process the event message
					gReceiver.Pop(gEvent);
					gEvent.Read(audioEvent);

					switch (audioEvent)
					{
						case GW::AUDIO::GAudio::Events::DESTROY:
						{
							//printf("DESTROY RECEIVED IN MUSIC\n");
							Stop();
							// Need to cleanup XAudio handles before GAudio is deleted
							LockSyncWrite();
							if (mySourceVoice)
							{
								mySourceVoice->DestroyVoice();
								mySourceVoice = nullptr;
							}

							if (mySubmixVoice)
							{
								mySubmixVoice->DestroyVoice();
								mySubmixVoice = nullptr;
							}
							UnlockSyncWrite();
							break;
						}
						case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
						{
							Play();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC PLAY %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
						{
							Pause();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC PAUSE %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
						{
							Resume();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC RESUME %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::STOP_MUSIC:
						{
							Stop();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC STOP: %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							masterVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalMusicVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							globalMusicVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("GLOBAL MUSIC VOLUME: %f | VOLUME: %f\n", globalMusicVolume, volume * globalMusicVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
						{
							gEvent.Read(audioEventData);
							memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
							SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
							//printf("MUSIC CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
							break;
						}
						default:
						{
							break;
						}
					}
				});
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < _numChannels; i++)
				{
					if (_values[i] < 0.0f)
						return GReturn::INVALID_ARGUMENT;

					// apply clamping and master volume multiplier
					channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
				}

				unsigned int sourceChannels = 0;
				GetSourceChannels(sourceChannels);

				// can only support up to 6 outputs
				float matrix[12] = { 0 };
				unsigned int trueIndex = 0;
				for (unsigned int i = 0; i < 12;)
				{
					if (trueIndex < _numChannels)
					{
						float matrixVolume = channelVolumes[trueIndex] * masterChannelVolumes[trueIndex];
						matrix[i] = matrixVolume;
						matrix[i + 1] = matrixVolume;
						trueIndex++;
						i += 2;
					}
					else
					{
						matrix[i] = 0;
						i++;
					}
				}

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetOutputMatrix(mySubmixVoice, sourceChannels, G_NUM_OF_OUTPUTS, matrix)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				// Clip the passed volume to max
				_newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				volume = _newVolume;

				// Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetVolume(volume * globalMusicVolume * masterVolume)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn Play(bool _loop = false) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				atomic_isLooping = _loop;

				if (atomic_isPlaying || atomic_isComplete)
				{
					GReturn result = Stop();

					if (result != GReturn::SUCCESS)
						return result;
				}

				if (atomic_isPlaying == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start(0, 0)))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_stopFlag = false;
					atomic_isPaused = false;
					atomic_isPlaying = true;

					gConcurrent.BranchSingular([&]() {
						unsigned short CurrentDiskReadBuffer = 0;
						unsigned long CurrentPosition = 0;

						if (-FindStreamData(filePath, fileSize, overlap))
							return GReturn::FAILURE;

						// probably safer to do this after the call to FindStreamData because that function creates its own GFile from the same path
						GW::SYSTEM::GFile gfile;
						gfile.Create();

						if (-gfile.OpenBinaryRead(filePath)) {
							// file could not be opened
							return GReturn::FAILURE;
						}

						// seek to start of the audio stream data
						unsigned int unusedPosition; // unused variable but needed for the next function
						gfile.Seek(0, overlap.Offset, unusedPosition);

						while (CurrentPosition < fileSize && atomic_stopFlag == false)
						{
							if (atomic_isPlaying)
							{
								unsigned long cbValid = (G_STREAMING_BUFFER_SIZE < (fileSize - CurrentPosition))
									? G_STREAMING_BUFFER_SIZE // if less
									: (fileSize - CurrentPosition); // if greater or equal

								// should already be at the correct offset. just have to read the data in now
								if (-gfile.Read(reinterpret_cast<char*>(buffers[CurrentDiskReadBuffer]), cbValid))
									continue;

								// update the file position to where it will be once the read finishes
								CurrentPosition += cbValid;

								XAUDIO2_VOICE_STATE state = { 0 };

								while (atomic_isPlaying)
								{
									LockAsyncRead();
									if (mySourceVoice == nullptr)
									{
										UnlockAsyncRead();
										return GReturn::FAILURE;
									}
									mySourceVoice->GetState(&state);
									UnlockAsyncRead();

									if (state.BuffersQueued >= G_MAX_BUFFER_COUNT - 1)
									{
										if (WaitForSingleObjectEx(hBufferEndEvent, INFINITE, TRUE) == WAIT_FAILED)
											break; // if deadlocks on pause check here <REMINDER>
									}
									else break;
								}

								/*
								FOR FUTURE AUDIO DEVELOPER
								PCM FUNTION POINTER GOES HERE
								for(int i = 0; i < cbValid; i++)
								{
									dataFunction(buffers[CurrentDiskReadBuffer][i]);
								}
								*/

								XAUDIO2_BUFFER buf = { 0 };
								buf.AudioBytes = cbValid;
								buf.pAudioData = buffers[CurrentDiskReadBuffer];

								if (CurrentPosition >= fileSize)
								{
									if (atomic_isLooping)
									{
										LockSyncWrite();
										if (mySourceVoice == nullptr || FAILED(mySourceVoice->SubmitSourceBuffer(&buf)))
										{
											UnlockSyncWrite();
											return GReturn::FAILURE;
										}
										UnlockSyncWrite();

										++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
										CurrentPosition = 0;
										
										// seek back to the start of the audio stream data
										gfile.Seek(0, overlap.Offset, unusedPosition);

										continue;
									}
									else
										buf.Flags = XAUDIO2_END_OF_STREAM;
								}

								LockSyncWrite();
								if (mySourceVoice == nullptr || FAILED(mySourceVoice->SubmitSourceBuffer(&buf)))
								{
									UnlockSyncWrite();
									return GReturn::FAILURE;
								}
								UnlockSyncWrite();

								++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
							}
						}
						// Close the gfile since we are no longer using it
						gfile.CloseFile();

						XAUDIO2_VOICE_STATE state;
						LockAsyncRead();
						if (mySourceVoice == nullptr)
						{
							UnlockAsyncRead();
							return GReturn::FAILURE;
						}
						mySourceVoice->GetState(&state);
						UnlockAsyncRead();

						// Waits for last buffers to finish playing
						while (state.BuffersQueued > 0)
						{
							if (atomic_stopFlag == true)
								break;

							LockAsyncRead();
							if (mySourceVoice == nullptr)
							{
								UnlockAsyncRead();
								return GReturn::FAILURE;
							}
							mySourceVoice->GetState(&state);
							UnlockAsyncRead();

							// [TODO:] needs testing
							if (WaitForSingleObjectEx(hBufferEndEvent, INFINITE, TRUE) == WAIT_FAILED)
								break;
						}

						// Stops the voice from producing more sound
						LockSyncWrite();
						if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
						{
							UnlockSyncWrite();
							return GReturn::FAILURE;
						}
						UnlockSyncWrite();

						// This needs to be reset so XAudio2 doesn't remember where it left off playing
						overlap.Offset = 0;

						// Updates information about playback state
						atomic_isPlaying = false;
						atomic_isPaused = false;
						atomic_isComplete = true;

						return GReturn::SUCCESS;
					});
				}

				return GReturn::SUCCESS;
			}

			GReturn Pause() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();
				}

				atomic_isPlaying = false;
				atomic_isPaused = true;
				SetEvent(hBufferEndEvent);

				return GReturn::SUCCESS;
			}

			GReturn Resume() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == true)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}
				else
					return GReturn::REDUNDANT;

				return GReturn::SUCCESS;
			}

			GReturn Stop() override
			{
				atomic_isPlaying = false;
				atomic_isPaused = false;
				atomic_isComplete = false;
				atomic_stopFlag = true;

				LockSyncWrite();
				if (mySourceVoice != nullptr)
					mySourceVoice->FlushSourceBuffers();
				UnlockSyncWrite();

				gConcurrent.Converge(0);

				// Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				return GReturn::SUCCESS;
			}

			GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = numOfChannels;
				return GReturn::SUCCESS;
			}

			GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = G_NUM_OF_OUTPUTS;
				return GReturn::SUCCESS;
			}

			GReturn isPlaying(bool& _returnedBool) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				_returnedBool = atomic_isPlaying;
				return GReturn::SUCCESS;
			}

		protected:
			// ThreadShared
			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	}// end I
}// end GW

#undef G_RIFFcc
#undef G_DATAcc
#undef G_FMTcc 
#undef G_WAVEcc
#undef G_JUNKcc
//#undef G_XWMAcc
//#undef G_DPDScc
#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT


#endif



namespace GW
{
    namespace AUDIO
    {
        class GMusic final 
			: public I::GProxy<I::GMusicInterface,  I::GMusicImplementation, const char*, GAudio, float>
        {
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback
			{
				init_callback()
				{
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<CORE::GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

            // All Gateware API interfaces contain no variables & are pure virtual.
        public:
			GATEWARE_PROXY_CLASS(GMusic)
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)

            // This area does not contain actual code, it is only for the benefit of documentation generation.
        };
    }
}

#endif // GMUSIC_H


/*---------------------------------
|	End of GMusic.h
----------------------------------*/


/*---------------------------------
|	Begin of GSound3D.h
----------------------------------*/
#ifndef GSOUND3D_H
#define GSOUND3D_H






namespace GW
{
	namespace I
	{
		class GSound3DInterface : public virtual GSoundInterface
		{
		public:
			virtual GReturn UpdatePosition(GW::MATH::GVECTORF _position) = 0;
			virtual GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) = 0;
		};
	}
}

// Implementaion for GSound3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GSOUND3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GSOUND3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GSound3DImplementation : public virtual GSound3DInterface
		{
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override { return GReturn::FAILURE; }
			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override { return GReturn::FAILURE; }
			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GReturn::FAILURE; }
			GReturn SetVolume(float _newVolume) override { return GReturn::FAILURE; }
			GReturn Play() override { return GReturn::FAILURE; }
			GReturn Pause() override { return GReturn::FAILURE; }
			GReturn Resume() override { return GReturn::FAILURE; }
			GReturn Stop() override { return GReturn::FAILURE; }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn isPlaying(bool& _returnedBool) const override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GSound3DImplementation : public virtual GSound3DInterface,
			protected GSoundImplementation
		{
		private:
			GW::AUDIO::GAudio3D gAudio3D;
			GW::CORE::GEventReceiver gReceiver;

			MATH::GVECTORF position = MATH::GIdentityVectorF;
			MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
			MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
			GW::AUDIO::GATTENUATION attenuation = GW::AUDIO::GATTENUATION::LINEAR;
			float minRadius = 0.0f;
			float maxRadius = 50.0f;
			float volume = 1.0f;

			GReturn CalculateRatio(float theta, float spread, float start, float end, float& outRatio)
			{
				if (start >= end)
					return GReturn::FAILURE;

				if (spread > 180.0f)
					return GReturn::FAILURE;

				float startBound = theta - spread;
				float endBound = theta + spread;
				float deltaSection = end - start;

				float RrR = (endBound - start) / deltaSection;
				float RlR = (startBound - start) / deltaSection;

				float clampR = G_CLAMP(RrR, 0.0f, 1.0f);
				float clampL = G_CLAMP(RlR, 0.0f, 1.0f);

				outRatio = clampR - clampL;

				return GReturn::SUCCESS;
			}

			GReturn GetSpatializedChannelVolumes(GW::MATH::GVECTORF _position, float _volume,
				float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, unsigned int _channelNum,
				float* _outChannelVolumes)
			{
				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				GW::MATH::GVECTORF localPosition;
				GReturn result = GW::MATH::GMatrix::VectorXMatrixF(transform, _position, localPosition);

				if (result != GReturn::SUCCESS)
					return result;

				// D = |local|                              -float distance [0, MAX_DISTANCE]
				float distance;
				GW::MATH::GVector::MagnitudeF(localPosition, distance);

				GW::MATH::GVECTORF pFlat = { {{ localPosition.x, 0, localPosition.z, localPosition.w }} };

				float dFlat;
				GW::MATH::GVector::MagnitudeF(pFlat, dFlat);

				localPosition = pFlat;
				GW::MATH::GVector::NormalizeF(localPosition, localPosition);

				// Here is where the different attenuation shapes will be implemented.
				switch (_attenuation)
				{
				case GW::AUDIO::GATTENUATION::LINEAR:
					// V = volume = 1 - D / Dmax                -float volume [0, 1]

					// maps x [0, 1] => 1 - x [0, 1]
					_volume *= (1 - G_CLAMP(G_CLAMP(distance - _minRadius, 0, 1) / _maxRadius, 0, 1));
					break;
					/*case LOGARITHMIC:
						// TODO: map volume x [0, 1] => Log(x) [0, 1]
					break;*/
					/*case LOGREVERSE:
						// TODO: map volume x [0, 1] => Log-1(x) [0, 1]
					break;*/
					/*case INVERSE:
						// TODO: map volume x [0, 1] => 1/x [0, 1]
					break;*/
					/*case NATURAL:
						// TODO: map volume x [0, 1] => 10^((x-dB)/20) [0, 1]
					break;*/
				}

				// spread = (1 - DFlat / DFlatMax) * 180    -float spread [0, 180]
				float spread = (1 - G_CLAMP(dFlat / _maxRadius, 0, 1)) * 180;

				GW::MATH::GVECTORF cross;
				GW::MATH::GVECTORF forward = {{{0.0f, 0.0f, 1.0f, 0.0f}}};
				result = GW::MATH::GVector::CrossVector3F(forward, localPosition, cross);

				if (result != GReturn::SUCCESS)
					return result;

				float theta;
				result = GW::MATH::GVector::DotF(forward, localPosition, theta);

				if (result != GReturn::SUCCESS)
					return result;

				theta = (cross.y > 0) ? acosf(theta) : -1 * acosf(theta);
				theta = static_cast<float>(G_RADIAN_TO_DEGREE(theta));

				if (result != GReturn::SUCCESS)
					return result;

				float ratio = 0;
				//float channelVolumes[6] = { 0, 0, 0, 0, 0, 0 };
				for (unsigned int i = 0; i < _channelNum; i++)
				{
					switch (i + 1)
					{
					case 1: // FRONT_LEFT
						result = CalculateRatio(theta, spread, -114, -38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 246, 322, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 2: // FRONT_RIGHT
						result = CalculateRatio(theta, spread, 38, 114, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -322, -246, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 3: // FRONT_CENTER
						result = CalculateRatio(theta, spread, -38, 38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 322, 398, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 5: // SURROUND_LEFT
						result = CalculateRatio(theta, spread, 180, 246, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -180, -114, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 6: // SURROUND_RIGHT
						result = CalculateRatio(theta, spread, 114, 180, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -246, -180, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					}

					_outChannelVolumes[i] = ratio * _volume;
					_outChannelVolumes[4] = _outChannelVolumes[i] > _outChannelVolumes[4] ? _outChannelVolumes[i] : _outChannelVolumes[4];
				}

				return result;
			}

			GReturn Spatialize()
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				float volumes[6] = { 0, 0, 0, 0, 0, 0 };
				GReturn result = GetSpatializedChannelVolumes(position, volume, minRadius, maxRadius, attenuation, 6, volumes);

				if (result != GReturn::SUCCESS)
					return result;

				return SetChannelVolumes(volumes, 6);
			}
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D, float _volume = 1.0f)
			{
				if (!_path || !_audio3D)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				attenuation = _attenuation;
				minRadius = _minRadius;
				maxRadius = _maxRadius;
				gAudio3D = _audio3D;
				volume = _volume;

				GReturn result = GSoundImplementation::Create(_path, _audio3D, _volume);
				if (result != GReturn::SUCCESS)
					return result;
				
				auto audio3DImplementation = std::dynamic_pointer_cast<GW::I::GAudio3DImplementation>(*_audio3D);
				return gReceiver.Create(audio3DImplementation->gEventGen, [&]()
				{
					GW::GEvent event;
					if (+gReceiver.Pop(event))
					{
						GW::AUDIO::GAudio3D::Events audio3devent;
						if (+event.Read(audio3devent))
						{
							switch (audio3devent)
							{
							case GW::AUDIO::GAudio3D::Events::UPDATE_LISTENER:
							{
								GW::AUDIO::GAudio3D::EVENT_DATA eventData;
								event.Read(eventData);
								GW::MATH::GMATRIXF eventMatrix;
								GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
								eventMatrix.row4 = eventData.position;
								listener = eventMatrix;
								break;
							}
							case GW::AUDIO::GAudio3D::Events::UPDATE_TRANSFORM_AND_SPATIALIZE:
							{
								GW::AUDIO::GAudio3D::EVENT_DATA eventData;
								event.Read(eventData);
								GW::MATH::GMATRIXF eventMatrix;
								GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
								eventMatrix.row4 = eventData.position;
								transform = eventMatrix;
								Spatialize();
								break;
							}
							default:
								break;
							}
						}
					}
				});
			}

			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				position = _position;
				return Spatialize();
			}

			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				if (_minRadius > _maxRadius)
					return GReturn::INVALID_ARGUMENT;

				minRadius = _minRadius;
				maxRadius = _maxRadius;
				attenuation = _attenuation;

				return Spatialize();
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				return GSoundImplementation::SetVolume(volume);
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GSoundImplementation::SetChannelVolumes(_values, _numChannels); }
			GReturn Play() override { return GSoundImplementation::Play(); }
			GReturn Pause() override { return GSoundImplementation::Pause(); }
			GReturn Resume() override { return GSoundImplementation::Resume(); }
			GReturn Stop() override { return GSoundImplementation::Stop(); }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GSoundImplementation::GetSourceChannels(_returnedChannelNum); }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GSoundImplementation::GetOutputChannels(_returnedChannelNum); }
			GReturn isPlaying(bool& _returnedBool) const override { return GSoundImplementation::isPlaying(_returnedBool); }
		};
	}
}


#endif


namespace GW
{
	namespace AUDIO
	{
		class GSound3D final 
			: public I::GProxy<I::GSound3DInterface, I::GSound3DImplementation, const char*, float, float, GW::AUDIO::GATTENUATION, GW::AUDIO::GAudio3D>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GSound3D);
			GATEWARE_FUNCTION(UpdatePosition);
			GATEWARE_FUNCTION(UpdateAttenuation);

			// reimplemented 
			GATEWARE_FUNCTION(SetChannelVolumes);
			GATEWARE_FUNCTION(SetVolume);
			GATEWARE_FUNCTION(Play);
			GATEWARE_FUNCTION(Pause);
			GATEWARE_FUNCTION(Resume);
			GATEWARE_FUNCTION(Stop);
			GATEWARE_CONST_FUNCTION(GetSourceChannels);
			GATEWARE_CONST_FUNCTION(GetOutputChannels);
			GATEWARE_CONST_FUNCTION(isPlaying);

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GSOUND3D_H

/*---------------------------------
|	End of GSound3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GMusic3D.h
----------------------------------*/
#ifndef GMUSIC3D_H
#define GMUSIC3D_H






namespace GW
{
	namespace I
	{
		class GMusic3DInterface : public virtual GMusicInterface
		{
		public:
			virtual GReturn UpdatePosition(GW::MATH::GVECTORF _position) = 0;
			virtual GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) = 0;
		};
	}
}

// Implementaion for GMusic3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GMUSIC3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GMUSIC3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GMusic3DImplementation : public virtual GMusic3DInterface
		{
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override { return GReturn::FAILURE; }
			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override { return GReturn::FAILURE; }
			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GReturn::FAILURE; }
			GReturn SetVolume(float _newVolume) override { return GReturn::FAILURE; }
			GReturn Play(bool _loop = false) override { return GReturn::FAILURE; }
			GReturn Pause() override { return GReturn::FAILURE; }
			GReturn Resume() override { return GReturn::FAILURE; }
			GReturn Stop() override { return GReturn::FAILURE; }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn isPlaying(bool& _returnedBool) const override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GMusic3DImplementation : public virtual GMusic3DInterface,
			protected GMusicImplementation
		{
		private:
			GW::AUDIO::GAudio3D gAudio3D;
			GW::CORE::GEventReceiver gReceiver;

			MATH::GVECTORF position = MATH::GIdentityVectorF;
			MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
			MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
			GW::AUDIO::GATTENUATION attenuation = GW::AUDIO::GATTENUATION::LINEAR;
			float minRadius = 0.0f;
			float maxRadius = 50.0f;
			float volume = 1.0f;

			GReturn CalculateRatio(float theta, float spread, float start, float end, float& outRatio)
			{
				if (start >= end)
					return GReturn::FAILURE;

				if (spread > 180.0f)
					return GReturn::FAILURE;

				float startBound = theta - spread;
				float endBound = theta + spread;
				float deltaSection = end - start;

				float RrR = (endBound - start) / deltaSection;
				float RlR = (startBound - start) / deltaSection;

				float clampR = G_CLAMP(RrR, 0.0f, 1.0f);
				float clampL = G_CLAMP(RlR, 0.0f, 1.0f);

				outRatio = clampR - clampL;

				return GReturn::SUCCESS;
			}

			GReturn GetSpatializedChannelVolumes(GW::MATH::GVECTORF _position, float _volume,
				float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, unsigned int _channelNum,
				float* _outChannelVolumes)
			{
				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				GW::MATH::GVECTORF localPosition;
				GReturn result = GW::MATH::GMatrix::VectorXMatrixF(transform, _position, localPosition);

				if (result != GReturn::SUCCESS)
					return result;

				// D = |local|                              -float distance [0, MAX_DISTANCE]
				float distance;
				GW::MATH::GVector::MagnitudeF(localPosition, distance);

				GW::MATH::GVECTORF pFlat = { {{ localPosition.x, 0, localPosition.z, localPosition.w }} };

				float dFlat;
				GW::MATH::GVector::MagnitudeF(pFlat, dFlat);

				localPosition = pFlat;
				GW::MATH::GVector::NormalizeF(localPosition, localPosition);

				// Here is where the different attenuation shapes will be implemented.
				switch (_attenuation)
				{
				case GW::AUDIO::GATTENUATION::LINEAR:
					// V = volume = 1 - D / Dmax                -float volume [0, 1]

					// maps x [0, 1] => 1 - x [0, 1]
					_volume *= (1 - G_CLAMP(G_CLAMP(distance - _minRadius, 0, 1) / _maxRadius, 0, 1));
					break;
					/*case LOGARITHMIC:
						// TODO: map volume x [0, 1] => Log(x) [0, 1]
					break;*/
					/*case LOGREVERSE:
						// TODO: map volume x [0, 1] => Log-1(x) [0, 1]
					break;*/
					/*case INVERSE:
						// TODO: map volume x [0, 1] => 1/x [0, 1]
					break;*/
					/*case NATURAL:
						// TODO: map volume x [0, 1] => 10^((x-dB)/20) [0, 1]
					break;*/
				}

				// spread = (1 - DFlat / DFlatMax) * 180    -float spread [0, 180]
				float spread = (1 - G_CLAMP(dFlat / _maxRadius, 0, 1)) * 180;

				GW::MATH::GVECTORF cross;
				GW::MATH::GVECTORF forward = {{{0.0f, 0.0f, 1.0f, 0.0f}}};
				result = GW::MATH::GVector::CrossVector3F(forward, localPosition, cross);

				if (result != GReturn::SUCCESS)
					return result;

				float theta;
				result = GW::MATH::GVector::DotF(forward, localPosition, theta);

				if (result != GReturn::SUCCESS)
					return result;

				theta = (cross.y > 0) ? acosf(theta) : -1 * acosf(theta);
				theta = static_cast<float>(G_RADIAN_TO_DEGREE(theta));

				if (result != GReturn::SUCCESS)
					return result;

				float ratio = 0;
				//float channelVolumes[6] = { 0, 0, 0, 0, 0, 0 };
				for (unsigned int i = 0; i < _channelNum; i++)
				{
					switch (i + 1)
					{
					case 1: // FRONT_LEFT
						result = CalculateRatio(theta, spread, -114, -38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 246, 322, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 2: // FRONT_RIGHT
						result = CalculateRatio(theta, spread, 38, 114, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -322, -246, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 3: // FRONT_CENTER
						result = CalculateRatio(theta, spread, -38, 38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 322, 398, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 5: // SURROUND_LEFT
						result = CalculateRatio(theta, spread, 180, 246, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -180, -114, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 6: // SURROUND_RIGHT
						result = CalculateRatio(theta, spread, 114, 180, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -246, -180, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					}

					_outChannelVolumes[i] = ratio * _volume;
					_outChannelVolumes[4] = _outChannelVolumes[i] > _outChannelVolumes[4] ? _outChannelVolumes[i] : _outChannelVolumes[4];
				}

				return result;
			}

			GReturn Spatialize()
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				float volumes[6] = { 0, 0, 0, 0, 0, 0 };
				GReturn result = GetSpatializedChannelVolumes(position, volume, minRadius, maxRadius, attenuation, 6, volumes);

				if (result != GReturn::SUCCESS)
					return result;

				return SetChannelVolumes(volumes, 6);
			}
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D, float _volume = 1.0f)
			{
				if (!_path || !_audio3D)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				attenuation = _attenuation;
				minRadius = _minRadius;
				maxRadius = _maxRadius;
				gAudio3D = _audio3D;
				volume = _volume;

				GReturn result = GMusicImplementation::Create(_path, _audio3D, _volume);
				if (result != GReturn::SUCCESS)
					return result;

				auto audio3DImplementation = std::dynamic_pointer_cast<GW::I::GAudio3DImplementation>(*_audio3D);
				return gReceiver.Create(audio3DImplementation->gEventGen, [&]()
				{
					GW::GEvent event;
					if (+gReceiver.Pop(event))
					{
						GW::AUDIO::GAudio3D::Events audio3devent;
						if (+event.Read(audio3devent))
						{
							switch (audio3devent)
							{
								case GW::AUDIO::GAudio3D::Events::UPDATE_LISTENER:
								{
									GW::AUDIO::GAudio3D::EVENT_DATA eventData;
									event.Read(eventData);

									GW::MATH::GMATRIXF eventMatrix;
									GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
									eventMatrix.row4 = eventData.position;
									listener = eventMatrix;

									break;
								}
								case GW::AUDIO::GAudio3D::Events::UPDATE_TRANSFORM_AND_SPATIALIZE:
								{
									GW::AUDIO::GAudio3D::EVENT_DATA eventData;
									event.Read(eventData);

									GW::MATH::GMATRIXF eventMatrix;
									GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
									eventMatrix.row4 = eventData.position;
									transform = eventMatrix;

									Spatialize();
									break;
								}
								default:
									break;
							}
						}
					}
				});
			}

			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				position = _position;
				return Spatialize();
			}

			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				if (_minRadius > _maxRadius)
					return GReturn::INVALID_ARGUMENT;

				minRadius = _minRadius;
				maxRadius = _maxRadius;
				attenuation = _attenuation;

				return Spatialize();
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				return GMusicImplementation::SetVolume(volume);
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GMusicImplementation::SetChannelVolumes(_values, _numChannels); }
			GReturn Play(bool _loop = false) override { return GMusicImplementation::Play(_loop); }
			GReturn Pause() override { return GMusicImplementation::Pause(); }
			GReturn Resume() override { return GMusicImplementation::Resume(); }
			GReturn Stop() override { return GMusicImplementation::Stop(); }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GMusicImplementation::GetSourceChannels(_returnedChannelNum); }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GMusicImplementation::GetOutputChannels(_returnedChannelNum); }
			GReturn isPlaying(bool& _returnedBool) const override { return GMusicImplementation::isPlaying(_returnedBool); }
		};
	}
}


#endif


namespace GW
{
	namespace AUDIO
	{
		class GMusic3D final 
			: public I::GProxy<I::GMusic3DInterface, I::GMusic3DImplementation, const char*, float, float, GW::AUDIO::GATTENUATION, GW::AUDIO::GAudio3D>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMusic3D)
			GATEWARE_FUNCTION(UpdatePosition)
			GATEWARE_FUNCTION(UpdateAttenuation)

			// reimplemented from base class
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GMUSIC3D_H

/*---------------------------------
|	End of GMusic3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GBufferedInput.h
----------------------------------*/
#ifndef GBUFFEREDINPUT_H
#define GBUFFEREDINPUT_H






namespace GW
{
	namespace I
	{
		class GBufferedInputInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				Invalid,
				KEYPRESSED,
				KEYRELEASED,
				BUTTONPRESSED,
				BUTTONRELEASED,
				MOUSEMOVE,
				MOUSESCROLL
			};

			struct EVENT_DATA
			{
				int data;
				int x;
				int y;
				int screenX;
				int screenY;
				unsigned int keyMask;
			};
		};
	}
}

// Implementaion for GBufferedInput.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GBUFFEREDINPUT) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GBUFFEREDINPUT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation :	public virtual GBufferedInputInterface,
												public GEventGeneratorImplementation
		{
		public:
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
			GReturn Create(GW::SYSTEM::GWindow _window) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
		};
	}
}

#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_ESCAPE,			// 1
			G_KEY_1,				// 2
			G_KEY_2,				// 3
			G_KEY_3,				// 4
			G_KEY_4,				// 5
			G_KEY_5,				// 6
			G_KEY_6,				// 7
			G_KEY_7,				// 8
			G_KEY_8,				// 9
			G_KEY_9,				// 10
			G_KEY_0,				// 11
			G_KEY_MINUS,			// 12
			G_KEY_EQUALS,			// 13
			G_KEY_BACKSPACE,		// 14
			G_KEY_TAB,				// 15
			G_KEY_Q,				// 16
			G_KEY_W,				// 17
			G_KEY_E,				// 18
			G_KEY_R,				// 19
			G_KEY_T,				// 20
			G_KEY_Y,				// 21
			G_KEY_U,				// 22
			G_KEY_I,				// 23
			G_KEY_O,				// 24
			G_KEY_P,				// 25
			G_KEY_BRACKET_OPEN,		// 26
			G_KEY_BRACKET_CLOSE,	// 27
			G_KEY_ENTER,			// 28
			G_KEY_CONTROL,			// 29
			G_KEY_A,				// 30
			G_KEY_S,				// 31
			G_KEY_D,				// 32
			G_KEY_F,				// 33
			G_KEY_G,				// 34
			G_KEY_H,				// 35
			G_KEY_J,				// 36
			G_KEY_K,				// 37
			G_KEY_L,				// 38
			G_KEY_COLON,			// 39
			G_KEY_QUOTE,			// 40
			G_KEY_TILDE,			// 41
			G_KEY_LEFTSHIFT,		// 42
			G_KEY_BACKSLASH,		// 43
			G_KEY_Z,				// 44
			G_KEY_X,				// 45
			G_KEY_C,				// 46
			G_KEY_V,				// 47
			G_KEY_B,				// 48
			G_KEY_N,				// 49
			G_KEY_M,				// 50
			G_KEY_COMMA,			// 51
			G_KEY_PERIOD,			// 52
			G_KEY_FOWARDSLASH,		// 53
			G_KEY_RIGHTSHIFT,		// 54
			G_KEY_PRINTSCREEN,		// 55
			G_KEY_LEFTALT,			// 56
			G_KEY_SPACE,			// 57
			G_KEY_CAPSLOCK,			// 58
			G_KEY_F1,				// 59
			G_KEY_F2,				// 60
			G_KEY_F3,				// 61
			G_KEY_F4,				// 62
			G_KEY_F5,				// 63
			G_KEY_F6,				// 64
			G_KEY_F7,				// 65
			G_KEY_F8,				// 66
			G_KEY_F9,				// 67
			G_KEY_F10,				// 68
			G_KEY_NUMLOCK,			// 69
			G_KEY_SCROLL_LOCK,		// 70
			G_KEY_HOME,				// 71
			G_KEY_UP,				// 72
			G_KEY_PAGEUP,			// 73
			G_KEY_NUMPAD_MINUS,		// 74
			G_KEY_LEFT,				// 75
			G_KEY_CENTER,			// 76
			G_KEY_RIGHT,			// 77
			G_KEY_NUMPAD_PLUS,		// 78
			G_KEY_END,				// 79
			G_KEY_DOWN,				// 80
			G_KEY_PAGEDOWN,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_DELETE,			// 83
			G_KEY_UNKNOWN,			// 84
			G_KEY_UNKNOWN,			// 85
			G_KEY_UNKNOWN,			// 86
			G_KEY_F11,				// 87
			G_KEY_F12,				// 88
			G_KEY_UNKNOWN,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UNKNOWN,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_UNKNOWN,			// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_UNKNOWN,			// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_UNKNOWN,			// 115
			G_KEY_UNKNOWN,			// 116
			G_KEY_UNKNOWN,			// 117
			G_KEY_UNKNOWN,			// 118
			G_KEY_UNKNOWN,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_CONTROL,			// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_COLON,			// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FOWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_MULTIPLY,			// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_UNKNOWN,			// 78
			G_KEY_HOME,				// 79
			G_KEY_UP,				// 80
			G_KEY_PAGEUP,			// 81
			G_KEY_MINUS,			// 82
			G_KEY_LEFT,				// 83
			G_KEY_CENTER,			// 84
			G_KEY_RIGHT,			// 85
			G_KEY_ADD,				// 86
			G_KEY_END,				// 87
			G_KEY_DOWN,				// 88
			G_KEY_PAGEDOWN,			// 89
			G_KEY_INSERT,			// 90
			G_KEY_PERIOD,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96

			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_ENTER,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_DIVIDE,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_SCROLL_LOCK,		// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_COLON,			// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FOWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_CONTROL,			// 55
			G_KEY_LEFTSHIFT,		// 5
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_CONTROL,			// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_CONTROL,			// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_DELETE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_MULTIPLY,			// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_PLUS,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_UNKNOWN,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_DIVIDE,			// 75
			G_KEY_ENTER,			// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_MINUS,			// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_END,				// 83
			G_KEY_DOWN,				// 84
			G_KEY_PAGEDOWN,			// 85
			G_KEY_LEFT,				// 86
			G_KEY_CENTER,			// 87
			G_KEY_RIGHT,			// 88
			G_KEY_HOME,				// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UP,				// 91
			G_KEY_PAGEUP,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP				// 126
		};
#endif
	}
}
#endif



namespace GW
{
    namespace I
    {
        class GBufferedInputImplementation;
    }
}

namespace internal_gw
{
    // GResponder Interface

    // Data members of GResponder
    G_OBJC_DATA_MEMBERS_STRUCT(GResponder)
    {
        unsigned int keyMask;
        GW::I::GBufferedInputImplementation* pBufferedInput;
        GW::GEvent gevent;
        int lastMouseX = 0, lastMouseY = 0;
    };

    // Forward declarations of GResponder methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GResponder);

    G_OBJC_HEADER_INSTANCE_METHOD(GResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, bool, acceptsFirstMouse, NSEvent* event);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseMoved, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, scrollWheel, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetKeyMask, NSEvent* theEvent);

    // Creates the GResponder class at runtime when G_OBJC_GET_CLASS(GResponder) is called
    G_OBJC_CLASS_BEGIN(GResponder, NSResponder)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GResponder);

        G_OBJC_CLASS_METHOD(GResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, acceptsFirstMouse, "B@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, keyDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, keyUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseMoved, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, rightMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, rightMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, otherMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, otherMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, scrollWheel, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, GetKeyMask, "v@:@", :);
    }
    G_OBJC_CLASS_END(GResponder)

    // GResponder Interface End
}

namespace GW
{
    namespace I
    {
        class GBufferedInputImplementation :    public virtual GBufferedInputInterface,
                                                public GEventGeneratorImplementation
        {
        private:
            NSWindow* currentResponder;
            id responder = [internal_gw::G_OBJC_GET_CLASS(GResponder) alloc];
        public:
            ~GBufferedInputImplementation()
            {
                if (responder)
                {
                    [responder release] ;
                    responder = nil;
                }
            }

            GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
            {
                if (!_uwh.window)
                    return GReturn::INVALID_ARGUMENT;
                //Need to convert _data back into an NSWindow*.
                //NSWindow* currentResponder = ((__bridge NSWindow*)_data);
                currentResponder = ((__bridge NSWindow*)_uwh.window);

                //We only want to process the message and pass it on. So if there is already
                //a responder we set our responders next responder to be the current next responder.
                [responder setNextResponder : currentResponder.nextResponder];

                //We then set out responder to the next responder of the window.
                [currentResponder setNextResponder : responder] ;

                //We also need to make our responder the first responder of the window.
                [currentResponder makeFirstResponder : responder] ;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GResponder)& responderDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GResponder, responder);
                responderDataMembers.pBufferedInput = this;

                RUN_ON_UI_THREAD(^ {
                    //In order to get mouse button presses we need to set our responder to be
                    //The next responder in the contentView as well.
                    [currentResponder.contentView setNextResponder : responder] ;
                    });
                
                //Enable responder to accept mouse move events. By default it doesn't.
                [currentResponder setAcceptsMouseMovedEvents:YES];

                return GReturn::SUCCESS;
            }

            GReturn Create(GW::SYSTEM::GWindow _window)
            {
                if (!_window)
                    return GReturn::INVALID_ARGUMENT;

                GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
                GReturn code = _window.GetWindowHandle(uwh);
                if (G_FAIL(code))
                    return code;

                return Create(uwh);
            }
        };
    }
}

namespace internal_gw
{
    // GResponder Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GResponder);

    G_OBJC_HEADER_INSTANCE_METHOD(GResponder, bool, acceptFirstResponder) { return YES; }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, bool, acceptsFirstMouse, NSEvent* event) { return YES; }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        //Get the key from the static list of keys.
        _dataStruct.data = GW::I::Keycodes [[theEvent keyCode]];
        //Call the GetKeyMask Function passing the event passed to this functions.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        //Set the keymask.
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        //Get the mouse position relative to the screen.
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::KEYPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = GW::I::Keycodes [[theEvent keyCode]];
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::KEYRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_LEFT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]mouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_LEFT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]mouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseMoved, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_KEY_UNKNOWN;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        if ((_dataStruct.x - selfDataMembers.lastMouseX) != 0 ||
            (_dataStruct.y - selfDataMembers.lastMouseY) != 0)
        {
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(GW::I::GBufferedInputInterface::Events::MOUSEMOVE, _dataStruct);
            
            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            pBufferedInput->Push(gevent);
            
            selfDataMembers.lastMouseX = _dataStruct.x;
            selfDataMembers.lastMouseY = _dataStruct.y;
        }
        
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseMoved:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_RIGHT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_RIGHT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_MIDDLE;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_MIDDLE;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, scrollWheel, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = 0;
        //Check wether the its a scroll up or down event.
        if ([theEvent scrollingDeltaY] > 0)
        {
            _dataStruct.data = G_MOUSE_SCROLL_UP;
        }
        if ([theEvent scrollingDeltaY] < 0)
        {
            _dataStruct.data = G_MOUSE_SCROLL_DOWN;
        }
        //Get the keymask using the getkeymask function/
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        //Set the keymask.
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        NSPoint mousePosition = [theEvent locationInWindow];
        _dataStruct.x = mousePosition.x;
        _dataStruct.y = mousePosition.y;
        //Get the mouse position relative to the screen.
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        _dataStruct.screenX = screenMousePosition.x;
        _dataStruct.screenY = screenMousePosition.y;
        //Make sure theres data to send and send the data to all registered listeners.
        if (_dataStruct.data)
        {
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(GW::I::GBufferedInputInterface::Events::MOUSESCROLL, _dataStruct);

            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            pBufferedInput->Push(gevent);

        }
        if ([self nextResponder] != nil)
            [[self nextResponder]scrollWheel:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetKeyMask, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        unsigned int& keyMask = selfDataMembers.keyMask;
        keyMask = 0;
        //Get the unsigned int of all the modifier flags.
        NSUInteger flags = [theEvent modifierFlags];
        //Check individual modifier flags and turn them on respectivly to our keymask(unsigned int).
        if (flags & NSEventModifierFlagShift)
        {
            G_TURNON_BIT(keyMask, G_MASK_SHIFT);
        }
        if (flags & NSEventModifierFlagOption)
        {
            G_TURNON_BIT(keyMask, G_MASK_ALT);
        }
        if (flags & NSEventModifierFlagCommand)
        {
            G_TURNON_BIT(keyMask, G_MASK_COMMAND);
        }
        if (flags & NSEventModifierFlagControl)
        {
            G_TURNON_BIT(keyMask, G_MASK_CONTROL);
        }
        if (flags & NSEventModifierFlagCapsLock)
        {
            G_TURNON_BIT(keyMask, G_MASK_CAPS_LOCK);
        }
        if (flags & NSEventModifierFlagFunction)
        {
            G_TURNON_BIT(keyMask, G_MASK_FUNCTION);
        }
        if (flags & NSEventModifierFlagNumericPad)
        {
            G_TURNON_BIT(keyMask, G_MASK_NUM_LOCK);
        }
    }

    // GResponder Implementation End
}


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_ESCAPE,			// 1
			G_KEY_1,				// 2
			G_KEY_2,				// 3
			G_KEY_3,				// 4
			G_KEY_4,				// 5
			G_KEY_5,				// 6
			G_KEY_6,				// 7
			G_KEY_7,				// 8
			G_KEY_8,				// 9
			G_KEY_9,				// 10
			G_KEY_0,				// 11
			G_KEY_MINUS,			// 12
			G_KEY_EQUALS,			// 13
			G_KEY_BACKSPACE,		// 14
			G_KEY_TAB,				// 15
			G_KEY_Q,				// 16
			G_KEY_W,				// 17
			G_KEY_E,				// 18
			G_KEY_R,				// 19
			G_KEY_T,				// 20
			G_KEY_Y,				// 21
			G_KEY_U,				// 22
			G_KEY_I,				// 23
			G_KEY_O,				// 24
			G_KEY_P,				// 25
			G_KEY_BRACKET_OPEN,		// 26
			G_KEY_BRACKET_CLOSE,	// 27
			G_KEY_ENTER,			// 28
			G_KEY_CONTROL,			// 29
			G_KEY_A,				// 30
			G_KEY_S,				// 31
			G_KEY_D,				// 32
			G_KEY_F,				// 33
			G_KEY_G,				// 34
			G_KEY_H,				// 35
			G_KEY_J,				// 36
			G_KEY_K,				// 37
			G_KEY_L,				// 38
			G_KEY_COLON,			// 39
			G_KEY_QUOTE,			// 40
			G_KEY_TILDE,			// 41
			G_KEY_LEFTSHIFT,		// 42
			G_KEY_BACKSLASH,		// 43
			G_KEY_Z,				// 44
			G_KEY_X,				// 45
			G_KEY_C,				// 46
			G_KEY_V,				// 47
			G_KEY_B,				// 48
			G_KEY_N,				// 49
			G_KEY_M,				// 50
			G_KEY_COMMA,			// 51
			G_KEY_PERIOD,			// 52
			G_KEY_FOWARDSLASH,		// 53
			G_KEY_RIGHTSHIFT,		// 54
			G_KEY_PRINTSCREEN,		// 55
			G_KEY_LEFTALT,			// 56
			G_KEY_SPACE,			// 57
			G_KEY_CAPSLOCK,			// 58
			G_KEY_F1,				// 59
			G_KEY_F2,				// 60
			G_KEY_F3,				// 61
			G_KEY_F4,				// 62
			G_KEY_F5,				// 63
			G_KEY_F6,				// 64
			G_KEY_F7,				// 65
			G_KEY_F8,				// 66
			G_KEY_F9,				// 67
			G_KEY_F10,				// 68
			G_KEY_NUMLOCK,			// 69
			G_KEY_SCROLL_LOCK,		// 70
			G_KEY_HOME,				// 71
			G_KEY_UP,				// 72
			G_KEY_PAGEUP,			// 73
			G_KEY_NUMPAD_MINUS,		// 74
			G_KEY_LEFT,				// 75
			G_KEY_CENTER,			// 76
			G_KEY_RIGHT,			// 77
			G_KEY_NUMPAD_PLUS,		// 78
			G_KEY_END,				// 79
			G_KEY_DOWN,				// 80
			G_KEY_PAGEDOWN,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_DELETE,			// 83
			G_KEY_UNKNOWN,			// 84
			G_KEY_UNKNOWN,			// 85
			G_KEY_UNKNOWN,			// 86
			G_KEY_F11,				// 87
			G_KEY_F12,				// 88
			G_KEY_UNKNOWN,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UNKNOWN,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_UNKNOWN,			// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_UNKNOWN,			// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_UNKNOWN,			// 115
			G_KEY_UNKNOWN,			// 116
			G_KEY_UNKNOWN,			// 117
			G_KEY_UNKNOWN,			// 118
			G_KEY_UNKNOWN,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_CONTROL,			// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_COLON,			// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FOWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_MULTIPLY,			// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_UNKNOWN,			// 78
			G_KEY_HOME,				// 79
			G_KEY_UP,				// 80
			G_KEY_PAGEUP,			// 81
			G_KEY_MINUS,			// 82
			G_KEY_LEFT,				// 83
			G_KEY_CENTER,			// 84
			G_KEY_RIGHT,			// 85
			G_KEY_ADD,				// 86
			G_KEY_END,				// 87
			G_KEY_DOWN,				// 88
			G_KEY_PAGEDOWN,			// 89
			G_KEY_INSERT,			// 90
			G_KEY_PERIOD,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96

			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_ENTER,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_DIVIDE,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_SCROLL_LOCK,		// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_COLON,			// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FOWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_CONTROL,			// 55
			G_KEY_LEFTSHIFT,		// 5
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_CONTROL,			// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_CONTROL,			// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_DELETE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_MULTIPLY,			// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_PLUS,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_UNKNOWN,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_DIVIDE,			// 75
			G_KEY_ENTER,			// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_MINUS,			// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_END,				// 83
			G_KEY_DOWN,				// 84
			G_KEY_PAGEDOWN,			// 85
			G_KEY_LEFT,				// 86
			G_KEY_CENTER,			// 87
			G_KEY_RIGHT,			// 88
			G_KEY_HOME,				// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UP,				// 91
			G_KEY_PAGEUP,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP				// 126
		};
#endif
	}
}
#endif




namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation :	public virtual GBufferedInputInterface,
												public GEventGeneratorImplementation
		{
		private:
			unsigned int keyMask;
			Display* display = nullptr;
			Window window = 0;
			GW::SYSTEM::GDaemon inputDaemon;
			GW::CORE::GEventReceiver watcher;
			unsigned int keyStates[256]; // 1 for on, 0 for off
			unsigned int buttonStates[32]; // 1 for on, 0 for off
			int lastMouseX = 0, lastMouseY = 0;
		public:
			~GBufferedInputImplementation()
			{
				inputDaemon = nullptr;
			}
			
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
			{
				if (!_uwh.window || !_uwh.display)
					return GReturn::INVALID_ARGUMENT;
					
				window = *((Window*)(_uwh.window));
				display = ((Display*)(_uwh.display));
				keyMask = 0;
				
				XInitThreads();// daemon run on another thread
				return inputDaemon.Create(G_BUFFEREDINPUT_OPERATION_INTERVAL, [&]()
				{
					int _code = -1;
					GEvent m_GEvent;
					Events m_Event = Events::Invalid;
					EVENT_DATA m_EventData;
					Window a, b;
					
					LockAsyncRead();
					XQueryPointer(display, window, &a, &b, &m_EventData.screenX, &m_EventData.screenY, &m_EventData.x, &m_EventData.y, &m_EventData.keyMask);

					char keys_return[32];
					//Get the current state of all keys.
					XQueryKeymap(display, keys_return);
					UnlockAsyncRead();
					//Loop through all the keys and check to see if they match the saved state of all the keys.
					for (unsigned int i = 5; i < 126; ++i) 
					{
						m_EventData.data = Keycodes[i];
						//Save the state of current key.
						unsigned int key = keys_return[(i >> 3)] & (1 << (i & 7));
						//If a key does not match send an event saying it has been updated.
						if (key != keyStates[m_EventData.data]) 
						{
							if (key == 0) 
							{
								m_Event = Events::KEYRELEASED;
							}
							else
							{
								m_Event = Events::KEYPRESSED;
							}
							
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
							keyStates[m_EventData.data] = key;
						}
					}

					if (m_EventData.keyMask & Button1Mask) 
					{
						if (!keyStates[G_BUTTON_LEFT]) 
						{
							m_EventData.data = G_BUTTON_LEFT;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_LEFT] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_LEFT]) 
						{
							m_EventData.data = G_BUTTON_LEFT;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_LEFT] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					
					if (m_EventData.keyMask & Button2Mask) 
					{
						if (!keyStates[G_BUTTON_MIDDLE]) 
						{
							m_EventData.data = G_BUTTON_MIDDLE;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_MIDDLE] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_MIDDLE]) 
						{
							m_EventData.data = G_BUTTON_MIDDLE;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_MIDDLE] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
		
					if (m_EventData.keyMask & Button3Mask) 
					{
						if (!keyStates[G_BUTTON_RIGHT]) 
						{
							m_EventData.data = G_BUTTON_RIGHT;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_RIGHT] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_RIGHT]) 
						{
							m_EventData.data = G_BUTTON_RIGHT;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_RIGHT] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					
					if ((m_EventData.x - lastMouseX) != 0 || (m_EventData.y - lastMouseY) != 0)
					{
						m_EventData.data = G_KEY_UNKNOWN;
						m_Event = Events::MOUSEMOVE;
						//Send the event to all registered listeners.
						m_GEvent.Write(m_Event, m_EventData);
						Push(m_GEvent);
						
						lastMouseX = m_EventData.x;
						lastMouseY = m_EventData.y;
					}					
				});
			}
			
			GReturn Create(GW::SYSTEM::GWindow _window)
			{
				if (!_window)
					return GReturn::INVALID_ARGUMENT;

				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
				GReturn code = _window.GetWindowHandle(uwh);
				if (G_FAIL(code))
					return code;

				// stop if window is killed
				watcher.Create(_window, [&](){
					if (+watcher.Find(GW::SYSTEM::GWindow::Events::DESTROY, true))
						inputDaemon = nullptr;
				});
				
				return Create(uwh);
			}
		};
	}
}

#elif defined(_WIN32)
    #include <map>
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_ESCAPE,			// 1
			G_KEY_1,				// 2
			G_KEY_2,				// 3
			G_KEY_3,				// 4
			G_KEY_4,				// 5
			G_KEY_5,				// 6
			G_KEY_6,				// 7
			G_KEY_7,				// 8
			G_KEY_8,				// 9
			G_KEY_9,				// 10
			G_KEY_0,				// 11
			G_KEY_MINUS,			// 12
			G_KEY_EQUALS,			// 13
			G_KEY_BACKSPACE,		// 14
			G_KEY_TAB,				// 15
			G_KEY_Q,				// 16
			G_KEY_W,				// 17
			G_KEY_E,				// 18
			G_KEY_R,				// 19
			G_KEY_T,				// 20
			G_KEY_Y,				// 21
			G_KEY_U,				// 22
			G_KEY_I,				// 23
			G_KEY_O,				// 24
			G_KEY_P,				// 25
			G_KEY_BRACKET_OPEN,		// 26
			G_KEY_BRACKET_CLOSE,	// 27
			G_KEY_ENTER,			// 28
			G_KEY_CONTROL,			// 29
			G_KEY_A,				// 30
			G_KEY_S,				// 31
			G_KEY_D,				// 32
			G_KEY_F,				// 33
			G_KEY_G,				// 34
			G_KEY_H,				// 35
			G_KEY_J,				// 36
			G_KEY_K,				// 37
			G_KEY_L,				// 38
			G_KEY_COLON,			// 39
			G_KEY_QUOTE,			// 40
			G_KEY_TILDE,			// 41
			G_KEY_LEFTSHIFT,		// 42
			G_KEY_BACKSLASH,		// 43
			G_KEY_Z,				// 44
			G_KEY_X,				// 45
			G_KEY_C,				// 46
			G_KEY_V,				// 47
			G_KEY_B,				// 48
			G_KEY_N,				// 49
			G_KEY_M,				// 50
			G_KEY_COMMA,			// 51
			G_KEY_PERIOD,			// 52
			G_KEY_FOWARDSLASH,		// 53
			G_KEY_RIGHTSHIFT,		// 54
			G_KEY_PRINTSCREEN,		// 55
			G_KEY_LEFTALT,			// 56
			G_KEY_SPACE,			// 57
			G_KEY_CAPSLOCK,			// 58
			G_KEY_F1,				// 59
			G_KEY_F2,				// 60
			G_KEY_F3,				// 61
			G_KEY_F4,				// 62
			G_KEY_F5,				// 63
			G_KEY_F6,				// 64
			G_KEY_F7,				// 65
			G_KEY_F8,				// 66
			G_KEY_F9,				// 67
			G_KEY_F10,				// 68
			G_KEY_NUMLOCK,			// 69
			G_KEY_SCROLL_LOCK,		// 70
			G_KEY_HOME,				// 71
			G_KEY_UP,				// 72
			G_KEY_PAGEUP,			// 73
			G_KEY_NUMPAD_MINUS,		// 74
			G_KEY_LEFT,				// 75
			G_KEY_CENTER,			// 76
			G_KEY_RIGHT,			// 77
			G_KEY_NUMPAD_PLUS,		// 78
			G_KEY_END,				// 79
			G_KEY_DOWN,				// 80
			G_KEY_PAGEDOWN,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_DELETE,			// 83
			G_KEY_UNKNOWN,			// 84
			G_KEY_UNKNOWN,			// 85
			G_KEY_UNKNOWN,			// 86
			G_KEY_F11,				// 87
			G_KEY_F12,				// 88
			G_KEY_UNKNOWN,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UNKNOWN,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_UNKNOWN,			// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_UNKNOWN,			// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_UNKNOWN,			// 115
			G_KEY_UNKNOWN,			// 116
			G_KEY_UNKNOWN,			// 117
			G_KEY_UNKNOWN,			// 118
			G_KEY_UNKNOWN,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_CONTROL,			// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_COLON,			// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FOWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_MULTIPLY,			// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_UNKNOWN,			// 78
			G_KEY_HOME,				// 79
			G_KEY_UP,				// 80
			G_KEY_PAGEUP,			// 81
			G_KEY_MINUS,			// 82
			G_KEY_LEFT,				// 83
			G_KEY_CENTER,			// 84
			G_KEY_RIGHT,			// 85
			G_KEY_ADD,				// 86
			G_KEY_END,				// 87
			G_KEY_DOWN,				// 88
			G_KEY_PAGEDOWN,			// 89
			G_KEY_INSERT,			// 90
			G_KEY_PERIOD,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96

			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_ENTER,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_DIVIDE,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_SCROLL_LOCK,		// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_COLON,			// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FOWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_CONTROL,			// 55
			G_KEY_LEFTSHIFT,		// 5
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_CONTROL,			// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_CONTROL,			// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_DELETE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_MULTIPLY,			// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_PLUS,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_UNKNOWN,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_DIVIDE,			// 75
			G_KEY_ENTER,			// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_MINUS,			// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_END,				// 83
			G_KEY_DOWN,				// 84
			G_KEY_PAGEDOWN,			// 85
			G_KEY_LEFT,				// 86
			G_KEY_CENTER,			// 87
			G_KEY_RIGHT,			// 88
			G_KEY_HOME,				// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UP,				// 91
			G_KEY_PAGEUP,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP				// 126
		};
#endif
	}
}
#endif

#include <vector>

namespace internal_gw
{
	struct GBUFFEREDINPUT_GLOBAL
	{
		unsigned int keyMask = 0;
		LONG_PTR _userWinProc = 0;
		POINT lastMousePosition = { 0, 0 };
		GW::CORE::GEventGenerator keyEvents;
		GBUFFEREDINPUT_GLOBAL() {
			keyEvents.Create();
		}
	};
	static GBUFFEREDINPUT_GLOBAL& GBufferedInputGlobal()
	{
		static GBUFFEREDINPUT_GLOBAL gdata;
		return gdata;
	}
}

namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation : public virtual GBufferedInputInterface
		{
		private:
			HWND wndHandle = nullptr;
			
			static LRESULT CALLBACK GWindowProcedure(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				switch (uMsg)
				{
				case WM_INPUT:
				{
					GEvent m_GEvent;
					Events m_Event = Events::Invalid;
					EVENT_DATA m_EventData;

					POINT p;
					if (GetCursorPos(&p))
					{
						m_EventData.screenX = p.x;
						m_EventData.screenY = p.y;
					}
					if (ScreenToClient(hWnd, &p))
					{
						m_EventData.x = p.x;
						m_EventData.y = p.y;
					}

					UINT dwSize = 0;
					unsigned int keyMask = internal_gw::GBufferedInputGlobal().keyMask;
					//Get the size of RawInput
					GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));
					LPBYTE lpb = new BYTE[dwSize];
					if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
					{
						delete[] lpb;
						break;
					}

					RAWINPUT* raw = (RAWINPUT*)lpb;
					m_Event = Events::Invalid;
					m_EventData.data = -1;

					if (raw->header.dwType == RIM_TYPEKEYBOARD)
					{
						//Get G_KEY
						m_EventData.data = Keycodes[raw->data.keyboard.MakeCode];

						//Set state released or pressed.
						switch (raw->data.keyboard.Message) {
						case 256:
							m_Event = Events::KEYPRESSED;
							switch (m_EventData.data) {
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNON_BIT(keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_CONTROL:
								G_TURNON_BIT(keyMask, G_MASK_CONTROL);
								break;
							case G_KEY_CAPSLOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_CAPS_LOCK);
								break;
							case G_KEY_NUMLOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_NUM_LOCK);
								break;
							case G_KEY_SCROLL_LOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_SCROLL_LOCK);
								break;
							}
							break;
						case 257:
							m_Event = Events::KEYRELEASED;
							switch (m_EventData.data) {
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNOFF_BIT(keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_CONTROL:
								G_TURNOFF_BIT(keyMask, G_MASK_CONTROL);
								break;
							}
							break;
						}
					}
					else if (raw->header.dwType == RIM_TYPEMOUSE)
					{
						//Mouse button events and movement events can occur at the same time.
						switch (raw->data.mouse.usFlags) {
							//Mouse Move
						case 0:
						case 1:
							//Check if the mouse position changed by at least a pixel amount, we don't want to send messages for sub-pixel change.
							if ((m_EventData.x - internal_gw::GBufferedInputGlobal().lastMousePosition.x) != 0 ||
								(m_EventData.y - internal_gw::GBufferedInputGlobal().lastMousePosition.y) != 0)
							{
								m_EventData.data = G_KEY_UNKNOWN;
								m_EventData.keyMask = keyMask;

								m_Event = Events::MOUSEMOVE;
								m_GEvent.Write(m_Event, m_EventData);
								internal_gw::GBufferedInputGlobal().keyEvents.Push(m_GEvent);

								internal_gw::GBufferedInputGlobal().lastMousePosition = { m_EventData.x, m_EventData.y };
							}
							break;
						}

						//Set Code
						switch (raw->data.mouse.ulButtons) {
						case 1:
						case 2:
							m_EventData.data = G_BUTTON_LEFT;
							break;
						case 4:
						case 8:
							m_EventData.data = G_BUTTON_RIGHT;
							break;
						case 16:
						case 32:
							m_EventData.data = G_BUTTON_MIDDLE;
							break;
						}

						switch (raw->data.mouse.usButtonData) {
						case 120:
							m_EventData.data = G_MOUSE_SCROLL_UP;
							break;
						case 65416:
							m_EventData.data = G_MOUSE_SCROLL_DOWN;
							break;
						}

						switch (raw->data.mouse.usButtonFlags) {
							//Mouse Pressed
						case 1:
						case 4:
						case 16:
							m_Event = Events::BUTTONPRESSED;
							break;
							//Mouse Released
						case 2:
						case 8:
						case 32:
							m_Event = Events::BUTTONRELEASED;
							break;
							//Scroll
						case 1024:
							m_Event = Events::MOUSESCROLL;
							break;
						}
					}

					//If the mouse move event was the only event, don't send it again.
					if (m_Event != Events::MOUSEMOVE)
					{
						internal_gw::GBufferedInputGlobal().keyMask = keyMask;
						m_EventData.keyMask = keyMask;

						m_GEvent.Write(m_Event, m_EventData);
						if (m_Event != Events::Invalid)
							internal_gw::GBufferedInputGlobal().keyEvents.Push(m_GEvent);
					}

					delete[] lpb;
				}
				break;

				default:
					break;
				}
				return CallWindowProcW((WNDPROC)internal_gw::GBufferedInputGlobal()._userWinProc, hWnd, uMsg, wParam, lParam);
			}
		public:
			~GBufferedInputImplementation()
			{
				if (wndHandle)
					//Sets the WinProc back. (Fixes the StackOverFlow bug)
					SetWindowLongPtr(wndHandle, GWLP_WNDPROC, (LONG_PTR)internal_gw::GBufferedInputGlobal()._userWinProc);
			}
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
			{
				if (!_uwh.window)
					return GReturn::INVALID_ARGUMENT;

				wndHandle = static_cast<HWND>(_uwh.window);
				if ((internal_gw::GBufferedInputGlobal()._userWinProc = 
					SetWindowLongPtr(wndHandle, GWLP_WNDPROC, (LONG_PTR)GWindowProcedure)) == NULL)
				{
					//The user has not setup a windows proc prior to this point.
					printf("SetWindowLongPtr Error : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				//Getting Raw Input Devices.
				UINT numDevices = 0;
				std::vector<RAWINPUTDEVICELIST> rawInputDeviceList;

				//Get Number of Devices.
				if (GetRawInputDeviceList(NULL, &numDevices, sizeof(RAWINPUTDEVICELIST)) == ((UINT)-1))
				{
					printf("GetRawInputDeviceList Error : %d \n", GetLastError());
					//If GetRawInputDeviceList returned 0 devices, following calls will fail.
					if (numDevices == 0)
					{
						printf("Zero devices returned from GetRawInputDeviceList.");
					}
					return GReturn::FAILURE;
				}

				//Allocate the list of devices.
				rawInputDeviceList.resize(sizeof(RAWINPUTDEVICELIST) * numDevices);
				if (rawInputDeviceList.size() < 1) {
					printf("Failed to allocate memory for RawInputDeviceList.");
					return GReturn::FAILURE;
				}

				int nNoOfDevices = 0;
				//Using the new List and number of devices,
				//populate the raw input device list.
				if ((nNoOfDevices = GetRawInputDeviceList(rawInputDeviceList.data(), &numDevices, sizeof(RAWINPUTDEVICELIST))) == ((UINT)-1))
				{
					printf("GetRawInputDeviceList Error : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				RID_DEVICE_INFO rdi;
				rdi.cbSize = sizeof(RID_DEVICE_INFO);

				//For all of the devices, display their correspondent information.
				for (int i = 0; i < nNoOfDevices; i++)
				{
					UINT size = 256;
					TCHAR tBuffer[256] = { 0 };
					tBuffer[0] = '\0';

					//Find the device name.
					if (!rawInputDeviceList.empty())
					{
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICENAME, tBuffer, &size) < 0)
							return GW::GReturn::FAILURE;

						UINT cbSize = rdi.cbSize;
						//Get the device information.
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICEINFO, &rdi, &cbSize) < 0)
							return GW::GReturn::FAILURE;
					}
				}

				//Register the raw input devices.
				RAWINPUTDEVICE rID[2];

				//KeyBoard
				rID[0].usUsagePage = 0x01;
				rID[0].usUsage = 0x06;
				rID[0].dwFlags = RIDEV_EXINPUTSINK;
				rID[0].hwndTarget = wndHandle;

				//Mouse
				rID[1].usUsagePage = 0x01;
				rID[1].usUsage = 0x02;
				rID[1].dwFlags = RIDEV_EXINPUTSINK;
				rID[1].hwndTarget = wndHandle;

				if (RegisterRawInputDevices(rID, 2, sizeof(rID[0])) == false)
				{
					printf("RegisterRawInputDevices Error: %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				//Capslock
				if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_CAPS_LOCK);
				}

				//Numlock
				if ((GetKeyState(VK_NUMLOCK) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_NUM_LOCK);
				}

				//ScrollLock
				if ((GetKeyState(VK_SCROLL) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_SCROLL_LOCK);
				}

				return GReturn::SUCCESS;
			}

			GReturn Create(GW::SYSTEM::GWindow _window)
			{
				if (!_window)
					return GReturn::INVALID_ARGUMENT;

				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
				GReturn code = _window.GetWindowHandle(uwh);
				if (G_FAIL(code))
					return code;

				return Create(uwh);
			}
			// transfer any receivers to internal global broadcaster
			GReturn Register(CORE::GEventCache _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Push(_newEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace INPUT
	{
		class GBufferedInput final
			: public I::GProxy<I::GBufferedInputInterface, I::GBufferedInputImplementation, GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GBufferedInput)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)

			// reimplemented functions
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GBUFFEREDINPUT_H

/*---------------------------------
|	End of GBufferedInput.h
----------------------------------*/


/*---------------------------------
|	Begin of GController.h
----------------------------------*/
#ifndef GCONTROLLER_H
#define GCONTROLLER_H





namespace GW
{
	namespace I
	{
		class GControllerInterface : public virtual GEventGeneratorInterface
		{
		public:
			struct EVENT_DATA
			{
				int controllerIndex;
				GW::INPUT::GControllerType controllerID;
				int inputCode;
				float inputValue;
				int isConnected;
			};

			enum class Events
			{
				CONTROLLERBUTTONVALUECHANGED,
				CONTROLLERAXISVALUECHANGED,	
				CONTROLLERCONNECTED,		
				CONTROLLERDISCONNECTED		
			};

			enum class DeadZoneTypes
			{
				DEADZONESQUARE,
				DEADZONECIRCLE
			};

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) = 0;
			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) = 0;
			virtual GReturn GetMaxIndex(int& _outMax) = 0;
			virtual GReturn GetNumConnected(int& _outConnectedCount) = 0;
			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) = 0;
			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) = 0;
			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) = 0;
			virtual GReturn StopVibration(unsigned int _controllerIndex) = 0;
			virtual GReturn StopAllVibrations() = 0;
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GController.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#ifndef GCONTROLLERTABLEROUTING_HPP
#define GCONTROLLERTABLEROUTING_HPP


#define G_MAX_CONTROLLER_INDEX 16
#define G_MAX_XBOX_CONTROLLER_INDEX 4
#define G_MAX_GENERAL_INPUTS 20
#define G_MAX_XBOX_INPUTS 20
#define G_MAX_PS4_INPUTS 20
#define G_MAX_XBOX_THUMB_AXIS 32768
#define G_MIN_XBOX_THUMB_AXIS -32768
#define G_MAX_XBOX_TRIGGER_AXIS 255
#define G_XINPUT_MAX_VIBRATION 65535
#define G_MAX_LINUX_THUMB_AXIS 32768
#define G_MAX_GENERAL_TRIGGER_AXIS 255
#define G_GENERAL_TRIGGER_THRESHOLD 51

#define G_MAX_AXIS 0
#define G_MIN_AXIS 1

#define G_SONY_VENDOR_ID 0x054C
#define G_MICROSOFT_VENDOR_ID 0x045E

#define G_CODE_MAPPING_GENERAL 0
#define G_CODE_MAPPING_PS4_WIRED 1
#define G_CODE_MAPPING_PS4_WIRELESS 1
#define G_CODE_MAPPING_XBOX360 0
#define G_CODE_MAPPING_XBOXONE_WIRED 0
#define G_CODE_MAPPING_XBOXONE_WIRELESS 2

#define G_MAC_AXIS_MAPPING_GENERAL 0
#define G_MAC_AXIS_MAPPING_PS4_WIRED 2
#define G_MAC_AXIS_MAPPING_PS4_WIRELESS 0
#define G_MAC_AXIS_MAPPING_XBOX360 1
#define G_MAC_AXIS_MAPPING_XBOXONE_WIRED 1
#define G_MAC_AXIS_MAPPING_XBOXONE_WIRELESS 3

#define G_LINUX_AXIS_MAPPING_GENERAL 0
#define G_LINUX_AXIS_MAPPING_PS4_WIRED 0
#define G_LINUX_AXIS_MAPPING_PS4_WIRELESS 0
#define G_LINUX_AXIS_MAPPING_XBOX360 1
#define G_LINUX_AXIS_MAPPING_XBOXONE_WIRED 3
#define G_LINUX_AXIS_MAPPING_XBOXONE_WIRELESS 2

namespace GW
{
	namespace I
	{
		// Routes GController inputs (defined in GInputDefines.h) to the corresponding column in ControllerAxisRangesMin/Max tables.
        constexpr int ControllerAxisOffsets[] =
        {
            -1, // 0
			-1, // 1
			-1, // 2
			-1, // 3
			-1, // 4	
			-1, // 5
			0,  // 6 G_LEFT_TRIGGER_AXIS	
			1,  // 7 G_RIGHT_TRIGGER_AXIS
			-1, // 8
			-1, // 9
			-1, // 10
			-1, // 11
			-1, // 12
			-1, // 13
			-1, // 14
			-1, // 15
			2,  // 16 G_LX_AXIS			
			3,  // 17 G_LY_AXIS			
			4,  // 18 G_RX_AXIS			
			5   // 19 G_RY_AXIS			
		};
        
		
		// Mac tables
        
        constexpr float Mac_ControllerAxisRangesMax[][6] =
        {
            //G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
            { 255.0f,               255.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // General & PS4 Wireless
            { 255.0f,               255.0f,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox 360 & Xbox One Wired
            { 315.0f,               315.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // PS4 Wired
            { 1023.0,               1023.0,                65535.0f,   65535.0f,   65535.0f,   65535.0f  }, // Xbox One Wireless
        };
            
        constexpr float Mac_ControllerAxisRangesMin[][6] =
        {
            //G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
            { 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // General & PS4 Wireless
            { 255.0f,               255.0f,                -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox 360 & Xbox One Wired
            { 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // PS4 Wired
            { 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // Xbox One Wireless
        };

		// Routes usage codes (defined in IOHIDUsageTables.h on Mac) to GController input.
		constexpr unsigned int Mac_ControllerCodes[][3] =
		{
			//General, Xbox 360 & Xbox One Wired    PS4                    Xbox One Wireless
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 0
		  { G_SOUTH_BTN,                            G_WEST_BTN,            G_SOUTH_BTN            }, // 1
		  { G_EAST_BTN,                             G_SOUTH_BTN,           G_EAST_BTN             }, // 2
		  { G_WEST_BTN,                             G_EAST_BTN,            G_UNKOWN_INPUT         }, // 3
		  { G_NORTH_BTN,                            G_NORTH_BTN,           G_WEST_BTN             }, // 4
		  { G_LEFT_SHOULDER_BTN,                    G_LEFT_SHOULDER_BTN,   G_NORTH_BTN            }, // 5
		  { G_RIGHT_SHOULDER_BTN,                   G_RIGHT_SHOULDER_BTN,  G_UNKOWN_INPUT         }, // 6
		  { G_LEFT_THUMB_BTN,                       G_UNKOWN_INPUT,        G_LEFT_SHOULDER_BTN    }, // 7
		  { G_RIGHT_THUMB_BTN,                      G_UNKOWN_INPUT,        G_RIGHT_SHOULDER_BTN   }, // 8
		  { G_START_BTN,                            G_SELECT_BTN,          G_UNKOWN_INPUT         }, // 9
		  { G_SELECT_BTN,                           G_START_BTN,           G_UNKOWN_INPUT         }, // 10
		  { G_UNKOWN_INPUT,                         G_LEFT_THUMB_BTN,      G_UNKOWN_INPUT         }, // 11
		  { G_DPAD_UP_BTN,                          G_RIGHT_THUMB_BTN,     G_START_BTN            }, // 12
		  { G_DPAD_DOWN_BTN,                        G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 13
		  { G_DPAD_LEFT_BTN,                        G_UNKOWN_INPUT,        G_LEFT_THUMB_BTN       }, // 14
		  { G_DPAD_RIGHT_BTN,                       G_UNKOWN_INPUT,        G_RIGHT_THUMB_BTN      }, // 15
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 16
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 17
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 18
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 19
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 20
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 21
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 22
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 23
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 24
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 25
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 26
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 27
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 28
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 29
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 30
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 31
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 32
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 33
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 34
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 35
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 36
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 37
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 38
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 39
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 40
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 41
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 42
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 43
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 44
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 45
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 46
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 47
		  { G_LX_AXIS,                              G_LX_AXIS,             G_LX_AXIS              }, // 48
		  { G_LY_AXIS,                              G_LY_AXIS,             G_LY_AXIS              }, // 49
		  { G_LEFT_TRIGGER_AXIS,                    G_RX_AXIS,             G_RX_AXIS              }, // 50
		  { G_RX_AXIS,                              G_LEFT_TRIGGER_AXIS,   G_UNKOWN_INPUT         }, // 51
		  { G_RY_AXIS,                              G_RIGHT_TRIGGER_AXIS,  G_UNKOWN_INPUT         }, // 52
		  { G_RIGHT_TRIGGER_AXIS,                   G_RY_AXIS,             G_RY_AXIS              }, // 53
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 54
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 55
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 56
		  { G_UNKOWN_INPUT,                         G_DPAD_LEFT_BTN,       G_DPAD_LEFT_BTN        }, // 57 /* Dpad value reported as 0-360, 0-8, or 0-315 & -45 */
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 58
		  { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 59
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 60
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 61
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 62
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 63
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 64
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 65
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 66
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 67
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 68
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 69
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 70
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 71
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 72
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 73
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 74
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 75
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 76
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 77
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 78
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 79
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 80
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 81
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 82
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 83
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 84
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 85
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 86
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 87
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 88
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 89
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 90
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 91
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 92
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 93
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 94
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 95
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 96
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 97
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 98
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 99
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 100
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 101
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 102
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 103
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 104
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 105
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 106
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 107
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 108
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 109
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 110
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 111
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 112
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 113
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 114
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 115
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 116
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 117
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 118
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 119
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 120
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 121
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 122
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 123
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 124
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 125
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 126
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 127
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 128
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 129
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 130
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 131
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 132
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 133
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 134
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 135
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 136
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 137
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 138
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 139
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 140
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 141
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 142
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 143
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 144
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 145
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 146
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 147
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 148
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 149
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 150
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 151
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 152
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 153
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 154
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 155
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 156
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 157
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 158
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 159
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 160
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 161
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 162
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 163
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 164
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 165
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 166
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 167
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 168
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 169
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 170
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 171
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 172
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 173
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 174
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 175
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 176
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 177
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 178
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 179
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 180
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 181
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 182
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 183
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 184
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 185
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 186
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 187
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 188
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 189
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 190
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 191
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 192
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 193
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 194
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 195
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_RIGHT_TRIGGER_AXIS   }, // 196
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_LEFT_TRIGGER_AXIS    }, // 197
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 198
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 199
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 200
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 201
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 202
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 203
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 204
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 205
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 206
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 207
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 208
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 209
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 210
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 211
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 212
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 213
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 214
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 215
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 216
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 217
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 218
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 219
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 220
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 221
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 222
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 223
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 224
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 225
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 226
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 227
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 228
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 229
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 230
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 231
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 232
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 233
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 234
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 235
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 236
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 237
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 238
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 239
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 240
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 241
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 242
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 243
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 244
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 245
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 246
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 247
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 248
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 249
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 250
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 251
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 252
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 253
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 254
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 255
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 256
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 257
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 258
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 259
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 260
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 261
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 262
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 263
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 264
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 265
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 266
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 267
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 268
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 269
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 270
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 271
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 272
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 273
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 274
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 275
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 276
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 277
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 278
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 279
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 280
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 281
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 282
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 283
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 284
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 285
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 286
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 287
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 288
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 289
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 290
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 291
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 292
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 293
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 294
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 295
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 296
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 297
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 298
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 299
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 300
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 301
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 302
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 303
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 304
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 305
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 306
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 307
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 308
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 309
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 310
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 311
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 312
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 313
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 314
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 315
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 316
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 317
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 318
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 319
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 320
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 321
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 322
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 323
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 324
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 325
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 326
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 327
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 328
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 329
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 330
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 331
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 332
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 333
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 334
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 335
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 336
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 337
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 338
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 339
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 340
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 341
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 342
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 343
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 344
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 345
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 346
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 347
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 348
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 349
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 350
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 351
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 352
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 353
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 354
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 355
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 356
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 357
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 358
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 359
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 360
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 361
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 362
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 363
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 364
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 365
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 366
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 367
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 368
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 369
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 370
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 371
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 372
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 373
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 374
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 375
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 376
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 377
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 378
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 379
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 380
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 381
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 382
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 383
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 384
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 385
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 386
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 387
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 388
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 389
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 390
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 391
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 392
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 393
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 394
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 395
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 396
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 397
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 398
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 399
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 400
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 401
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 402
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 403
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 404
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 405
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 406
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 407
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 408
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 409
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 410
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 411
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 412
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 413
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 414
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 415
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 416
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 417
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 418
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 419
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 420
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 421
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 422
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 423
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 424
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 425
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 426
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 427
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 428
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 429
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 430
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 431
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 432
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 433
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 434
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 435
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 436
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 437
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 438
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 439
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 440
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 441
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 442
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 443
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 444
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 445
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 446
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 447
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 448
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 449
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 450
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 451
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 452
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 453
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 454
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 455
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 456
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 457
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 458
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 459
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 460
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 461
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 462
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 463
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 464
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 465
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 466
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 467
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 468
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 469
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 470
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 471
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 472
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 473
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 474
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 475
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 476
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 477
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 478
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 479
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 480
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 481
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 482
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 483
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 484
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 485
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 486
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 487
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 488
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 489
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 490
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 491
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 492
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 493
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 494
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 495
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 496
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 497
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 498
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 499
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 500
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 501
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 502
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 503
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 504
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 505
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 506
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 507
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 508
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 509
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 510
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 511
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 512
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 513
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 514
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 515
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 516
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 517
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 518
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 519
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 520
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 521
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 522
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 523
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 524
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 525
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 526
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 527
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 528
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 529
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 530
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 531
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 532
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 533
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 534
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 535
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 536
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 537
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 538
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 539
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 540
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 541
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 542
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 543
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 544
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 545
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 546
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_UNKOWN_INPUT         }, // 547
          { G_UNKOWN_INPUT,                         G_UNKOWN_INPUT,        G_SELECT_BTN           }, // 548
		};
        
		
		// Linux tables
		
        constexpr float Linux_ControllerAxisRangesMax[][6] =
        {
            //G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
            { 255.0f,               255.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // General, PS4 Wired & PS4 Wireless
            { 255.0f,               255.0f,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox 360
            { 1023.0,               1023.0,                65535.0f,   65535.0f,   65535.0f,   65535.0f  }, // Xbox One Wireless
            { 1023.0,               1023.0,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox One Wired
        };
            
        constexpr float Linux_ControllerAxisRangesMin[][6] =
        {
            //G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
            { 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // General, PS4 Wired & PS4 Wireless
            { 255.0f,               255.0f,                -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox 360 & Xbox One Wired
            { 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // Xbox One Wireless
            { 0.0f,                 0.0f,                  -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox One Wired
        };

		// Routes input_event codes (defined in input-event-codes.h on Linux) for different axes to GController axis input (defined in GInputDefines.h)
		constexpr unsigned int Linux_ControllerAxisCodes[][3] = 
		{
			//General, Xbox 360 & Xbox One Wired    PS4                    Xbox One Wireless
			{ G_LX_AXIS, 							G_LX_AXIS, 	   		   G_LX_AXIS 			}, // 0	ABS_X	
			{ G_LY_AXIS, 							G_LY_AXIS, 	   		   G_LY_AXIS 			}, // 1 ABS_Y
			{ G_LEFT_TRIGGER_AXIS, 					G_LEFT_TRIGGER_AXIS,   G_RX_AXIS 			}, // 2 ABS_Z
			{ G_RX_AXIS, 							G_RX_AXIS, 	   		   G_UNKOWN_INPUT 		}, // 3 ABS_RX
			{ G_RY_AXIS, 							G_RY_AXIS, 	   		   G_UNKOWN_INPUT 		}, // 4 ABS_RY
			{ G_RIGHT_TRIGGER_AXIS, 				G_RIGHT_TRIGGER_AXIS,  G_RY_AXIS 			}, // 5 ABS_RZ
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT,   	   G_UNKOWN_INPUT 		}, // 6 ABS_THROTTLE
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT,  	   G_UNKOWN_INPUT 		}, // 7 ABS_RUDDER
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 		}, // 8 ABS_WHEEL
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_RIGHT_TRIGGER_AXIS }, // 9 ABS_GAS
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_LEFT_TRIGGER_AXIS 	}, // 10 ABS_BRAKE
		};

		// Routes input_event codes (from KEY_BACK to BTN_THUMBR) to GController button input.
		constexpr unsigned int Linux_ControllerCodes[][3] = 
		{
			//General, Xbox 360 & Xbox One Wired    PS4                    Xbox One Wireless
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_SELECT_BTN 			}, // 0		
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 1
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 2
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 3
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 4
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 5
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT	 		}, // 6
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT,  	   G_UNKOWN_INPUT 			}, // 7
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 8
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 9
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 10
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 11
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 12
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 13
			{ G_UNKOWN_INPUT, 						G_UNKOWN_INPUT, 	   G_UNKOWN_INPUT 			}, // 14
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 15
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 16
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 17
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 18
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 19
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 20
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 21
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 22
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 23
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 24
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 25
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 26
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 27
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 28
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 29
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 30
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 31
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 32
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 33
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 34
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 35
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 36
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 37
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 38
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 39
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 40
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 41
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 42
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 43
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 44
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 45
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 46
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 47
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 48
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 49
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 50
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 51
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 52
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT           }, // 53
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 54
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 55
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 56
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT        	}, // 57
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 58
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 59
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 60
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 61
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 62
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 63
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 64
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 65
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 66
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 67
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 68
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 69
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 70
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 71
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 72
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 73
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 74
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 75
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 76
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 77
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 78
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 79
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 80
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 81
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 82
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 83
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 84
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 85
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 86
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 87
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 88
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 89
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 90
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 91
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 92
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 93
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 94
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 95
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 96
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 97
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 98
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 99
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 100
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 101
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 102
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 103
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 104
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 105
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 106
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 107
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 108
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 109
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 110
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 111
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 112
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 113
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 114
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 115
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 116
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 117
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 118
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 119
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 120
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 121
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 122
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 123
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 124
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 125
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 126
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 127
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 128
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 129
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 130
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 131
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 132
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 133
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 134
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 135
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 136
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 137
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 138
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 139
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 140
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 141
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 142
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 143
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 144
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 145
			{ G_SOUTH_BTN,       					G_SOUTH_BTN,           G_SOUTH_BTN         		}, // 146
			{ G_EAST_BTN,       					G_EAST_BTN,  		   G_EAST_BTN         		}, // 147
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 148
			{ G_WEST_BTN,       					G_NORTH_BTN,           G_WEST_BTN         		}, // 149
			{ G_NORTH_BTN,       					G_WEST_BTN,        	   G_NORTH_BTN        	 	}, // 150
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 151
			{ G_LEFT_SHOULDER_BTN,       			G_LEFT_SHOULDER_BTN,   G_LEFT_SHOULDER_BTN     	}, // 152
			{ G_RIGHT_SHOULDER_BTN,       			G_RIGHT_SHOULDER_BTN,  G_RIGHT_SHOULDER_BTN    	}, // 153
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 154
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 155
			{ G_SELECT_BTN,       					G_SELECT_BTN,          G_UNKOWN_INPUT         	}, // 156
			{ G_START_BTN,       					G_START_BTN,           G_START_BTN         		}, // 157
			{ G_UNKOWN_INPUT,       				G_UNKOWN_INPUT,        G_UNKOWN_INPUT         	}, // 158
			{ G_LEFT_THUMB_BTN,       				G_LEFT_THUMB_BTN,      G_LEFT_THUMB_BTN         }, // 159
			{ G_RIGHT_THUMB_BTN,       				G_RIGHT_THUMB_BTN,     G_RIGHT_THUMB_BTN        }, // 160
		};
	}
}
#endif

 // every implementation besides dummy uses this
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GCONTROLLER) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GCONTROLLER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    // dummy implemintation for GController
namespace GW {
	namespace I {
		class GControllerImplementation :	public virtual GControllerInterface,
											public GEventGeneratorImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override {
				return GW::GReturn::FAILURE;
			}
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override {
				return GW::GReturn::FAILURE;
			}
			GReturn GetMaxIndex(int& _outMax) override {
				return GW::GReturn::FAILURE;
			}
			GReturn GetNumConnected(int& _outConnectedCount) override {
				return GW::GReturn::FAILURE;
			}
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override {
				return GW::GReturn::FAILURE;
			}
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StopVibration(unsigned int _controllerIndex) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StopAllVibrations() override {
				return GW::GReturn::FAILURE;
			}
		};
	} // end I
} // end GW

#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
@import IOKit.hid;
#endif

#include <atomic>
#include <chrono>
#include <cmath>
#include <pthread.h>


namespace GW
{
    namespace I
    {
        class GGeneralController;
    }
}

namespace internal_gw
{
    // HIDMANAGER Interface
    // HidManager wrapper class

    // Data members of HIDMANAGER
    G_OBJC_DATA_MEMBERS_STRUCT(HIDMANAGER)
    {
        // These are to point to the GController variables
        GW::I::GGeneralController* pController;
        CFRunLoopRef managerRunLoop;

        int LX, LY, LZ, RX, RY, RZ;

        IOHIDManagerRef hidManager;
        NSThread* runLoopThread;
    };

    // Forward declarations of HIDMANAGER methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(HIDMANAGER);

    G_OBJC_HEADER_INSTANCE_METHOD(HIDMANAGER, void, InitManagerAndRunLoop);

    // Creates the HIDMANAGER class at runtime when G_OBJC_GET_CLASS(HIDMANAGER) is called
    G_OBJC_CLASS_BEGIN(HIDMANAGER, NSObject)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(HIDMANAGER);

        G_OBJC_CLASS_METHOD(HIDMANAGER, InitManagerAndRunLoop, "v@:");
    }
    G_OBJC_CLASS_END(HIDMANAGER)

    // HIDMANAGER Interface End
}

namespace GW
{
    namespace I
    {
        class GGeneralController; // Interface which all controller will inherit from

        class GControllerImplementation : public virtual GControllerInterface,
            protected GEventGeneratorImplementation
        {
        private:
            GGeneralController* pController; // POLYMORHISM
        public:
            ~GControllerImplementation();

            GReturn Create();

            GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
            GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
            GReturn GetMaxIndex(int& _outMax) override;
            GReturn GetNumConnected(int& _outConnectedCount) override;
            GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
            GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
            GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
            GReturn StopVibration(unsigned int _controllerIndex) override;
            GReturn StopAllVibrations() override;

            GReturn Register(CORE::GEventCache _observer) override;
            GReturn Register(CORE::GEventResponder _observer) override;
            GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
            GReturn Deregister(CORE::GInterface _observer) override;
            GReturn Observers(unsigned int& _outCount) const override;
            GReturn Push(const GEvent& _newEvent) override;
        };

        class GGeneralController : public GControllerInterface,
            protected GEventGeneratorImplementation
        {
        public:
            struct CONTROLLER_STATE
            {
                int isConnected;
                int isVibrating;
                float vibrationDuration;
                std::chrono::high_resolution_clock::time_point* vibrationStartTime;
                int maxInputs; // Hold the size of controllerInputs array
                float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
                GW::INPUT::GControllerType controllerID;
                IOHIDDeviceRef device;
                int codeMapping;
                int axisMapping;
            } *pControllers;

            GW::I::GControllerInterface::DeadZoneTypes deadZoneType;
            float deadZonePercentage;

            GW::CORE::GThreadShared mutex;
            std::atomic<bool> isRunning;
            NSThread* runLoopThread;
            id manager;
            pthread_attr_t  runLoopPthread_attr;
            pthread_t       runLoopPthread_ID;

            // This function does not lock before using _controllers
            int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers)
            {
                for (unsigned int i = 0; i < _maxIndex; ++i)
                {
                    if (_controllers[i].isConnected == 0)
                        return i;
                }
                return -1;
            }

            // prehaps make return vaule GRETURN
            CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy)
            {
                if (_stateToCopy->maxInputs == _outCopy->maxInputs)
                    for (int i = 0; i < _outCopy->maxInputs; ++i)
                    {
                        _outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
                    }
                else
                    _outCopy = nullptr;

                return _outCopy;
            }

            void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage)
            {
                float range = _axisMax - _axisMin;
                _outX = (((_x - _axisMin) * 2) / range) - 1;
                _outY = (((_y - _axisMin) * 2) / range) - 1;
                float liveRange = 1.0f - _deadzonePercentage;
                if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
                {
                    if (std::abs(_outX) <= _deadzonePercentage)
                        _outX = 0.0f;
                    if (std::abs(_outY) <= _deadzonePercentage)
                        _outY = 0.0f;

                    if (_outX > 0.0f)
                        _outX = (_outX - _deadzonePercentage) / liveRange;
                    else if (_outX < 0.0f)
                        _outX = (_outX + _deadzonePercentage) / liveRange;
                    if (_outY > 0.0f)
                        _outY = (_outY - _deadzonePercentage) / liveRange;
                    else if (_outY < 0.0f)
                        _outY = (_outY + _deadzonePercentage) / liveRange;
                }
                else
                {
                    float mag = std::sqrt(_outX * _outX + _outY * _outY);
                    mag = (mag - _deadzonePercentage) / liveRange;
                    _outX *= mag;
                    _outY *= mag;

                    if (std::abs(_outX) <= _deadzonePercentage)
                        _outX = 0.0f;
                    if (std::abs(_outY) <= _deadzonePercentage)
                        _outY = 0.0f;
                }
            }

            static void* RunLoopThreadEntry(void* manager_ptr)
            {
                id manager = (id)manager_ptr;
                internal_gw::G_OBJC_CALL_METHOD(HIDMANAGER, manager, InitManagerAndRunLoop); // warning due to forward declartion
                return NULL;
            }
        public:
            GGeneralController() {}

            virtual void Initialize()
            {
                mutex.Create();
                pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
                deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
                deadZonePercentage = 0.2f;

                for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    pControllers[i].isConnected = 0;
                    pControllers[i].isVibrating = 0;
                    pControllers[i].vibrationDuration = 0;
                    pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
                    pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
                    pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
                    for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
                    {
                        pControllers[i].controllerInputs[j] = 0.0f;
                    }
                }

                isRunning = true;
                manager = [internal_gw::G_OBJC_GET_CLASS(HIDMANAGER) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
                managerDataMembers.pController = this;

                pthread_attr_init(&runLoopPthread_attr);

                pthread_attr_setdetachstate(&runLoopPthread_attr, PTHREAD_CREATE_JOINABLE);

                pthread_create(&runLoopPthread_ID, &runLoopPthread_attr, &RunLoopThreadEntry, manager);
            }

            virtual void Release()
            {
                isRunning = false;
                pthread_join(runLoopPthread_ID, NULL);
                for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    delete[] pControllers[i].controllerInputs;
                    delete pControllers[i].vibrationStartTime;
                }
                delete[] pControllers;
            }

            virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
            {
                if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
                    return GReturn::INVALID_ARGUMENT;
                if (pControllers[_controllerIndex].isConnected == 0)
                    return GReturn::FAILURE;
                LockAsyncRead();
                _outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
                UnlockAsyncRead();
                return GReturn::SUCCESS;
            }

            virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
            {
                if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
                    return GReturn::INVALID_ARGUMENT;
                LockAsyncRead();
                _outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
                UnlockAsyncRead();

                return GReturn::SUCCESS;
            }

            virtual GReturn GetMaxIndex(int& _outMax) override
            {
                _outMax = G_MAX_CONTROLLER_INDEX;
                return GReturn::SUCCESS;
            }

            virtual GReturn GetNumConnected(int& _outConnectedCount) override
            {
                _outConnectedCount = 0;
                LockAsyncRead();
                for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    if (pControllers[i].isConnected)
                        ++_outConnectedCount;
                }
                UnlockAsyncRead();
                return GReturn::SUCCESS;
            }

            virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
            {
                if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
                    return GReturn::INVALID_ARGUMENT;
                LockSyncWrite();
                deadZoneType = _type;
                deadZonePercentage = _deadzonePercentage;
                UnlockSyncWrite();
                return GReturn::SUCCESS;
            }

            virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn StopVibration(unsigned int _controllerIndex) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn StopAllVibrations() override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
            GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
            GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
            GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
            GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
            GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
        };

        inline GControllerImplementation::~GControllerImplementation()
        {
            if (pController)
            {
                pController->Release();
                delete pController;
                pController = nullptr;
            }
        }

        inline GReturn GControllerImplementation::Create()
        {
            pController = new GGeneralController();
            pController->Initialize();
            
            return GReturn::SUCCESS;
        }
        inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
        inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
        inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
        inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
        inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
        inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
    }
}

namespace internal_gw
{
    // Arg 1: context from IOHIDDeviceRegisterInputValueCallback
    // Arg 2: completion result for the input value operation
    // Arg 3: IOHIDDeviceRef of the device this element is from
    // Arg 4: the new element value
    static void Handle_IOHIDDeviceInputValueCallback(void* inContext, IOReturn inResult, void* inSender, IOHIDValueRef inIOHIDValueRef)
    {
        GW::GEvent l_GEvent;

        double_t scaledValue = IOHIDValueGetScaledValue(inIOHIDValueRef, kIOHIDValueScaleTypePhysical);

        IOHIDElementRef tIOHIDElementRef = IOHIDValueGetElement(inIOHIDValueRef);
        IOHIDElementType type = IOHIDElementGetType(tIOHIDElementRef);
        int32_t usage = IOHIDElementGetUsage(tIOHIDElementRef);
        
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        GW::I::GControllerInterface::EVENT_DATA eventData;
        int controllerIndex = 0;
        bool controllerFound = false;
        for (; controllerIndex < G_MAX_CONTROLLER_INDEX; ++controllerIndex)
        {
            if (pController->pControllers[controllerIndex].device == (IOHIDDeviceRef)inSender)
            {
                controllerFound = true;
                break;
            }
        }

        if (controllerFound)
        {
            while (!(usage < 549 && usage >= 0))
                usage = IOHIDElementGetUsage(tIOHIDElementRef);
            
            int inputCode = GW::I::Mac_ControllerCodes[usage][(int)pController->pControllers[controllerIndex].codeMapping];
            // switch on input type
            if (inputCode == G_UNKOWN_INPUT)
                return;
            
            if (type == kIOHIDElementTypeInput_Button)
            {
                pController->mutex.LockSyncWrite();
                // swap 2 with controller id stored in pControllers
                pController->pControllers[controllerIndex].controllerInputs[inputCode] = (float)scaledValue;
                eventData.inputCode = inputCode;
                eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[inputCode];
                eventData.isConnected = 1;
                eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                eventData.controllerIndex = controllerIndex;
                pController->mutex.UnlockSyncWrite();

                l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                pController->Push(l_GEvent);
            }
            else if (type == kIOHIDElementTypeInput_Misc)
            {
                // get input code from array then switch base on the code to determine how to proccess it
                switch (inputCode)
                {
                case G_LX_AXIS:
                {
                    int& LX = managerDataMembers.LX;
                    if (scaledValue != LX)
                    {
                        int& LY = managerDataMembers.LY;
                        pController->mutex.LockSyncWrite();
                        float oldY = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        LX = scaledValue;
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(LX,
                            LY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        eventData.inputCode = G_LX_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldY != eventData.inputValue)
                        {
                            // Send LY event
                            eventData.inputCode = G_LY_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_LY_AXIS:
                {
                    int& LY = managerDataMembers.LY;
                    //leftY
                    if (scaledValue != LY)
                    {
                        int& LX = managerDataMembers.LX;
                        pController->mutex.LockSyncWrite();
                        LY = scaledValue;
                        float oldX = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(LX,
                            LY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        // Send LY event
                        pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputCode = G_LY_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldX != eventData.inputValue)
                        {
                            // Send LX event
                            eventData.inputCode = G_LX_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RX_AXIS:
                {
                    int& RX = managerDataMembers.RX;
                    if (scaledValue != RX)
                    {
                        int& RY = managerDataMembers.RY;
                        pController->mutex.LockSyncWrite();
                        float oldY = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        RX = scaledValue;
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(RX,
                            RY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        eventData.inputCode = G_RX_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldY != eventData.inputValue)
                        {
                            // Send LY event
                            eventData.inputCode = G_RY_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RY_AXIS:
                {
                    int& RY = managerDataMembers.RY;
                    if (scaledValue != RY)
                    {
                        int RX = managerDataMembers.RX;
                        pController->mutex.LockSyncWrite();
                        RY = scaledValue;
                        float oldX = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(RX,
                            RY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        // Send RY event
                        pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputCode = G_RY_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldX != eventData.inputValue)
                        {
                            // Send RX event
                            eventData.inputCode = G_RX_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_LEFT_TRIGGER_AXIS:
                {
                    int& LZ = managerDataMembers.LZ;
                    if (scaledValue != LZ)
                    {
                        pController->mutex.LockSyncWrite();
                        LZ = scaledValue;
                        float oldAxis = pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
                        if (scaledValue > G_GENERAL_TRIGGER_THRESHOLD)
                        {
                            int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                            pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = scaledValue / GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset];
                        }
                        else
                            pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = 0;

                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (oldAxis != eventData.inputValue)
                        {
                            eventData.inputCode = G_LEFT_TRIGGER_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RIGHT_TRIGGER_AXIS:
                {
                    int& RZ = managerDataMembers.RZ;
                    if (scaledValue != RZ)
                    {
                        pController->mutex.LockSyncWrite();
                        RZ = scaledValue;
                        float oldAxis = pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
                        if (scaledValue > G_GENERAL_TRIGGER_THRESHOLD)
                        {
                            int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                            pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = scaledValue / GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset];
                        }
                        else
                            pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = 0;

                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (oldAxis != eventData.inputValue)
                        {
                            eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_DPAD_LEFT_BTN: // This is used when the Dpad value is reported as a value of 0-360
                {
                    switch ((int)scaledValue)
                    {
                    case 0: // UP
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 1: // UP-RIGHT
                    case 45:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 2: // RIGHT
                    case 90:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 3: // RIGHT-DOWN
                    case 135:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }


                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 4: // DOWN
                    case 180:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 5: // DOWN-LEFT
                    case 225:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 6: // LEFT
                    case 270:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 7: // LEFT-UP
                    case 315:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case -45: // Released
                    case 8:
                    case 360:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    }
                    break;
                }
                break;
                }
            }
        }
    }

    static void GamepadWasAdded(void* inContext, IOReturn inResult, void* inSender, IOHIDDeviceRef device)
    {
        //NSLog(@"Gamepad was plugged in");
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        if (pController->isRunning)
        {
            GW::GEvent l_GEvent;
            pController->mutex.LockSyncWrite();
            int controllerIndex = pController->FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pController->pControllers);
            if (controllerIndex != -1)
            {
                IOReturn res = IOHIDDeviceOpen(device, kIOHIDOptionsTypeNone);
                if (kIOReturnSuccess == res)
                {
                    CFStringRef productKey;
                    productKey = (CFStringRef)IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductKey));
                    
                    uint32_t vendorID;
                    GW::INPUT::GControllerType controllerID;
                    // IOHIDeviceGetProperty Returns a CFTyperef based on the CString passed in. CFNumberGetValue is used to retrieve the value.
                    CFNumberGetValue((CFNumberRef)IOHIDDeviceGetProperty(device, CFSTR(kIOHIDVendorIDKey)), kCFNumberSInt32Type, &vendorID);
                    
                    switch (vendorID)
                    {
                    case G_SONY_VENDOR_ID:
                    {
                        controllerID = GW::INPUT::GControllerType::PS4;

                        CFStringRef usbProperty = (CFStringRef)IOHIDDeviceGetProperty(device, CFSTR("USB Product Name"));
                        
                        if (usbProperty == nil) // usbProperty will be nil if the device is not connected via USB.
                        {
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_PS4_WIRELESS;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_PS4_WIRELESS;
                        }
                        else
                        {
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_PS4_WIRED;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_PS4_WIRED;
                        }

                        break;
                    }

                    case G_MICROSOFT_VENDOR_ID:
                    {
                        const char* productName = CFStringGetCStringPtr(productKey, kCFStringEncodingMacRoman);
                        
                        if (strstr(productName, "Wireless") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOXONE;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOXONE_WIRELESS;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOXONE_WIRELESS;
                        }
                        else if (strstr(productName, "One") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOXONE;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOXONE_WIRED;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOXONE_WIRED;
                        }
                        else
                        {
                            controllerID = GW::INPUT::GControllerType::XBOX360;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOX360;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOX360;
                        }
                        
                        break;
                    }

                    default:
                    {
                        const char* productName = CFStringGetCStringPtr(productKey, kCFStringEncodingMacRoman);
                        
                        if (strstr(productName, "Xbox") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOX360;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOX360;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOX360;
                        }
                        else
                        {
                            controllerID = GW::INPUT::GControllerType::GENERAL;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_GENERAL;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_GENERAL;
                        }
                        
                        break;
                    }
                    }
                    
                    pController->pControllers[controllerIndex].controllerID = controllerID;
                    pController->pControllers[controllerIndex].isConnected = 1;
                    pController->pControllers[controllerIndex].device = device;

                    // send controller connected event
                    GW::I::GControllerInterface::EVENT_DATA eventData;

                    eventData.controllerIndex = controllerIndex;
                    eventData.inputCode = 0;
                    eventData.inputValue = 0;
                    eventData.isConnected = 1;
                    eventData.controllerID = pController->pControllers[controllerIndex].controllerID;

                    l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
                    pController->Push(l_GEvent);

                    IOHIDDeviceRegisterInputValueCallback(device, Handle_IOHIDDeviceInputValueCallback, (__bridge void*)manager);
                }
            }
            pController->mutex.UnlockSyncWrite();
        }
    }

    static void GamepadWasRemoved(void* inContext, IOReturn inResult, void* inSender, IOHIDDeviceRef device)
    {
        // NSLog(@"Gamepad was unplugged");
        IOHIDDeviceClose(device, kIOHIDOptionsTypeNone);
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        if (pController->isRunning)
        {
            GW::GEvent l_GEvent;
            pController->mutex.LockSyncWrite();
            int controllerIndex = 0;
            for (; controllerIndex < G_MAX_CONTROLLER_INDEX; ++controllerIndex)
            {
                if (device == pController->pControllers[controllerIndex].device)
                {
                    pController->pControllers[controllerIndex].isConnected = 0;

                    // send controller connected event
                    GW::I::GControllerInterface::EVENT_DATA eventData;

                    eventData.controllerIndex = controllerIndex;
                    eventData.inputCode = 0;
                    eventData.inputValue = 0;
                    eventData.isConnected = 0;
                    eventData.controllerID = pController->pControllers[controllerIndex].controllerID;

                    l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
                    pController->Push(l_GEvent);
                }
            }
            pController->mutex.UnlockSyncWrite();
        }
    }

    // This Function creates and return an array of dictionarys used to match connected devices
    static CFMutableArrayRef CreateHIDManagerCriteria()
    {
        // create a dictionary to add usage page/usages to
        UInt32 usagePage = kHIDPage_GenericDesktop;
        UInt32 joyUsage = kHIDUsage_GD_Joystick;
        UInt32 gamepadUsage = kHIDUsage_GD_GamePad;
        UInt32 mutiaxisUsage = kHIDUsage_GD_MultiAxisController;

        CFMutableDictionaryRef joyDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFMutableDictionaryRef gamepadDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFMutableDictionaryRef multiaxisDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFNumberRef pageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &usagePage);

        CFDictionarySetValue(joyDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFDictionarySetValue(gamepadDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFDictionarySetValue(multiaxisDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFRelease(pageCFNumberRef);

        CFNumberRef usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &joyUsage);
        CFDictionarySetValue(joyDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);

        usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &gamepadUsage);
        CFDictionarySetValue(gamepadDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);

        usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &mutiaxisUsage);
        CFDictionarySetValue(multiaxisDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);
        CFRelease(usageCFNumberRef);

        CFMutableArrayRef dictionaryCFArr = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);

        CFArrayAppendValue(dictionaryCFArr, joyDictionary);
        CFArrayAppendValue(dictionaryCFArr, gamepadDictionary);
        CFArrayAppendValue(dictionaryCFArr, multiaxisDictionary);

        CFRelease(joyDictionary);
        CFRelease(gamepadDictionary);
        CFRelease(multiaxisDictionary);

        return dictionaryCFArr;
    }

    // HIDMANAGER Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(HIDMANAGER);

    G_OBJC_HEADER_INSTANCE_METHOD(HIDMANAGER, void, InitManagerAndRunLoop)
    {
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, self);
        IOHIDManagerRef& hidManager = selfDataMembers.hidManager;

        hidManager = IOHIDManagerCreate(kCFAllocatorDefault, kIOHIDManagerOptionNone);

        IOHIDManagerRegisterDeviceMatchingCallback(hidManager, GamepadWasAdded, (__bridge void*)self);
        IOHIDManagerRegisterDeviceRemovalCallback(hidManager, GamepadWasRemoved, (__bridge void*)self);

        IOHIDManagerScheduleWithRunLoop(hidManager, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);

        CFMutableArrayRef criteria = CreateHIDManagerCriteria();
        IOHIDManagerSetDeviceMatchingMultiple(hidManager, criteria);

        CFRelease(criteria);

        IOHIDManagerOpen(hidManager, kIOHIDOptionsTypeNone);
        CFTimeInterval timer = 1;
        Boolean runLoopReturn = true;
        // The run loop will exit once a second to check and see if GController is still running
        // The run loop is used for proccessing the events for the IOHIDManager it work similar to [NSAPP run]
        GW::I::GGeneralController* pController = selfDataMembers.pController;
        while (pController->isRunning)
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, timer, runLoopReturn);
    }

    // HIDMANAGER Implementation End
}





#elif defined(__linux__)
    #include <stdio.h>
#include <stdlib.h>
#include <sys/inotify.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <linux/input-event-codes.h>
#include <chrono>
#include <cmath>
#include <dirent.h>
#include <string>
#include <cstring>
#include <atomic>


namespace GW
{
	namespace I
	{
		class GGeneralController; // Interface which all controller will inherit from

		class GControllerImplementation : public virtual GControllerInterface,
			protected GEventGeneratorImplementation
		{
		private:
			GGeneralController* pController; // POLYMORHISM
		public:
			~GControllerImplementation();

			GReturn Create();

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
			GReturn GetMaxIndex(int& _outMax) override;
			GReturn GetNumConnected(int& _outConnectedCount) override;
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
			GReturn StopVibration(unsigned int _controllerIndex) override;
			GReturn StopAllVibrations() override;

			GReturn Register(CORE::GEventCache _observer) override;
			GReturn Register(CORE::GEventResponder _observer) override;
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
			GReturn Deregister(CORE::GInterface _observer) override;
			GReturn Observers(unsigned int& _outCount) const override;
			GReturn Push(const GEvent& _newEvent) override;
		};

		class GGeneralController : public virtual GControllerInterface,
			protected GEventGeneratorImplementation
		{
		protected:
			struct CONTROLLER_STATE
			{
				int isConnected;
				int isVibrating;
				float vibrationDuration;
				std::chrono::high_resolution_clock::time_point* vibrationStartTime;
				int maxInputs; // Hold the size of controllerInputs array
				float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
				GW::INPUT::GControllerType controllerID;
				char controllerFilePath[8];
				int codeMapping;
				int axisMapping;
			} *pControllers;

			struct G_inotify_event
			{
				int wd;        /* Watch descriptor.  */
				uint32_t mask;    /* Watch mask.  */
				uint32_t cookie;    /* Cookie to synchronize two events.  */
				uint32_t len;        /* Length (including NULs) of name.  */
				char name[16];    /* Name.  */
			};

			GW::I::GControllerInterface::DeadZoneTypes deadZoneType;
			float deadZonePercentage;

			std::atomic_bool isRunning;
			GW::SYSTEM::GConcurrent controllerThreads[G_MAX_CONTROLLER_INDEX];
			std::atomic_bool isControllerThreadActive[G_MAX_CONTROLLER_INDEX];
			GW::SYSTEM::GConcurrent notifyThread;

			// This function does not lock before using _controllers
			int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers)
			{
				for (unsigned int i = 0; i < _maxIndex; ++i)
				{
					if (_controllers[i].isConnected == 0)
						return i;
				}
				return -1;
			}

			CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy)
			{
				if (_stateToCopy->maxInputs == _outCopy->maxInputs)
					for (int i = 0; i < _outCopy->maxInputs; ++i)
					{
						_outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
					}
				else
					_outCopy = nullptr;

				return _outCopy;
			}

			void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage)
			{
				float range = _axisMax - _axisMin;
				_outX = (((_x - _axisMin) * 2) / range) - 1;
				_outY = (((_y - _axisMin) * 2) / range) - 1;
				float liveRange = 1.0f - _deadzonePercentage;
				if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
				{
					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;

					if (_outX > 0.0f)
						_outX = (_outX - _deadzonePercentage) / liveRange;
					else if (_outX < 0.0f)
						_outX = (_outX + _deadzonePercentage) / liveRange;
					if (_outY > 0.0f)
						_outY = (_outY - _deadzonePercentage) / liveRange;
					else if (_outY < 0.0f)
						_outY = (_outY + _deadzonePercentage) / liveRange;
				}
				else
				{
					float mag = std::sqrt(_outX * _outX + _outY * _outY);
					mag = (mag - _deadzonePercentage) / liveRange;
					_outX *= mag;
					_outY *= mag;

					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;
				}
			}

			// This functions gets an array of bits representing the keys supported for the device and check if BTN_GAMEPAD/BTN_SOUTH is set
			bool isGamepadBitSet(int _event_fd)
			{
				// keys' size is based on how many sets of 64 bits it would take to cover all of the diffrent types of keys where each key is a bit
				unsigned long keys[(KEY_CNT + 64 - 1) / 64];
				// EXVIOCGBIT gets the keys supported by the device returned as an array of 64 bits per index
				// BTN_GAMEPAD represents the bit we want to check so we find where the bit would be located in the array
				// and in the current 64 bits
				ioctl(_event_fd, EVIOCGBIT(EV_KEY, sizeof(keys)), keys);
				return (keys[BTN_GAMEPAD / 64] & (1LL << (BTN_GAMEPAD % 64))) != 0 ? true : false;
			}
			
			void GetControllerIDAndMappings(int _event_fd, GW::INPUT::GControllerType& _outControllerID, int& _outCodeMapping, int& _outAxisMapping)
			{
				char name[256];
				memset(name, ' ', 256);
				ioctl(_event_fd, EVIOCGNAME(256), name);
	
				if (strstr(name, "Sony") != nullptr)
				{
					_outControllerID = GW::INPUT::GControllerType::PS4;
					_outCodeMapping = G_CODE_MAPPING_PS4_WIRED;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_PS4_WIRED;
				}
				else if (strstr(name, "Xbox") != nullptr || strstr(name, "Microsoft") != nullptr)
				{
					if (strstr(name, "Wireless") != nullptr)
					{
						_outControllerID = GW::INPUT::GControllerType::XBOXONE;
						_outCodeMapping = G_CODE_MAPPING_XBOXONE_WIRELESS;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOXONE_WIRELESS;
					}
					else if (strstr(name, "One") != nullptr)
					{
						_outControllerID = GW::INPUT::GControllerType::XBOXONE;
						_outCodeMapping = G_CODE_MAPPING_XBOXONE_WIRED;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOXONE_WIRED;
					}
					else
					{
						_outControllerID = GW::INPUT::GControllerType::XBOX360;
						_outCodeMapping = G_CODE_MAPPING_XBOX360;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOX360;
					}
				}
				else if (strstr(name, "Wireless Controller") != nullptr)
				{
					_outControllerID = GW::INPUT::GControllerType::PS4;
					_outCodeMapping = G_CODE_MAPPING_PS4_WIRELESS;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_PS4_WIRELESS;
				}
				else
				{
					_outControllerID = GW::INPUT::GControllerType::GENERAL;
					_outCodeMapping = G_CODE_MAPPING_GENERAL;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_GENERAL;
				}
			}

			void ControllerInputThreadEntryPoint(unsigned int _controllerIndex, int fd)
			{
				GEvent l_GEvent;
				input_event ev; // time value type code
				input_event base;
				base.value = 0;
				base.type = 0;
				base.code = 0;
				EVENT_DATA eventData;
				int lastLX = 0, lastLY = 0, lastRX = 0, lastRY = 0, lastLT = 0, lastRT = 0;

				while (isControllerThreadActive[_controllerIndex])
				{
					ev = base;
					int result = read(fd, &ev, sizeof(struct input_event));
					if (result != -1)
					{
						switch (ev.type)
						{
						case EV_KEY:
						{
							if (ev.code < KEY_BACK)
								break;
							
							int inputCode = Linux_ControllerCodes[ev.code - KEY_BACK][pControllers[_controllerIndex].codeMapping];
							
							if (inputCode == G_UNKOWN_INPUT)
								break;
							
							LockSyncWrite();
							pControllers[_controllerIndex].controllerInputs[inputCode] = ev.value;
							eventData.inputCode = inputCode;
							eventData.inputValue = pControllers[_controllerIndex].controllerInputs[inputCode];
							eventData.controllerIndex = _controllerIndex;
							eventData.controllerID = pControllers[_controllerIndex].controllerID;
							UnlockSyncWrite();

							l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
							Push(l_GEvent);
						}
						break;

						case EV_ABS:
						{
							if (ev.code <= ABS_BRAKE)
							{
								int inputCode = GW::I::Linux_ControllerAxisCodes[ev.code][pControllers[_controllerIndex].codeMapping];
								int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
								
								switch (inputCode)
								{
									case G_LX_AXIS:
									{
										// leftX
										if (ev.value != lastLX)
										{
											LockSyncWrite();
											float oldY = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											lastLX = ev.value;
											DeadZoneCalculation(lastLX,
												lastLY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_LX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_LY_AXIS],
												deadZoneType,
												deadZonePercentage);

											eventData.inputCode = G_LX_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											pControllers[_controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											eventData.controllerIndex = _controllerIndex;
											UnlockSyncWrite();

											if (oldY != eventData.inputValue)
											{
												// Send LY event
												eventData.inputCode = G_LY_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_LY_AXIS:
									{
										//leftY
										if (ev.value != lastLY)
										{			
											LockSyncWrite();
											lastLY = ev.value; // evdev values for Y are flipped
											float oldX = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											int axisMapping = pControllers[_controllerIndex].axisMapping;
											DeadZoneCalculation(lastLX,
												lastLY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_LX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_LY_AXIS],
												deadZoneType,
												deadZonePercentage);

											// Send LY event
											pControllers[_controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputCode = G_LY_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldX != eventData.inputValue)
											{
												// Send LX event
												eventData.inputCode = G_LX_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RX_AXIS:
									{										
										// RightX
										if (ev.value != lastRX)
										{
											LockSyncWrite();
											float oldY = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											lastRX = ev.value;
											DeadZoneCalculation(lastRX,
												lastRY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_RX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_RY_AXIS],
												deadZoneType,
												deadZonePercentage);

											eventData.inputCode = G_RX_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											pControllers[_controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldY != eventData.inputValue)
											{
												// Send LY event
												eventData.inputCode = G_RY_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RY_AXIS:
									{
										//leftY
										if (ev.value != lastRY)
										{
											LockSyncWrite();
											lastRY = ev.value; // evdev values for y are flipped.
											float oldX = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											DeadZoneCalculation(lastRX,
												lastRY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_RX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_RY_AXIS],
												deadZoneType,
												deadZonePercentage);

											// Send LY event
											pControllers[_controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputCode = G_RY_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldX != eventData.inputValue)
											{
												// Send LX event
												eventData.inputCode = G_RX_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_LEFT_TRIGGER_AXIS:
									{
										// left trigger
										if (ev.value != lastLT)
										{										
											LockSyncWrite();
											lastLT = ev.value;
											float oldAxis = pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
											if (ev.value > G_GENERAL_TRIGGER_THRESHOLD)
												pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = (float)ev.value / GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset];
											else
												pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = 0;

											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();
											if (oldAxis != eventData.inputValue)
											{
												eventData.inputCode = G_LEFT_TRIGGER_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RIGHT_TRIGGER_AXIS:
									{
										if (ev.value != lastRT)
										{
											LockSyncWrite();
											lastRT = ev.value;
											float oldAxis = pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
											if (ev.value > G_GENERAL_TRIGGER_THRESHOLD)
												pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = (float)ev.value / GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset];
											else
												pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = 0;

											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();
											if (oldAxis != pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS])
											{
												eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
								}
							}
							else
							{
								switch (ev.code)
								{
								case ABS_HAT0X:
								case ABS_HAT3X:
								{
									// DPAD HORZONTAL
									if (ev.value == 1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
										eventData.inputCode = G_DPAD_RIGHT_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == -1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
										eventData.inputCode = G_DPAD_LEFT_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == 0)
									{
										LockSyncWrite();
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										eventData.controllerIndex = _controllerIndex;
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
											eventData.inputCode = G_DPAD_LEFT_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
										}
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
											eventData.inputCode = G_DPAD_RIGHT_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
										}
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
								}
								break;

								case ABS_HAT0Y:
								case ABS_HAT3Y:
								{
									// DPAD VERT
									if (ev.value == 1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
										eventData.inputCode = G_DPAD_DOWN_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == -1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
										eventData.inputCode = G_DPAD_UP_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == 0)
									{
										LockSyncWrite();
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										eventData.controllerIndex = _controllerIndex;
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
											eventData.inputCode = G_DPAD_UP_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN];
										}
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
											eventData.inputCode = G_DPAD_DOWN_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
										}
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
								}
								break;
								}
							}
						}
						break;
						}
					}
					else
					{
						if (errno == EAGAIN)
							sleep(.001);
						else
							break;
					}
				}

				if (close(fd) == -1)
				{
					if (errno == EBADF)
						printf("fd isnt a valid open file descriptor\n");
					else if (errno == EINTR)
						printf("close call is interrupted by signal\n");
					else if (errno == EIO)
						printf("i/o error\n");
				}

				LockSyncWrite();
				pControllers[_controllerIndex].isConnected = 0;
				UnlockSyncWrite();

				eventData.controllerIndex = _controllerIndex;
				eventData.inputCode = 0;
				eventData.inputValue = 0;
				eventData.isConnected = 0;

				l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERDISCONNECTED, eventData);
				Push(l_GEvent);
			}

			void NotifyThreadEntryPoint()
			{
				EVENT_DATA eventData;
				int fd = 0;
				int wd = 0;
				struct G_inotify_event iev, base;
				int length = sizeof(struct G_inotify_event);
				base.len = 0;
				base.mask = 0;

				fd = inotify_init1(IN_NONBLOCK);
				wd = inotify_add_watch(fd, "/dev/input", IN_ATTRIB | IN_CREATE | IN_DELETE);

				while (isRunning)
				{
					iev = base;
					if (read(fd, &iev, length) != -1)
					{
						if (iev.len)
						{
							if (iev.mask & IN_ATTRIB || iev.mask & IN_CREATE)
							{
								if (!(iev.mask & IN_ISDIR))
								{
									char newFile[30];
									strcpy(newFile, "/dev/input/");
									strcat(newFile, iev.name);
									// check the type of file
									int evdevCheck = strncmp(iev.name, "event", 5);
									// check if file has a vaild number of inputs
									if (evdevCheck == 0)
									{
										int event_fd = open(newFile, O_RDONLY | O_NONBLOCK);
										if (event_fd > -1)
										{
											if (isGamepadBitSet(event_fd))
											{
												LockSyncWrite();
												int controllerIndex = FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pControllers);
												UnlockSyncWrite();
												if (controllerIndex != -1)
												{
													GW::INPUT::GControllerType controllerID;
													int codeMapping, axisMapping;
													GetControllerIDAndMappings(event_fd, controllerID, codeMapping, axisMapping);
													
													LockSyncWrite();
													pControllers[controllerIndex].controllerID = controllerID;
													pControllers[controllerIndex].codeMapping = codeMapping;
													pControllers[controllerIndex].axisMapping = axisMapping;
													isControllerThreadActive[controllerIndex] = true;
													for (int i = 0; i < 8; ++i)
														pControllers[controllerIndex].controllerFilePath[i] = iev.name[i];
													pControllers[controllerIndex].isConnected = 1;
													eventData.controllerID = pControllers[controllerIndex].controllerID;
													UnlockSyncWrite();

													controllerThreads[controllerIndex].Create(false);
													controllerThreads[controllerIndex].BranchSingular(std::bind(&GGeneralController::ControllerInputThreadEntryPoint, this, controllerIndex, event_fd));

													eventData.controllerIndex = controllerIndex;
													eventData.inputCode = 0;
													eventData.inputValue = 0;
													eventData.isConnected = 1;

													GW::GEvent l_GEvent;
													l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
													Push(l_GEvent);
												}
											}
										}
									}
								}
							}
							else if (iev.mask & IN_DELETE)
							{
								if (!(iev.mask & IN_ISDIR))
								{
									for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
									{
										if (strncmp(pControllers[i].controllerFilePath, iev.name, 8) == 0)
										{
											isControllerThreadActive[i] = false;
											controllerThreads[i].Converge(0);
											controllerThreads[i] = nullptr;
										}
									}
								}
							}
						}
					}
				}

				close(fd);
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (isControllerThreadActive[i])
					{
						isControllerThreadActive[i] = false;
						controllerThreads[i].Converge(0);
						controllerThreads[i] = nullptr;
					}
				}
			}
		public:
			GGeneralController() {}

			virtual void Initialize()
			{
				isRunning = true;

				pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;

				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					// Init the bools
					isControllerThreadActive[i] = false;

					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
					for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
					{
						pControllers[i].controllerInputs[j] = 0.0f;
					}
				}

				DIR* dir;
				dirent* fileData;
				EVENT_DATA eventData;

				if ((dir = opendir("/dev/input")) != NULL)
				{
					/* print all the files and directories within directory */
					while ((fileData = readdir(dir)) != NULL)
					{
						char newFile[30];
						strcpy(newFile, "/dev/input/");
						strcat(newFile, fileData->d_name);
						// check the type of file
						int evdevCheck = strncmp(fileData->d_name, "event", 5);
						// check if file has a vaild number of inputs
						if (evdevCheck == 0)
						{
							int event_fd = open(newFile, O_RDONLY | O_NONBLOCK);
							if (event_fd > -1)
							{
								if (isGamepadBitSet(event_fd))
								{
									LockAsyncRead();
									int controllerIndex = FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pControllers);
									UnlockAsyncRead();
									if (controllerIndex != -1)
									{
										GW::INPUT::GControllerType controllerID;
										int codeMapping, axisMapping;
										GetControllerIDAndMappings(event_fd, controllerID, codeMapping, axisMapping);
										
										LockSyncWrite();
										isControllerThreadActive[controllerIndex] = true;
										for (int i = 0; i < 8; ++i)
											pControllers[controllerIndex].controllerFilePath[i] = fileData->d_name[i];
										pControllers[controllerIndex].controllerID = controllerID;
										pControllers[controllerIndex].codeMapping = codeMapping;
										pControllers[controllerIndex].axisMapping = axisMapping;
										pControllers[controllerIndex].isConnected = 1;
										eventData.controllerID = pControllers[controllerIndex].controllerID;
										UnlockSyncWrite();

										controllerThreads[controllerIndex].Create(false);
										controllerThreads[controllerIndex].BranchSingular(std::bind(&GGeneralController::ControllerInputThreadEntryPoint, this, controllerIndex, event_fd));

										eventData.controllerIndex = controllerIndex;
										eventData.inputCode = 0;
										eventData.inputValue = 0;
										eventData.isConnected = 1;

										GW::GEvent l_GEvent;
										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
										Push(l_GEvent);
									}
								}
							}
						}
					}
					closedir(dir);
				}
				
				notifyThread.Create(false);
				notifyThread.BranchSingular(std::bind(&GGeneralController::NotifyThreadEntryPoint, this));
			}

			virtual void Release()
			{
				isRunning = false;
				
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
					if (isControllerThreadActive[i])
					{
						isControllerThreadActive[i] = false;
						controllerThreads[i].Converge(0);
						controllerThreads[i] = nullptr;
					}
				
				notifyThread.Converge(0);
				
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
					return GReturn::INVALID_ARGUMENT;
				if (pControllers[_controllerIndex].isConnected == 0)
					return GReturn::FAILURE;
				LockAsyncRead();
				_outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn GetMaxIndex(int& _outMax) override
			{
				_outMax = G_MAX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			virtual GReturn GetNumConnected(int& _outConnectedCount) override
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
			{
				if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
					return GReturn::INVALID_ARGUMENT;
				LockSyncWrite();
				deadZoneType = _type;
				deadZonePercentage = _deadzonePercentage;
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			// General controllers do not support these features because it is used cross-platform as a "general" controller
			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn StopVibration(unsigned int _controllerIndex) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn StopAllVibrations() override { return GReturn::FEATURE_UNSUPPORTED; }

			GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
			GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
			GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
			GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
		};

		inline GControllerImplementation::~GControllerImplementation()
		{
			if (pController)
			{
				pController->Release();
				delete pController;
				pController = nullptr;
			}
		}

		inline GReturn GControllerImplementation::Create()
		{
			pController = new GGeneralController();
			pController->Initialize();
			
			return GReturn::SUCCESS;
		}
		inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
		inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
		inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
		inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
	} // end I namespace
} // end GW namespace

#elif defined(_WIN32)
    #include <cmath>
#include <chrono>
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <XInput.h>
#pragma comment(lib, "XInput.lib")

#include <objbase.h>

namespace GW
{
	namespace I
	{
		class GGeneralController; // Interface which all controller will inherit from
		class GXboxController; // xbox
		// class GPS4Controller; // Not supported yet! future devs, this is for you :)

		class GControllerImplementation :	public virtual GControllerInterface,
				protected GEventGeneratorImplementation
		{
		private:
			GGeneralController* pController = nullptr; // POLYMORHISM
		public:
			~GControllerImplementation();

			GReturn Create();

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
			GReturn GetMaxIndex(int& _outMax) override;
			GReturn GetNumConnected(int& _outConnectedCount) override;
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
			GReturn StopVibration(unsigned int _controllerIndex) override;
			GReturn StopAllVibrations() override;

			GReturn Register(CORE::GEventCache _observer) override;
			GReturn Register(CORE::GEventResponder _observer) override;
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
			GReturn Deregister(CORE::GInterface _observer) override;
			GReturn Observers(unsigned int& _outCount) const override;
			GReturn Push(const GEvent& _newEvent) override;
		};

		class GGeneralController :	public virtual GControllerInterface,
									public GEventGeneratorImplementation
		{
		protected:
			struct CONTROLLER_STATE
			{
				int isConnected;
				int isVibrating;
				float vibrationDuration;
				std::chrono::high_resolution_clock::time_point* vibrationStartTime;
				int maxInputs; // Hold the size of controllerInputs array
				float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
				GW::INPUT::GControllerType controllerID;
			} *pControllers = nullptr;

			GW::I::GControllerInterface::DeadZoneTypes deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONECIRCLE;
			float deadZonePercentage = 0;

			// This function does not lock before using _controllers
			unsigned int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers) const
			{
				for (unsigned int i = 0; i < _maxIndex; ++i)
				{
					if (_controllers[i].isConnected == 0)
						return i;
				}
				return -1;
			}

			// prehaps make return vaule GRETURN
			CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy) const
			{
				if (_stateToCopy->maxInputs == _outCopy->maxInputs)
					for (int i = 0; i < _outCopy->maxInputs; ++i)
					{
						_outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
					}
				else
					_outCopy = nullptr;

				return _outCopy;
			}

			void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage) const
			{
				float range = _axisMax - _axisMin;
				_outX = (((_x - _axisMin) * 2) / range) - 1;
				_outY = (((_y - _axisMin) * 2) / range) - 1;
				float liveRange = 1.0f - _deadzonePercentage;
				if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
				{
					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;

					if (_outX > 0.0f)
						_outX = (_outX - _deadzonePercentage) / liveRange;
					else if (_outX < 0.0f)
						_outX = (_outX + _deadzonePercentage) / liveRange;
					if (_outY > 0.0f)
						_outY = (_outY - _deadzonePercentage) / liveRange;
					else if (_outY < 0.0f)
						_outY = (_outY + _deadzonePercentage) / liveRange;
				}
				else
				{
					float mag = std::sqrt(_outX * _outX + _outY * _outY);
					mag = (mag - _deadzonePercentage) / liveRange;
					_outX *= mag;
					_outY *= mag;

					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;
				}
			}
		public:
			GGeneralController() {}

			virtual void Initialize()
			{
				pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;

				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
					for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
					{
						pControllers[i].controllerInputs[j] = 0.0f;
					}
				}
			}

			virtual void Release()
			{
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isConnected == 0)
				{
					UnlockAsyncRead();
					return GReturn::FAILURE;
				}

				_outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn GetMaxIndex(int& _outMax) override
			{
				_outMax = G_MAX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			virtual GReturn GetNumConnected(int& _outConnectedCount) override
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
			{
				if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
					return GReturn::INVALID_ARGUMENT;
				LockSyncWrite();
				deadZoneType = _type;
				deadZonePercentage = _deadzonePercentage;
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn StopVibration(unsigned int _controllerIndex) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn StopAllVibrations() override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
			GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
			GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
			GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
		};

		class GXboxController : public GGeneralController
		{
		private:
			GW::SYSTEM::GDaemon xinputDaemon;
			int XControllerSlotIndices[4];
			DWORD XControllerLastPacket[4];

			struct DaemonData
			{
				DWORD result;
				XINPUT_STATE controllerState;
				EVENT_DATA eventData;
				CONTROLLER_STATE oldState;

				DaemonData()
				{
					ZeroMemory(&controllerState, sizeof(XINPUT_STATE));
					ZeroMemory(&eventData, sizeof(EVENT_DATA));
					oldState.maxInputs = G_MAX_XBOX_INPUTS;
					oldState.controllerInputs = new float[G_MAX_XBOX_INPUTS];
				}

				~DaemonData()
				{
					delete[] oldState.controllerInputs;
				}
			} daemonData;

			float XboxDeadZoneCalc(float _value, bool _isTigger)
			{
				if (_isTigger)
				{
					if (std::abs(_value) > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)
						_value /= G_MAX_XBOX_TRIGGER_AXIS;
					else
						_value = 0;
				}
				else
				{
					if (std::abs(_value) > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
						_value /= G_MAX_XBOX_THUMB_AXIS;
					else
						_value = 0;
				}
				return _value;
			}
		public:
			GXboxController()
				: GGeneralController()
			{
				ZeroMemory(XControllerLastPacket, ARRAYSIZE(XControllerLastPacket));
				for (int i = 0; i < 4; ++i)
					XControllerSlotIndices[i] = -1;
			}

			virtual void Initialize()
			{
				pControllers = new CONTROLLER_STATE[G_MAX_XBOX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;
				for (unsigned int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_XBOX_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_XBOX_INPUTS];
				}
				// Event callback for xinput
				xinputDaemon.Create(G_CONTROLLER_DAEMON_OPERATION_INTERVAL, [&]()
				{
					/* --- NOTE ---
					 * pControllers:
					 *      Locked when being read or written to because it can be read and written to outside
					 *      of this function. All other function should lock when reading or writing to it.
					 * XControllerSlotIndices:
					 *      Only Locked whenever written to because it is only written to inside of this function. 
					 *      All other functions should lock before reading this array while xinputDaemon is running.
					 * All other member variables are not used outside of this function. Therefore, they don't need locks.
					 */
					CoInitialize(nullptr); // place this thread in COM single threaded appartment
					GW::GEvent m_GEvent;
					for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
					{
						daemonData.result = XInputGetState(i, &daemonData.controllerState);
						if (daemonData.result == ERROR_SUCCESS)
						{
							if (XControllerSlotIndices[i] < 0)
							{
								LockSyncWrite();
								XControllerSlotIndices[i] = FindEmptyControllerIndex(G_MAX_XBOX_CONTROLLER_INDEX, pControllers);
								pControllers[XControllerSlotIndices[i]].isConnected = 1;
								UnlockSyncWrite();

								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];
								daemonData.eventData.inputCode = 0;
								daemonData.eventData.inputValue = 0;
								daemonData.eventData.isConnected = 1;
								daemonData.eventData.controllerID = GW::INPUT::GControllerType::XBOX360;

								m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, daemonData.eventData);
								Push(m_GEvent);
							}

							if (XControllerSlotIndices[i] >= 0 && daemonData.controllerState.dwPacketNumber != XControllerLastPacket[i]) // add checks for events
							{
								LockAsyncRead();
								CopyControllerState(&pControllers[XControllerSlotIndices[i]], &daemonData.oldState);
								UnlockAsyncRead();
								daemonData.eventData.isConnected = 1;
								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];

								XControllerLastPacket[i] = daemonData.controllerState.dwPacketNumber;

								// Buttons
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_A) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_SOUTH_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_SOUTH_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_A) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_SOUTH_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_SOUTH_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_B) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_EAST_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_EAST_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_B) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_EAST_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_EAST_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_Y) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_NORTH_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_NORTH_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_Y) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_NORTH_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_NORTH_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_X) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_WEST_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_WEST_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_X) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_WEST_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_WEST_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_LEFT_SHOULDER_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_SHOULDER_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_LEFT_SHOULDER_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_SHOULDER_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_RIGHT_SHOULDER_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_SHOULDER_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_RIGHT_SHOULDER_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_SHOULDER_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_LEFT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_LEFT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_LEFT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_LEFT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_RIGHT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_RIGHT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_RIGHT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_RIGHT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_UP_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_UP_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_UP_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_UP_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_DOWN_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_DOWN_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_DOWN_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_DOWN_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_LEFT_THUMB_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_THUMB_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_LEFT_THUMB_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_THUMB_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_RIGHT_THUMB_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_THUMB_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_RIGHT_THUMB_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_THUMB_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_START) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_START_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_START_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_START) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_START_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_START_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_SELECT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_SELECT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_SELECT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_SELECT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								// AXES
								if (XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bLeftTrigger, true) != daemonData.oldState.controllerInputs[G_LEFT_TRIGGER_AXIS])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_TRIGGER_AXIS] = XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bLeftTrigger, true);
									daemonData.eventData.inputCode = G_LEFT_TRIGGER_AXIS;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_TRIGGER_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bRightTrigger, true) != daemonData.oldState.controllerInputs[G_RIGHT_TRIGGER_AXIS])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_TRIGGER_AXIS] = XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bRightTrigger, true);
									daemonData.eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_TRIGGER_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								LockSyncWrite();

								DeadZoneCalculation(daemonData.controllerState.Gamepad.sThumbLX,
									daemonData.controllerState.Gamepad.sThumbLY,
									G_MAX_XBOX_THUMB_AXIS,
									G_MIN_XBOX_THUMB_AXIS,
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS],
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS],
									deadZoneType,
									deadZonePercentage);

								DeadZoneCalculation(daemonData.controllerState.Gamepad.sThumbRX,
									daemonData.controllerState.Gamepad.sThumbRY,
									G_MAX_XBOX_THUMB_AXIS,
									G_MIN_XBOX_THUMB_AXIS,
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS],
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS],
									deadZoneType,
									deadZonePercentage);

								float newLX = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS];
								float newLY = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS];
								float newRX = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS];
								float newRY = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS];

								UnlockSyncWrite();

								if (newLX != daemonData.oldState.controllerInputs[G_LX_AXIS])
								{
									daemonData.eventData.inputCode = G_LX_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (newLY != daemonData.oldState.controllerInputs[G_LY_AXIS])
								{
									daemonData.eventData.inputCode = G_LY_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								if (newRX != daemonData.oldState.controllerInputs[G_RX_AXIS])
								{
									daemonData.eventData.inputCode = G_RX_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								if (newRY != daemonData.oldState.controllerInputs[G_RY_AXIS])
								{
									daemonData.eventData.inputCode = G_RY_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
							}
						}
						else // no controller connected
						{
							if (XControllerSlotIndices[i] >= 0)
							{
								//call event

								LockSyncWrite();
								pControllers[XControllerSlotIndices[i]].isConnected = 0;
								pControllers[XControllerSlotIndices[i]].isVibrating = 0;
								pControllers[XControllerSlotIndices[i]].vibrationDuration = 0.0f;
								UnlockSyncWrite();

								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];
								daemonData.eventData.inputCode = 0;
								daemonData.eventData.inputValue = 0;
								daemonData.eventData.isConnected = 0;
								daemonData.eventData.controllerID = GW::INPUT::GControllerType::XBOX360;

								m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERDISCONNECTED, daemonData.eventData);
								Push(m_GEvent);

								LockSyncWrite();
								XControllerSlotIndices[i] = -1;
								UnlockSyncWrite();
							}
						}

						LockAsyncRead();
						if (XControllerSlotIndices[i] >= 0 && pControllers[XControllerSlotIndices[i]].isVibrating)
						{
							if (pControllers[XControllerSlotIndices[i]].vibrationDuration <=
								(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() -
									*pControllers[XControllerSlotIndices[i]].vibrationStartTime).count() * .001f))
							{
								UnlockAsyncRead();

								XINPUT_VIBRATION vibrationState;
								vibrationState.wLeftMotorSpeed = 0;
								vibrationState.wRightMotorSpeed = 0;

								LockSyncWrite();
								pControllers[XControllerSlotIndices[i]].isVibrating = 0;
								pControllers[XControllerSlotIndices[i]].vibrationDuration = 0.0f;
								UnlockSyncWrite();

								XInputSetState(i, &vibrationState);

								LockAsyncRead();
							}
						}
						UnlockAsyncRead();
					}
				});
			}

			virtual void Release()
			{
				xinputDaemon = nullptr; // Stop the input thread.

				for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override final
			{
				if (_controllerIndex >= G_MAX_XBOX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode  > 19)
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isConnected == 0)
				{
					UnlockAsyncRead();
					return GReturn::FAILURE;
				}

				_outState = pControllers[_controllerIndex].controllerInputs[_inputCode];
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override final
			{
				if (_controllerIndex >= G_MAX_XBOX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn GetMaxIndex(int& _outMax) override final
			{
				_outMax = G_MAX_XBOX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			GReturn GetNumConnected(int& _outConnectedCount) override final
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX)
					|| (_pan < -1.0f || _pan > 1.0f)
					|| _duration < 0.0f
					|| (_strength < -1.0f || _strength > 1.0f))
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isVibrating)
				{
					UnlockAsyncRead();
					return GReturn::REDUNDANT;
				}
				UnlockAsyncRead();

				XINPUT_VIBRATION vibrationState;
				unsigned int vibrationStrength = static_cast<unsigned int>(G_XINPUT_MAX_VIBRATION * _strength);
				vibrationState.wLeftMotorSpeed = static_cast<WORD>(vibrationStrength * (.5f + (.5f * (-1 * _pan))));
				vibrationState.wRightMotorSpeed = static_cast<WORD>(vibrationStrength * (.5f + (.5f * _pan)));

				LockSyncWrite();
				for (int i = 0; i < 4; ++i)
				{
					if (_controllerIndex == static_cast<unsigned int>(XControllerSlotIndices[i]))
					{
						pControllers[i].isVibrating = 1;
						pControllers[i].vibrationDuration = _duration;
						*pControllers[i].vibrationStartTime = std::chrono::high_resolution_clock::now();
						XInputSetState(i, &vibrationState);
						break;
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX))
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsVibrating = pControllers[_controllerIndex].isVibrating == 0 ? false : true;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn StopVibration(unsigned int _controllerIndex) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX))
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isVibrating == false)
				{
					UnlockAsyncRead();
					return GReturn::REDUNDANT;
				}
				UnlockAsyncRead();

				XINPUT_VIBRATION vibrationState;
				vibrationState.wLeftMotorSpeed = 0;
				vibrationState.wRightMotorSpeed = 0;

				LockSyncWrite();
				for (int i = 0; i < 4; ++i)
				{
					if (_controllerIndex == static_cast<unsigned int>(XControllerSlotIndices[i]))
					{
						pControllers[i].isVibrating = 0;
						pControllers[i].vibrationDuration = 0.0f;
						XInputSetState(i, &vibrationState);
						break;
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			GReturn StopAllVibrations() override final
			{
				XINPUT_VIBRATION vibrationState;
				vibrationState.wLeftMotorSpeed = 0;
				vibrationState.wRightMotorSpeed = 0;

				LockSyncWrite();
				for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isVibrating)
					{
						pControllers[i].isVibrating = 0;
						pControllers[i].vibrationDuration = 0.0f;
						XInputSetState(i, &vibrationState);
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}
		};

		// Need to put definitions here instead of class body because it needs to know function definitions
		inline GControllerImplementation::~GControllerImplementation()
		{
			if (pController)
			{
				pController->Release();
				delete pController;
				pController = nullptr;
			}
		}

		inline GReturn GControllerImplementation::Create()
		{
			pController = new GXboxController();
			pController->Initialize();

			return GReturn::SUCCESS;
		}
		inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
		inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
		inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
		inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
	} // end I namespace
} // end GW namespace

#endif


namespace GW
{
	namespace INPUT
	{
		class GController final
			: public I::GProxy<I::GControllerInterface, I::GControllerImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GController);
			GATEWARE_TYPEDEF(Events);
			GATEWARE_TYPEDEF(EVENT_DATA);
			GATEWARE_TYPEDEF(DeadZoneTypes);
			GATEWARE_FUNCTION(GetState);
			GATEWARE_FUNCTION(IsConnected);
			GATEWARE_FUNCTION(GetMaxIndex);
			GATEWARE_FUNCTION(GetNumConnected);
			GATEWARE_FUNCTION(SetDeadZone);
			GATEWARE_FUNCTION(StartVibration);
			GATEWARE_FUNCTION(IsVibrating);
			GATEWARE_FUNCTION(StopVibration);
			GATEWARE_FUNCTION(StopAllVibrations);

			// reimplemented functions
			GATEWARE_FUNCTION(Register);
			GATEWARE_CONST_FUNCTION(Observers);
			GATEWARE_FUNCTION(Push);

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}// end SYSTEM namespace
}// end GW namespace
#endif // #endif GCONTROLLER_H

/*---------------------------------
|	End of GController.h
----------------------------------*/


/*---------------------------------
|	Begin of GInput.h
----------------------------------*/
#ifndef GINPUT_H
#define GINPUT_H






namespace GW
{
	namespace I
	{
		class GInputInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn GetState(int _keyCode, float& _outState) = 0;
			virtual GReturn GetMouseDelta(float& _x, float& _y) = 0;
			virtual GReturn GetMousePosition(float& _x, float& _y) const = 0;
			virtual GReturn GetKeyMask(unsigned int& _outKeyMask) const = 0;
		};
	}// end I
}// end GW 

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GInput.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_ESCAPE,			// 1
			G_KEY_1,				// 2
			G_KEY_2,				// 3
			G_KEY_3,				// 4
			G_KEY_4,				// 5
			G_KEY_5,				// 6
			G_KEY_6,				// 7
			G_KEY_7,				// 8
			G_KEY_8,				// 9
			G_KEY_9,				// 10
			G_KEY_0,				// 11
			G_KEY_MINUS,			// 12
			G_KEY_EQUALS,			// 13
			G_KEY_BACKSPACE,		// 14
			G_KEY_TAB,				// 15
			G_KEY_Q,				// 16
			G_KEY_W,				// 17
			G_KEY_E,				// 18
			G_KEY_R,				// 19
			G_KEY_T,				// 20
			G_KEY_Y,				// 21
			G_KEY_U,				// 22
			G_KEY_I,				// 23
			G_KEY_O,				// 24
			G_KEY_P,				// 25
			G_KEY_BRACKET_OPEN,		// 26
			G_KEY_BRACKET_CLOSE,	// 27
			G_KEY_ENTER,			// 28
			G_KEY_CONTROL,			// 29
			G_KEY_A,				// 30
			G_KEY_S,				// 31
			G_KEY_D,				// 32
			G_KEY_F,				// 33
			G_KEY_G,				// 34
			G_KEY_H,				// 35
			G_KEY_J,				// 36
			G_KEY_K,				// 37
			G_KEY_L,				// 38
			G_KEY_COLON,			// 39
			G_KEY_QUOTE,			// 40
			G_KEY_TILDE,			// 41
			G_KEY_LEFTSHIFT,		// 42
			G_KEY_BACKSLASH,		// 43
			G_KEY_Z,				// 44
			G_KEY_X,				// 45
			G_KEY_C,				// 46
			G_KEY_V,				// 47
			G_KEY_B,				// 48
			G_KEY_N,				// 49
			G_KEY_M,				// 50
			G_KEY_COMMA,			// 51
			G_KEY_PERIOD,			// 52
			G_KEY_FOWARDSLASH,		// 53
			G_KEY_RIGHTSHIFT,		// 54
			G_KEY_PRINTSCREEN,		// 55
			G_KEY_LEFTALT,			// 56
			G_KEY_SPACE,			// 57
			G_KEY_CAPSLOCK,			// 58
			G_KEY_F1,				// 59
			G_KEY_F2,				// 60
			G_KEY_F3,				// 61
			G_KEY_F4,				// 62
			G_KEY_F5,				// 63
			G_KEY_F6,				// 64
			G_KEY_F7,				// 65
			G_KEY_F8,				// 66
			G_KEY_F9,				// 67
			G_KEY_F10,				// 68
			G_KEY_NUMLOCK,			// 69
			G_KEY_SCROLL_LOCK,		// 70
			G_KEY_HOME,				// 71
			G_KEY_UP,				// 72
			G_KEY_PAGEUP,			// 73
			G_KEY_NUMPAD_MINUS,		// 74
			G_KEY_LEFT,				// 75
			G_KEY_CENTER,			// 76
			G_KEY_RIGHT,			// 77
			G_KEY_NUMPAD_PLUS,		// 78
			G_KEY_END,				// 79
			G_KEY_DOWN,				// 80
			G_KEY_PAGEDOWN,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_DELETE,			// 83
			G_KEY_UNKNOWN,			// 84
			G_KEY_UNKNOWN,			// 85
			G_KEY_UNKNOWN,			// 86
			G_KEY_F11,				// 87
			G_KEY_F12,				// 88
			G_KEY_UNKNOWN,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UNKNOWN,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_UNKNOWN,			// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_UNKNOWN,			// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_UNKNOWN,			// 115
			G_KEY_UNKNOWN,			// 116
			G_KEY_UNKNOWN,			// 117
			G_KEY_UNKNOWN,			// 118
			G_KEY_UNKNOWN,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_CONTROL,			// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_COLON,			// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FOWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_MULTIPLY,			// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_UNKNOWN,			// 78
			G_KEY_HOME,				// 79
			G_KEY_UP,				// 80
			G_KEY_PAGEUP,			// 81
			G_KEY_MINUS,			// 82
			G_KEY_LEFT,				// 83
			G_KEY_CENTER,			// 84
			G_KEY_RIGHT,			// 85
			G_KEY_ADD,				// 86
			G_KEY_END,				// 87
			G_KEY_DOWN,				// 88
			G_KEY_PAGEDOWN,			// 89
			G_KEY_INSERT,			// 90
			G_KEY_PERIOD,			// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96

			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_ENTER,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_DIVIDE,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_SCROLL_LOCK,		// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN			// 126
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[127] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_COLON,			// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FOWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_CONTROL,			// 55
			G_KEY_LEFTSHIFT,		// 5
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_CONTROL,			// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_CONTROL,			// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_DELETE,			// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_MULTIPLY,			// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_PLUS,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_UNKNOWN,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_DIVIDE,			// 75
			G_KEY_ENTER,			// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_MINUS,			// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_INSERT,			// 82
			G_KEY_END,				// 83
			G_KEY_DOWN,				// 84
			G_KEY_PAGEDOWN,			// 85
			G_KEY_LEFT,				// 86
			G_KEY_CENTER,			// 87
			G_KEY_RIGHT,			// 88
			G_KEY_HOME,				// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_UP,				// 91
			G_KEY_PAGEUP,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_UNKNOWN,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP				// 126
		};
#endif
	}
}
#endif
 // every implementation besides dummy uses this.
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GINPUT) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GINPUT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GInput

namespace GW
{
	namespace I
	{
		class GInputImplementation : public virtual GInputInterface
		{
		public:
			GReturn GetState(int _keyCode, float& _outState) override
			{
				return GReturn::FAILURE;
			}
			GReturn GetMouseDelta(float& _x, float& _y) override
			{
				return GReturn::FAILURE;
			}
			GReturn GetMousePosition(float& _x, float& _y) const override
			{
				return GReturn::FAILURE;
			}
			GReturn GetKeyMask(unsigned int& _outKeyMask) const override
			{
				return GReturn::FAILURE;
			}
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _dummyHandle)
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(const GW::SYSTEM::GWindow _dummyWindow)
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
		};
	}
}


#elif defined(__APPLE__)
	#ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif

#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define TURNON_BIT(var,pos) ((var) |=  (1<<(pos)))
#define TURNOFF_BIT(var,pos) ((var) &= ~(1<<(pos)))
#define TOGGLE_BIT(var, pos) (CHECK_BIT(var, pos) ? (TURNOFF_BIT(var,pos)) : (TURNON_BIT(var,pos)))

#include <chrono>



namespace internal_gw
{
    struct GINPUT_GLOBAL
    {
        GW::SYSTEM::GDaemon myDaemon;
        int mousePositionX;
        int mousePositionY;
        int mouseDeltaX;
        int mouseDeltaY;
        int upPings;
        int downPings;
        unsigned int keyMask;
        unsigned int mouseReadCount;
        unsigned int mouseWriteCount;

        unsigned int n_Keys[256];
    };

    static GINPUT_GLOBAL& GInputGlobal()
    {
        static GINPUT_GLOBAL keyData;
        return keyData;
    }

    // GIResponder Interface
    // The GIResponder is our interpretation of the NSReponder to recieve events.

    // Forward declarations of GResponder methods
    // Overide NSResponder functions
    G_OBJC_HEADER_INSTANCE_METHOD(GIResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, bool, acceptsFirstMouse, NSEvent* event);
    //G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, BOOL, performKeyEquivalent, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, scrollWheel, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseMoved, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, GetKeyMask, NSEvent* theEvent);

    // Creates the GIResponder class at runtime when G_OBJC_GET_CLASS(GIResponder) is called
    G_OBJC_CLASS_BEGIN(GIResponder, NSResponder)
    {
        G_OBJC_CLASS_METHOD(GIResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, acceptsFirstMouse, "B@:@", :);
        //G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, performKeyEquivalent, "B@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, keyDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, keyUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, scrollWheel, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, rightMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, rightMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, otherMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, otherMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseMoved, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, GetKeyMask, "v@:@", :);
    }
    G_OBJC_CLASS_END(GIResponder)
    
    // GIResponder Interface End
}

namespace GW
{
    namespace I
    {
        class GInputImplementation : public virtual GInputInterface,
            private GThreadSharedImplementation
        {

        private:
            NSWindow* currentResponder;
            id responder;

            static void RUN_ON_UI_THREAD(dispatch_block_t block)
            {
                if ([NSThread isMainThread])
                    block();
                else
                    dispatch_sync(dispatch_get_main_queue(), block);
            }

        public:

            ~GInputImplementation()
            {
                [currentResponder setNextResponder : nil] ;
                [responder release] ;
            }

            GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle)
            {
                responder = [internal_gw::G_OBJC_GET_CLASS(GIResponder) alloc];

                if (_windowHandle.window == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                //Need to convert data back into an NSWindow*.
                //NSWindow * currentResponder = ((__bridge NSWindow*)_data);
                currentResponder = ((__bridge NSWindow*)_windowHandle.window);

                //We only want to process the message and pass it on. So if there is already
                //a responder we set our responders next responder to be the current next responder.
                [responder setNextResponder : currentResponder.nextResponder];

                //We then set out responder to the next responder of the window.
                [currentResponder setNextResponder : responder] ;

                //We also need to make our responder the first responder of the window.
                [currentResponder makeFirstResponder : responder] ;

                RUN_ON_UI_THREAD(^ {
                    //In order to get mouse button presses we need to set our responder to be
                    //the next responder in the contentView as well.
                    [currentResponder.contentView setNextResponder : responder] ;
                    });

                return GReturn::SUCCESS;
            }

            GReturn Create(GW::SYSTEM::GWindow _gWindow)
            {
                GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

                if (-_gWindow.GetWindowHandle(uwHndl))
                    return GW::GReturn::FAILURE;

                return Create(uwHndl);
            }

            GReturn GetState(int _keyCode, float& _outState) override
            {
                _outState = static_cast<float>(internal_gw::GInputGlobal().n_Keys[_keyCode]);
                return GW::GReturn::SUCCESS;
            }

            GReturn GetMouseDelta(float& _x, float& _y) override
            {
                _x = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaX);
                _y = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaY);
                if (internal_gw::GInputGlobal().mouseReadCount != internal_gw::GInputGlobal().mouseWriteCount)
                {
                    internal_gw::GInputGlobal().mouseReadCount = internal_gw::GInputGlobal().mouseWriteCount;
                    return GW::GReturn::SUCCESS;
                }
                return GW::GReturn::REDUNDANT;
            }

            GReturn GetMousePosition(float& _x, float& _y) const override
            {
                _x = static_cast<float>(internal_gw::GInputGlobal().mousePositionX);
                _y = static_cast<float>(internal_gw::GInputGlobal().mousePositionY);

                return GW::GReturn::SUCCESS;
            }

            GReturn GetKeyMask(unsigned int& _outKeyMask) const override
            {
                _outKeyMask = internal_gw::GInputGlobal().keyMask;
                return GW::GReturn::SUCCESS;
            }
        };

    }
}

namespace internal_gw
{
    // GIResponder Implementation

    G_OBJC_HEADER_INSTANCE_METHOD(GIResponder, bool, acceptFirstResponder)
    {
        return YES;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, bool, acceptsFirstMouse, NSEvent* event)
    {
        return YES;
    }

    /*G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, BOOL, performKeyEquivalent, NSEvent* theEvent)
    {
        GW::I::GInputImplementation::n_Keys[GW::I::GInputImplementation::Keycodes [[theEvent keyCode]] ] = 1;
        //Get the keymask.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder] keyDown : theEvent];

        return YES;
    }*/

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyDown, NSEvent* theEvent)
    {
        //Set the key to pressed after getting it from the static table of keys.
        GInputGlobal().n_Keys[GW::I::Keycodes [[theEvent keyCode]] ] = 1;
        //Get the keymask.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[GW::I::Keycodes [[theEvent keyCode]] ] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_LEFT] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_LEFT] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, scrollWheel, NSEvent* theEvent)
    {
        ////Scrolling Up
        if (theEvent.deltaY > 0)
        {
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 1;
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
        }
        ////Scrolling down
        if (theEvent.deltaY < 0)
        {
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 1;
        }

        std::chrono::time_point<std::chrono::steady_clock> start = std::chrono::steady_clock::now();

        if (GInputGlobal().myDaemon == nullptr)
        {
            GInputGlobal().myDaemon.Create(6, [&]()
            {
                auto end = std::chrono::steady_clock::now();

                if (std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() >= 50000)
                {
                    GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
                    GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
                    return;
                }
            });
        }

        if ([self nextResponder] != nil)
            [[self nextResponder]scrollWheel:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_RIGHT] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_RIGHT] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_MIDDLE] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_MIDDLE] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseMoved, NSEvent* theEvent)
    {
        NSPoint mousePosition = [theEvent locationInWindow];

        GInputGlobal().mousePositionX = mousePosition.x;
        GInputGlobal().mousePositionY = mousePosition.y;

        if ([self nextResponder] != nil)
            [[self nextResponder]mouseMoved:theEvent];

    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, GetKeyMask, NSEvent* theEvent)
    {
        GInputGlobal().keyMask = 0;
        //Get the unsigned int of all the modifier flags.
        NSUInteger xflags = [theEvent modifierFlags];
        //Check individual modifier flags and turn them on respectivly to our keymask(unsigned int).
        if (xflags & NSEventModifierFlagShift)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_SHIFT);
        }
        if (xflags & NSEventModifierFlagOption)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_ALT);
        }
        if (xflags & NSEventModifierFlagCommand)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_COMMAND);
        }
        if (xflags & NSEventModifierFlagControl)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_CONTROL);
        }
        if (xflags & NSEventModifierFlagCapsLock)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_CAPS_LOCK);
        }
        if (xflags & NSEventModifierFlagFunction)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_FUNCTION);
        }
        if (xflags & NSEventModifierFlagNumericPad)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_NUM_LOCK);
        }
    }

    // GIResponder Implementation End
}

#undef CHECK_BIT
#undef TURNON_BIT
#undef TURNOFF_BIT
#undef TOGGLE_BIT


#elif defined(__linux__)
	#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>



namespace GW
{
	namespace I
	{
		class GInputImplementation : public virtual GInputInterface,
			protected GInterfaceImplementation
		{
		private:
			int _mousePrevX = 0;
			int _mousePrevY = 0;
			int _mousePositionX = 0;
			int _mousePositionY = 0;
			int _mouseDeltaX = 0;
			int _mouseDeltaY = 0;
			unsigned int keyMask = 0;
			unsigned int mouseReadCount = 0;
			unsigned int mouseWriteCount = 0;

			// Daemon data
			int _code = -1;
			Window root, child;
            int _mouseScreenPositionX = 0, _mouseScreenPositionY = 0;
			char keys_return[32];

			// Window data
			Display* _display = nullptr;
			Window _window;
            
			unsigned int keyStates[256] = { 0 };
            GW::SYSTEM::GDaemon inputDaemon;
			GW::CORE::GEventReceiver watcher;		
		public:
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle)
			{
				if (_windowHandle.window == nullptr || _windowHandle.display == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Copy data from UNIVERSAL_WINDOW_HANDLE(void * display, void * window) structure.
				_window = *((Window*)(_windowHandle.window));
				_display = ((Display*)(_windowHandle.display));

				//Select the type of Input events we wish to recieve.
				///XSelectInput(_display, _window, ExposureMask | ButtonPressMask | ButtonReleaseMask | KeyReleaseMask | KeyPressMask | LockMask | ControlMask | ShiftMask);
				
				XInitThreads();// daemon run on another thread
                // Creates a daemon that parses all the input on the other thread
                inputDaemon.Create(G_INPUT_OPERATION_INTERVAL, [&]()
                {
					XQueryKeymap(_display, keys_return);
					for (unsigned int i = 0; i < 127; ++i)
					{
						_code = Keycodes[i];
					
						//Set keyboard input
						keyStates[_code] = (keys_return[(i >> 3)] & (1 << (i & 7))) ? 1 : 0;
					}
					
					XQueryPointer(_display, _window, &root, &child, &_mouseScreenPositionX, &_mouseScreenPositionY, &_mousePositionX, &_mousePositionY, &keyMask);

					//Set the mouse input
					keyStates[G_BUTTON_LEFT] = (keyMask & Button1Mask) ? 1 : 0;
					keyStates[G_BUTTON_RIGHT] = (keyMask & Button3Mask) ? 1 : 0;
					keyStates[G_BUTTON_MIDDLE] = (keyMask & Button2Mask) ? 1 : 0;

					//Set the change in mouse position.
					_mouseDeltaX = _mousePrevX - _mousePositionX;
					_mouseDeltaY = _mousePrevY - _mousePositionY;

					//Set the previous mouse position as the current.
					_mousePrevX = _mousePositionX;
					_mousePrevY = _mousePositionY;
                });

				return GReturn::SUCCESS;
			}

			GReturn Create(const GW::SYSTEM::GWindow _gWindow)
			{
				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

				if (-_gWindow.GetWindowHandle(uwHndl))
					return GW::GReturn::FAILURE;
				
				// stop if window is killed
				watcher.Create(_gWindow, [&](){
					if (+watcher.Find(GW::SYSTEM::GWindow::Events::DESTROY, true))
						inputDaemon = nullptr;
				});
				
				return Create(uwHndl);
			}

			GReturn GetState(int _keyCode, float& _outState) override
			{
				if (_keyCode == G_MOUSE_SCROLL_DOWN || _keyCode == G_MOUSE_SCROLL_UP)
					return GW::GReturn::FEATURE_UNSUPPORTED;
				_outState = (float)keyStates[_keyCode];
				return GW::GReturn::SUCCESS;
			}

			GReturn GetMouseDelta(float& _x, float& _y) override
			{
				_x = static_cast<float>(_mouseDeltaX);
				_y = static_cast<float>(_mouseDeltaY);
				if (mouseReadCount != mouseWriteCount)
				{
					mouseReadCount = mouseWriteCount;
					return GW::GReturn::SUCCESS;
				}
				return GW::GReturn::REDUNDANT;
			}

			GReturn GetMousePosition(float& _x, float& _y) const override
			{
				_x = static_cast<float>(_mousePositionX);
				_y = static_cast<float>(_mousePositionY);

				return GW::GReturn::SUCCESS;
			}

			GReturn GetKeyMask(unsigned int& _outKeyMask) const override
			{
				_outKeyMask = keyMask;
				return GW::GReturn::SUCCESS;
			}
		};
	}
}

#elif defined(_WIN32)
	#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <vector>

namespace internal_gw
{
	struct GINPUT_GLOBAL
	{
		int mousePrevX;
		int mousePrevY;
		int mousePositionX;
		int mousePositionY;
		int mouseDeltaX;
		int mouseDeltaY;
		unsigned int keyMask;

		unsigned int mouseReadCount;
		unsigned int mouseWriteCount;
		unsigned int scrollUpWriteCount;
		unsigned int scrollUpReadCount;
		unsigned int scrollDownWriteCount;
		unsigned int scrollDownReadCount;
		LONG_PTR _userWinProc;

		unsigned int n_Keys[256];
	};
	static GINPUT_GLOBAL& GInputGlobal()
	{
		static GINPUT_GLOBAL keyData;
		return keyData;
	}
}

namespace GW
{
	namespace I
	{
		class GInputImplementation : public virtual GInputInterface,
			private GInterfaceImplementation
		{
		private:
			HWND hWnd = nullptr;
			static LRESULT CALLBACK GWinProc(HWND window, unsigned int msg, WPARAM wp, LPARAM lp)
			{
				switch (msg)
				{
				case WM_INPUT:
				{
					UINT dwSize = 0;

					//Get the size of RawInput
					GetRawInputData((HRAWINPUT)lp, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));

					LPBYTE lpb = new BYTE[dwSize];

					if (GetRawInputData((HRAWINPUT)lp, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
					{
						delete[] lpb;
						return LRESULT(false);
					}

					RAWINPUT* raw = (RAWINPUT*)lpb;

					unsigned int data = 0;

					if (raw->header.dwType == RIM_TYPEKEYBOARD)
					{
						//Get G_KEY
						data = Keycodes[raw->data.keyboard.MakeCode];
						//Set state released or pressed.
						switch (raw->data.keyboard.Message)
						{
						case 256:
							internal_gw::GInputGlobal().n_Keys[data] = 1;
							switch (data)
							{
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_CONTROL:
								G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CONTROL);
								break;
							case G_KEY_CAPSLOCK:
								G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CAPS_LOCK);
								break;
							case G_KEY_NUMLOCK:
								G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_NUM_LOCK);
								break;
							case G_KEY_SCROLL_LOCK:
								G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SCROLL_LOCK);
								break;
							}
							break;
						case 257:
							internal_gw::GInputGlobal().n_Keys[data] = 0;
							switch (data)
							{
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNOFF_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_CONTROL:
								G_TURNOFF_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CONTROL);
								break;
							}
							break;
						}

					}
					else if (raw->header.dwType == RIM_TYPEMOUSE)
					{
						++internal_gw::GInputGlobal().mouseWriteCount;

						switch (raw->data.mouse.ulButtons)
						{
						case 1:
						case 2:
							data = G_BUTTON_LEFT;
							break;
						case 4:
						case 8:
							data = G_BUTTON_RIGHT;
							break;
						case 16:
						case 32:
							data = G_BUTTON_MIDDLE;
							break;
						}

						switch (raw->data.mouse.usButtonData) {
						case 120:
						{
							data = G_MOUSE_SCROLL_UP;
							++internal_gw::GInputGlobal().scrollUpWriteCount;
							break;
						}
						case 65416:
						{
							data = G_MOUSE_SCROLL_DOWN;
							++internal_gw::GInputGlobal().scrollDownWriteCount;
							break;
						}
						}

						switch (raw->data.mouse.usButtonFlags)
						{
							//pressed
						case 1:
						case 4:
						case 16:
							internal_gw::GInputGlobal().n_Keys[data] = 1;
							break;
							//Released
						case 2:
						case 8:
						case 32:
							internal_gw::GInputGlobal().n_Keys[data] = 0;
							break;
						case 1024:
							internal_gw::GInputGlobal().n_Keys[data] = 1;
							break;
						}

						//update delta mouse position
						if ((internal_gw::GInputGlobal().mouseWriteCount - 
							internal_gw::GInputGlobal().mouseReadCount) <= 1)
						{
							internal_gw::GInputGlobal().mouseDeltaX = raw->data.mouse.lLastX;
							internal_gw::GInputGlobal().mouseDeltaY = raw->data.mouse.lLastY;
						}
						else
						{
							internal_gw::GInputGlobal().mouseDeltaX += raw->data.mouse.lLastX;
							internal_gw::GInputGlobal().mouseDeltaY += raw->data.mouse.lLastY;
						}

					}

					if (data != G_MOUSE_SCROLL_UP) {
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
						internal_gw::GInputGlobal().scrollUpReadCount = internal_gw::GInputGlobal().scrollUpWriteCount;
					}
					if (data != G_MOUSE_SCROLL_DOWN) {
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
						internal_gw::GInputGlobal().scrollDownReadCount = internal_gw::GInputGlobal().scrollDownWriteCount;
					}

					POINT p;
					if (GetCursorPos(&p) && ScreenToClient(window, &p))
					{
						internal_gw::GInputGlobal().mousePositionX = static_cast<int>(p.x);
						internal_gw::GInputGlobal().mousePositionY = static_cast<int>(p.y);

						internal_gw::GInputGlobal().mousePrevX = internal_gw::GInputGlobal().mousePositionX;
						internal_gw::GInputGlobal().mousePrevY = internal_gw::GInputGlobal().mousePositionY;
					}

					delete[] lpb;
					break;
				}
				default:
					break;
				}
				return CallWindowProcW((WNDPROC)internal_gw::GInputGlobal()._userWinProc, window, msg, wp, lp);
			}

		public:
			~GInputImplementation()
			{
				if (hWnd)
					//Sets the WinProc back. (Fixes the StackOverFlow bug)
					SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)internal_gw::GInputGlobal()._userWinProc);
			}

			// GWindow - one version
			// UNIVERSAL_WINDOW_HANDLE by value - another version
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle)
			{
				if (_windowHandle.window == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				hWnd = static_cast<HWND>(_windowHandle.window);
				internal_gw::GInputGlobal()._userWinProc = SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)GWinProc);

				if (internal_gw::GInputGlobal()._userWinProc == NULL)
					return GW::GReturn::FAILURE;

				//Getting Raw Input Devices.
				UINT numDevices = 0;
				std::vector<RAWINPUTDEVICELIST> rawInputDeviceList;

				//Get Number of Devices.
				if (GetRawInputDeviceList(NULL, &numDevices, sizeof(RAWINPUTDEVICELIST)) != 0)
					return GW::GReturn::FAILURE;

				//Allocate the list of devices.
				rawInputDeviceList.resize(sizeof(RAWINPUTDEVICELIST) * numDevices);
				if (rawInputDeviceList.size() < 1)
					return GW::GReturn::FAILURE;

				int nNoOfDevices = 0;
				//Using the new List and number of devices.
				//Populate the raw input device list.
				if ((nNoOfDevices = GetRawInputDeviceList(rawInputDeviceList.data(), &numDevices, sizeof(RAWINPUTDEVICELIST))) == ((UINT)-1))
					return GW::GReturn::FAILURE;

				RID_DEVICE_INFO rdi;
				rdi.cbSize = sizeof(RID_DEVICE_INFO);

				//For all of the devices, display their correspondent information.
				for (int i = 0; i < nNoOfDevices; i++)
				{
					UINT size = 256;
					TCHAR tBuffer[256] = { 0 };
					tBuffer[0] = '\0';

					//Find the device name.
					if (!rawInputDeviceList.empty())
					{
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICENAME, tBuffer, &size) < 0)
							return GW::GReturn::FAILURE;

						UINT cbSize = rdi.cbSize;
						//Get the device information.
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICEINFO, &rdi, &cbSize) < 0)
							return GW::GReturn::FAILURE;
					}
				}

				//Register the raw input devices.
				RAWINPUTDEVICE rID[2];

				//KeyBoard
				rID[0].usUsagePage = 0x01;
				rID[0].usUsage = 0x06;
				rID[0].dwFlags = RIDEV_EXINPUTSINK;
				rID[0].hwndTarget = hWnd;

				//Mouse
				rID[1].usUsagePage = 0x01;
				rID[1].usUsage = 0x02;
				rID[1].dwFlags = RIDEV_EXINPUTSINK;
				rID[1].hwndTarget = hWnd;

				if (RegisterRawInputDevices(rID, 2, sizeof(rID[0])) == false)
					return GW::GReturn::FAILURE;

				//Capslock
				if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CAPS_LOCK);

				//Numlock
				if ((GetKeyState(VK_NUMLOCK) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_NUM_LOCK);

				//ScrollLock
				if ((GetKeyState(VK_SCROLL) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SCROLL_LOCK);


				return GW::GReturn::SUCCESS;
			}

			GReturn Create(const GW::SYSTEM::GWindow _gWindow)
			{
				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

				if (-_gWindow.GetWindowHandle(uwHndl))
					return GW::GReturn::FAILURE;

				return Create(uwHndl);
			}

			GReturn GetState(int _keyCode, float& _outState) override
			{
				if (_keyCode == G_MOUSE_SCROLL_UP && internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] == 1)
				{
					// Compare writes to the SCROLL_UP state by GWinProc to reads by the user.
					if (internal_gw::GInputGlobal().scrollUpWriteCount != internal_gw::GInputGlobal().scrollUpReadCount)
						++internal_gw::GInputGlobal().scrollUpReadCount;
					else
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0; // Prevents overreporting scroll up.
				}
				else if (_keyCode == G_MOUSE_SCROLL_DOWN && internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] == 1)
				{
					if (internal_gw::GInputGlobal().scrollDownWriteCount != internal_gw::GInputGlobal().scrollDownReadCount)
						++internal_gw::GInputGlobal().scrollDownReadCount;
					else
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
				}

				_outState = (float)internal_gw::GInputGlobal().n_Keys[_keyCode];
				return GW::GReturn::SUCCESS;
			}

			GReturn GetMouseDelta(float& _x, float& _y) override
			{
				_x = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaX);
				_y = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaY);
				if (internal_gw::GInputGlobal().mouseReadCount != internal_gw::GInputGlobal().mouseWriteCount)
				{
					internal_gw::GInputGlobal().mouseReadCount = internal_gw::GInputGlobal().mouseWriteCount;
					return GW::GReturn::SUCCESS;
				}
				return GW::GReturn::REDUNDANT;
			}

			GReturn GetMousePosition(float& _x, float& _y) const override
			{
				_x = static_cast<float>(internal_gw::GInputGlobal().mousePositionX);
				_y = static_cast<float>(internal_gw::GInputGlobal().mousePositionY);

				return GW::GReturn::SUCCESS;
			}

			GReturn GetKeyMask(unsigned int& _outKeyMask) const override
			{
				_outKeyMask = internal_gw::GInputGlobal().keyMask;
				return GW::GReturn::SUCCESS;
			}
		};
	}
}


#endif



namespace GW
{
	namespace INPUT
	{
		class GInput final
			: public I::GProxy<I::GInputInterface, I::GInputImplementation, SYSTEM::UNIVERSAL_WINDOW_HANDLE>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GInput)
			GATEWARE_FUNCTION(GetState)
			GATEWARE_FUNCTION(GetMouseDelta)
			GATEWARE_CONST_FUNCTION(GetMousePosition)
			GATEWARE_CONST_FUNCTION(GetKeyMask)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GINPUT_H


/*---------------------------------
|	End of GInput.h
----------------------------------*/



#endif // End of GATEWARE_H
